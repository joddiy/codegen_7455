{"task_id": "Mbpp/721", "completion": "\nHere is a Python script that solves the problem using dynamic programming. The script first initializes a 2D array to store the maximum average cost of each cell. Then it iterates over the cells in the matrix from top-left to bottom-right, updating the maximum average cost of each cell based on the maximum average cost of its neighboring cells. Finally, it returns the maximum average cost of the bottom-right cell.\n\n```python\ndef maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0]*n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[-1][-1] / ((n-1) * 2)\n\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n```\n\nThis script assumes that the input matrix is a square matrix and that the cost of each cell is a non-negative integer. If the input matrix is not a square matrix or if the cost of a cell is negative, the script may not work correctly.\n\nPlease note that the average is computed as total cost divided by the number of cells visited in the path. In this case, the total cost is the sum of the costs of the cells in the path and the number of cells visited is the number of cells in the path, which is n + n - 1 = n * 2. Therefore, the average is the total cost divided by 2.\n\nThis script has a time complexity of O(n^2) and a space complexity of O(n^2), where n is the size of the input matrix.\n", "all_code": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n\n### Instruction:\nCreate a Python script for this problem:\nGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path. Your code should satisfy the following assertion:\n```python\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n```\n\n### Response:\nHere is a Python script that solves the problem using dynamic programming. The script first initializes a 2D array to store the maximum average cost of each cell. Then it iterates over the cells in the matrix from top-left to bottom-right, updating the maximum average cost of each cell based on the maximum average cost of its neighboring cells. Finally, it returns the maximum average cost of the bottom-right cell.\n\n```python\ndef maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0]*n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[-1][-1] / ((n-1) * 2)\n\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n```\n\nThis script assumes that the input matrix is a square matrix and that the cost of each cell is a non-negative integer. If the input matrix is not a square matrix or if the cost of a cell is negative, the script may not work correctly.\n\nPlease note that the average is computed as total cost divided by the number of cells visited in the path. In this case, the total cost is the sum of the costs of the cells in the path and the number of cells visited is the number of cells in the path, which is n + n - 1 = n * 2. Therefore, the average is the total cost divided by 2.\n\nThis script has a time complexity of O(n^2) and a space complexity of O(n^2), where n is the size of the input matrix.\n"}
