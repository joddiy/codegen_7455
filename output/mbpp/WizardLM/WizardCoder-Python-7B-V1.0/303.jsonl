{"task_id": "Mbpp/620", "completion": "Here's a possible solution:\r\n\r\n```python\r\ndef largest_subset(numbers):\r\n    def is_divisible(a, b):\r\n        return a % b == 0 or b % a == 0\r\n    \r\n    def find_largest_subset(numbers, i=0, subset=set()):\r\n        if i == len(numbers):\r\n            return len(subset)\r\n        \r\n        max_size = 0\r\n        for j in range(i, len(numbers)):\r\n            if is_divisible(numbers[i], numbers[j]):\r\n                subset.add(numbers[j])\r\n                max_size = max(max_size, find_largest_subset(numbers, j+1, subset))\r\n                subset.remove(numbers[j])\r\n        \r\n        return max_size + 1\r\n    \r\n    return find_largest_subset(numbers)\r\n```\r\n\r\nThe function `is_divisible` checks if two numbers are divisible, and `find_largest_subset` is a recursive function that takes a list of numbers and an index `i` and a set of numbers in the current subset. It starts by checking if the current number `numbers[i]` is divisible by any of the remaining numbers in the list, and if so, it adds it to the subset and recursively calls itself with the next index `j+1` and the updated subset. If not, it returns the size of the current subset plus one. The base case is when `i` reaches the end of the list, in which case it returns the size of the subset. The maximum size found so far is stored in a variable `max_size`, which is updated whenever a larger subset is found. Finally, the function returns the maximum size found. ", "all_code": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n\n### Instruction:\nCreate a Python script for this problem:\nWrite a function to find the size of the largest subset of a list of numbers so that every pair is divisible. Your code should satisfy the following assertion:\n```python\nassert largest_subset([ 1, 3, 6, 13, 17, 18 ]) == 4\n```\n\n### Response:Here's a possible solution:\r\n\r\n```python\r\ndef largest_subset(numbers):\r\n    def is_divisible(a, b):\r\n        return a % b == 0 or b % a == 0\r\n    \r\n    def find_largest_subset(numbers, i=0, subset=set()):\r\n        if i == len(numbers):\r\n            return len(subset)\r\n        \r\n        max_size = 0\r\n        for j in range(i, len(numbers)):\r\n            if is_divisible(numbers[i], numbers[j]):\r\n                subset.add(numbers[j])\r\n                max_size = max(max_size, find_largest_subset(numbers, j+1, subset))\r\n                subset.remove(numbers[j])\r\n        \r\n        return max_size + 1\r\n    \r\n    return find_largest_subset(numbers)\r\n```\r\n\r\nThe function `is_divisible` checks if two numbers are divisible, and `find_largest_subset` is a recursive function that takes a list of numbers and an index `i` and a set of numbers in the current subset. It starts by checking if the current number `numbers[i]` is divisible by any of the remaining numbers in the list, and if so, it adds it to the subset and recursively calls itself with the next index `j+1` and the updated subset. If not, it returns the size of the current subset plus one. The base case is when `i` reaches the end of the list, in which case it returns the size of the subset. The maximum size found so far is stored in a variable `max_size`, which is updated whenever a larger subset is found. Finally, the function returns the maximum size found. "}
