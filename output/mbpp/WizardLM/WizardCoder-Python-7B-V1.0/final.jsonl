{"task_id": "Mbpp/2", "completion": "def similar_elements(list1, list2):\r\n    return set(list1) & set(list2)"}
{"task_id": "Mbpp/3", "completion": "def is_not_prime(n):\r\n    \"\"\"\r\n    This function takes an integer n as input and returns True if n is not a prime number, and False otherwise.\r\n    \"\"\"\r\n    if n < 2:\r\n        return True\r\n    for i in range(2, int(n**0.5)+1):\r\n        if n % i == 0:\r\n            return True\r\n    return False"}
{"task_id": "Mbpp/16", "completion": "def text_lowercase_underscore(string):\r\n    \"\"\"\r\n    This function checks if a string contains sequences of lowercase letters joined with an underscore.\r\n    \"\"\"\r\n    for i in range(len(string)-1):\r\n        if string[i] == \"_\":\r\n            if not string[i+1].islower():\r\n                return False\r\n    return True"}
{"task_id": "Mbpp/171", "completion": "def perimeter_pentagon(side_length):\r\n    return 5 * side_length"}
{"task_id": "Mbpp/172", "completion": "def count_occurance(string):\r\n    count = 0\r\n    for i in string:\r\n        if i == 'std':\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/222", "completion": "def check_type(tup):\r\n    \"\"\"\r\n    This function takes a tuple as input and returns True if all the elements in the tuple have the same data type, False otherwise.\r\n    \"\"\"\r\n    # Get the data type of the first element in the tuple\r\n    first_type = type(tup[0])\r\n    # Loop through the tuple and check if all the elements have the same data type as the first element\r\n    for i in tup:\r\n        if type(i) != first_type:\r\n            return False\r\n    # If all elements have the same data type, return True\r\n    return True"}
{"task_id": "Mbpp/223", "completion": "def is_majority(arr, n, element):\r\n    count = 0\r\n    for i in range(n):\r\n        if arr[i] == element:\r\n            count += 1\r\n        if count > n/2:\r\n            return True\r\n    return False"}
{"task_id": "Mbpp/224", "completion": "def count_Set_Bits(n):\r\n    count = 0\r\n    while n:\r\n        count += n & 1\r\n        n >>= 1\r\n    return count"}
{"task_id": "Mbpp/226", "completion": "def odd_values_string(string):\r\n    result = \"\"\r\n    for i in range(len(string)):\r\n        if i % 2 == 0:\r\n            result += string[i]\r\n    return result"}
{"task_id": "Mbpp/227", "completion": "def min_of_three(a, b, c):\r\n    \"\"\"\r\n    This function takes three numbers as input and returns the minimum of the three numbers.\r\n    \"\"\"\r\n    if a < b and a < c:\r\n        return a\r\n    elif b < c:\r\n        return b\r\n    else:\r\n        return c"}
{"task_id": "Mbpp/229", "completion": "def re_arrange_array(arr, n):\r\n    neg = []\r\n    pos = []\r\n    for i in arr:\r\n        if i < 0:\r\n            neg.append(i)\r\n        else:\r\n            pos.append(i)\r\n    return neg + pos"}
{"task_id": "Mbpp/230", "completion": "def replace_blank(string, character):\r\n    return string.replace(\" \", character)"}
{"task_id": "Mbpp/232", "completion": "def larg_nnum(lst, n):\r\n    return sorted(lst, reverse=True)[:n]"}
{"task_id": "Mbpp/17", "completion": "def square_perimeter(side):\r\n    return 4 * side"}
{"task_id": "Mbpp/233", "completion": "import math\r\n\r\ndef lateralsurface_cylinder(radius, height):\r\n    return 2 * math.pi * radius * height + 2 * math.pi * radius ** 2\r\n\r\nassert math.isclose(lateralsurface_cylinder(10, 5), 314.1500000000003, rel_tol=0.001)"}
{"task_id": "Mbpp/234", "completion": "def volume_cube(side):\r\n    return side**3"}
{"task_id": "Mbpp/235", "completion": "def even_bit_set_number(num):\r\n    \"\"\"\r\n    This function takes a number as input and sets all even bits to 1.\r\n    \"\"\"\r\n    binary = bin(num)[2:]\r\n    even_bits = [bit for i, bit in enumerate(binary) if i % 2 == 0]\r\n    set_bits = ''.join(['1' if bit == '0' else '0' for bit in even_bits])\r\n    return int(set_bits, 2)"}
{"task_id": "Mbpp/237", "completion": "def count_tuples(lst):\r\n    counts = {}\r\n    for tup in lst:\r\n        if tup in counts:\r\n            counts[tup] += 1\r\n        else:\r\n            counts[tup] = 1\r\n    return counts"}
{"task_id": "Mbpp/238", "completion": "def number_of_substrings(s: str) -> int:\r\n    \"\"\"\r\n    Returns the number of non-empty substrings of a given string.\r\n    \"\"\"\r\n    n = len(s)\r\n    count = 0\r\n    for i in range(n):\r\n        for j in range(i+1, n+1):\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/239", "completion": "def get_total_number_of_sequences(m, n):\r\n    if n == 1:\r\n        return 1\r\n    elif n == 2:\r\n        return m - 1\r\n    else:\r\n        return (m - 2) * (m - 1) // 2"}
{"task_id": "Mbpp/240", "completion": "def replace_list(list1, list2):\r\n    list1[-1] = list2\r\n    return list1"}
{"task_id": "Mbpp/242", "completion": "def count_charac(string):\r\n    return len(string)"}
{"task_id": "Mbpp/244", "completion": "def next_Perfect_Square(num):\r\n    \"\"\"\r\n    This function takes a number as input and returns the next perfect square greater than that number.\r\n    \"\"\"\r\n    # Find the square root of the number\r\n    sqrt_num = int(num ** 0.5)\r\n    # If the square root is an integer, return the next perfect square\r\n    if sqrt_num ** 2 == num:\r\n        return (sqrt_num + 1) ** 2\r\n    # If the square root is not an integer, return the next integer square\r\n    else:\r\n        return (sqrt_num + 1) ** 2"}
{"task_id": "Mbpp/245", "completion": "def max_sum(arr):\r\n    n = len(arr)\r\n    if n < 2:\r\n        return 0\r\n    \r\n    # Initialize the maximum sum and maximum sum ending at each index\r\n    max_sum = [0] * n\r\n    max_sum[0] = arr[0]\r\n    max_sum[1] = max(arr[0], arr[1])\r\n    \r\n    # Initialize the maximum sum ending at each index\r\n    max_ending_here = [0] * n\r\n    max_ending_here[0] = arr[0]\r\n    max_ending_here[1] = max(arr[0], arr[1])\r\n    \r\n    # Loop through the array from index 2 to n-1\r\n    for i in range(2, n):\r\n        # Update the maximum sum ending at index i\r\n        max_ending_here[i] = max(max_ending_here[i-1], arr[i] + max_ending_here[i-2])\r\n        \r\n        # Update the maximum sum\r\n        if max_ending_here[i] > max_sum[i-1]:\r\n            max_sum[i] = max_ending_here[i]\r\n        else:\r\n            max_sum[i] = max_sum[i-1]\r\n            \r\n        # If the maximum sum ending at index i is greater than the maximum sum ending at index i-2, then the maximum sum of the bitonic subsequence ending at index i is the maximum sum ending at index i\r\n        if max_ending_here[i] > max_sum[i-2]:\r\n            max_sum[i] = max(max_sum[i], max_sum[i-2] + max_ending_here[i])\r\n            \r\n    # Return the maximum sum of the bitonic subsequence\r\n    return max_sum[n-1]"}
{"task_id": "Mbpp/18", "completion": "def remove_dirty_chars(str1, str2):\r\n    for char in str2:\r\n        str1 = str1.replace(char, '')\r\n    return str1"}
{"task_id": "Mbpp/247", "completion": "def lps(s):\r\n    n = len(s)\r\n    dp = [[0] * n for _ in range(n)]\r\n    for i in range(n):\r\n        dp[i][i] = 1\r\n    for i in range(n-1):\r\n        if s[i] == s[i+1]:\r\n            dp[i][i+1] = 2\r\n    for l in range(3, n+1):\r\n        for i in range(n-l+1):\r\n            j = i + l - 1\r\n            if s[i] == s[j]:\r\n                dp[i][j] = dp[i+1][j-1] + 2\r\n            else:\r\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\r\n    return dp[0][n-1]"}
{"task_id": "Mbpp/249", "completion": "def intersection_array(arr1, arr2):\r\n    \"\"\"\r\n    Returns the intersection of two arrays.\r\n    \"\"\"\r\n    # Create a set from the second array to make it faster for searching\r\n    arr2_set = set(arr2)\r\n    # Create an empty list to store the intersection\r\n    intersection = []\r\n    # Loop through the first array and check if each element is in the second array\r\n    for num in arr1:\r\n        if num in arr2_set:\r\n            intersection.append(num)\r\n    # Return the intersection list\r\n    return intersection"}
{"task_id": "Mbpp/250", "completion": "def count_X(tup, x):\r\n    count = 0\r\n    for element in tup:\r\n        if element == x:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/251", "completion": "def insert_element(lst, elem):\r\n    result = []\r\n    for i in lst:\r\n        result.append(elem)\r\n        result.append(i)\r\n    return result"}
{"task_id": "Mbpp/252", "completion": "import math\r\n\r\ndef convert(z):\r\n    r = math.sqrt(z.real**2 + z.imag**2)\r\n    theta = math.atan2(z.imag, z.real)\r\n    return (r, theta)"}
{"task_id": "Mbpp/253", "completion": "def count_integer(lst):\r\n    count = 0\r\n    for i in lst:\r\n        if type(i) == int:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/255", "completion": "def combinations_colors(colors, n):\r\n    \"\"\"\r\n    Generates all combinations of length n of the given colors list.\r\n    \"\"\"\r\n    if n == 1:\r\n        return [(color,) for color in colors]\r\n    else:\r\n        return [(color1, color2) for color1 in colors for color2 in combinations_colors(colors, n-1)]"}
{"task_id": "Mbpp/256", "completion": "def count_Primes_nums(n):\r\n    count = 0\r\n    for i in range(2, n):\r\n        if all(i % j != 0 for j in range(2, i)):\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/257", "completion": "def swap_numbers(num1, num2):\r\n    return (num2, num1)"}
{"task_id": "Mbpp/259", "completion": "def maximize_elements(tup1, tup2):\r\n    result = []\r\n    for i in range(len(tup1)):\r\n        if tup1[i][1] > tup2[i][1]:\r\n            result.append(tup1[i])\r\n        else:\r\n            result.append(tup2[i])\r\n    return tuple(result)"}
{"task_id": "Mbpp/19", "completion": "def test_duplicate(arr):\r\n    return len(arr) != len(set(arr))"}
{"task_id": "Mbpp/260", "completion": "def newman_prime(n):\r\n    def is_prime(num):\r\n        if num < 2:\r\n            return False\r\n        for i in range(2, int(num**0.5)+1):\r\n            if num % i == 0:\r\n                return False\r\n        return True\r\n\r\n    def find_prime(n):\r\n        i = 1\r\n        while True:\r\n            if is_prime(i):\r\n                n -= 1\r\n            if n == 0:\r\n                return i\r\n            i += 1\r\n\r\n    def newman_shanks(n):\r\n        prime = find_prime(n)\r\n        while True:\r\n            if is_prime(prime**2 + prime):\r\n                prime += 1\r\n            else:\r\n                return prime**2 + prime\r\n\r\n    return newman_shanks(n)\r\n\r\nassert newman_prime(3) == 7"}
{"task_id": "Mbpp/261", "completion": "def division_elements(tup1, tup2):\r\n    return tuple(map(lambda x, y: x/y, tup1, tup2))"}
{"task_id": "Mbpp/262", "completion": "def split_two_parts(lst, L):\r\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/264", "completion": "def dog_age(human_age):\r\n    return human_age * 7"}
{"task_id": "Mbpp/265", "completion": "def split_list(lst, n):\r\n    result = []\r\n    for i in range(0, len(lst), n):\r\n        result.append(lst[i:i+n])\r\n    return result"}
{"task_id": "Mbpp/266", "completion": "def lateralsurface_cube(side):\r\n    return 6 * side ** 2"}
{"task_id": "Mbpp/267", "completion": "def square_Sum(n):\r\n    sum = 0\r\n    for i in range(1, n*2, 2):\r\n        sum += i**2\r\n    return sum"}
{"task_id": "Mbpp/268", "completion": "def find_star_num(n):\r\n    \"\"\"\r\n    Returns the nth star number.\r\n    \"\"\"\r\n    if n < 1:\r\n        return None\r\n    \r\n    # Initialize the first two star numbers\r\n    prev_star = 1\r\n    curr_star = 2\r\n    \r\n    # Loop through the remaining numbers\r\n    for i in range(2, n):\r\n        # Calculate the next star number\r\n        next_star = prev_star + curr_star\r\n        \r\n        # Update the previous and current star numbers\r\n        prev_star = curr_star\r\n        curr_star = next_star\r\n        \r\n    return curr_star"}
{"task_id": "Mbpp/269", "completion": "def ascii_value(char):\r\n    return ord(char)"}
{"task_id": "Mbpp/270", "completion": "def sum_even_and_even_index(lst):\r\n    \"\"\"\r\n    This function takes a list as input and returns the sum of even numbers at even positions.\r\n    \"\"\"\r\n    even_sum = 0\r\n    for i in range(0, len(lst), 2):\r\n        if lst[i] % 2 == 0:\r\n            even_sum += lst[i]\r\n    return even_sum"}
{"task_id": "Mbpp/20", "completion": "def is_woodall(num):\r\n    \"\"\"\r\n    This function takes a number as input and returns True if it is a woodball number, else False.\r\n    A woodball number is a number whose sum of its digits is equal to the product of its digits.\r\n    \"\"\"\r\n    # Convert the number to a string to split it into digits\r\n    num_str = str(num)\r\n    # Split the string into a list of digits\r\n    digits = [int(d) for d in num_str]\r\n    # Calculate the sum of the digits\r\n    sum_of_digits = sum(digits)\r\n    # Calculate the product of the digits\r\n    product_of_digits = 1\r\n    for digit in digits:\r\n        product_of_digits *= digit\r\n    # Check if the sum of digits is equal to the product of digits\r\n    if sum_of_digits == product_of_digits:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/271", "completion": "def even_Power_Sum(n):\r\n    sum = 0\r\n    for i in range(2, n+1, 2):\r\n        sum += i**5\r\n    return sum"}
{"task_id": "Mbpp/272", "completion": "def rear_extract(lst):\r\n    return [t[-1] for t in lst]"}
{"task_id": "Mbpp/273", "completion": "def substract_elements(tup1, tup2):\r\n    result = []\r\n    for i in range(len(tup1)):\r\n        result.append(tup1[i] - tup2[i])\r\n    return tuple(result)"}
{"task_id": "Mbpp/274", "completion": "def even_binomial_Coeff_Sum(n):\r\n    sum = 0\r\n    for i in range(0, n+1):\r\n        sum += binomial_Coeff(n, i)\r\n    return sum\r\n\r\ndef binomial_Coeff(n, k):\r\n    if k == 0 or k == n:\r\n        return 1\r\n    else:\r\n        return binomial_Coeff(n-1, k-1) + binomial_Coeff(n-1, k)"}
{"task_id": "Mbpp/276", "completion": "import math\r\n\r\ndef volume_cylinder(radius, height):\r\n    volume = math.pi * radius**2 * height\r\n    return volume"}
{"task_id": "Mbpp/277", "completion": "def filter_dict(d, n):\r\n    return {k: v for k, v in d.items() if v >= n}"}
{"task_id": "Mbpp/278", "completion": "def count_first_elements(tup):\r\n    count = 0\r\n    for i in tup:\r\n        if not isinstance(i, tuple):\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/279", "completion": "def is_num_decagonal(n):\r\n    return n * (n * n * (n - 1) // 2)"}
{"task_id": "Mbpp/280", "completion": "def sequential_search(arr, element):\r\n    for i in range(len(arr)):\r\n        if arr[i] == element:\r\n            return (True, i)\r\n    return (False, -1)"}
{"task_id": "Mbpp/281", "completion": "def all_unique(lst):\r\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/56", "completion": "def check(num):\r\n    reverse = int(str(num)[::-1])\r\n    if num == reverse - 2:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/282", "completion": "def sub_list(list1, list2):\r\n    \"\"\"\r\n    This function takes two lists as input and returns a new list that contains the element-wise difference of the two input lists.\r\n    \"\"\"\r\n    result = []\r\n    for i in range(len(list1)):\r\n        result.append(list1[i] - list2[i])\r\n    return result"}
{"task_id": "Mbpp/283", "completion": "def validate(n):\r\n    num_str = str(n)\r\n    for digit in num_str:\r\n        if num_str.count(digit) > int(digit):\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/284", "completion": "def check_element(lst, element):\r\n    for item in lst:\r\n        if item != element:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/285", "completion": "def text_match_two_three(string):\r\n    if 'a' in string and 'b'*2 in string or 'a' in string and 'b'*3 in string:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/286", "completion": "def max_sub_array_sum_repeated(arr, k, n):\r\n    # Repeat the array k times\r\n    arr = arr * k\r\n    # Initialize the sum of the modified array\r\n    modified_sum = sum(arr)\r\n    # Initialize the maximum sum\r\n    max_sum = sum(arr)\r\n    # Initialize the current sum\r\n    current_sum = 0\r\n    # Initialize the start index\r\n    start = 0\r\n    # Initialize the end index\r\n    end = 0\r\n    # Initialize the maximum sum subarray\r\n    max_subarray = []\r\n    \r\n    # Iterate through the modified array\r\n    for i in range(len(arr)):\r\n        # Add the current element to the current sum\r\n        current_sum += arr[i]\r\n        # If the current sum is greater than the maximum sum, update the maximum sum and the maximum sum subarray\r\n        if current_sum > max_sum:\r\n            max_sum = current_sum\r\n            max_subarray = arr[start:i+1]\r\n        # If the current sum becomes negative, reset the current sum and start index\r\n        if current_sum < 0:\r\n            current_sum = 0\r\n            start = i+1\r\n    \r\n    # Return the maximum sum\r\n    return max_sum"}
{"task_id": "Mbpp/287", "completion": "def square_Sum(n):\r\n    sum = 0\r\n    for i in range(1, n+1):\r\n        sum += i**2\r\n    return sum"}
{"task_id": "Mbpp/290", "completion": "def max_length(lst):\r\n    max_length = 0\r\n    max_lst = []\r\n    for sub_lst in lst:\r\n        if len(sub_lst) > max_length:\r\n            max_length = len(sub_lst)\r\n            max_lst = sub_lst\r\n    return max_length, max_lst"}
{"task_id": "Mbpp/292", "completion": "def find(a, b):\r\n    return a // b"}
{"task_id": "Mbpp/293", "completion": "import math\r\n\r\ndef otherside_rightangle(a,b):\r\n    c = math.sqrt(a**2 + b**2)\r\n    return c\r\n\r\nassert otherside_rightangle(7,8)==10.63014581273465"}
{"task_id": "Mbpp/294", "completion": "def max_val(lst):\r\n    max_val = lst[0]\r\n    for i in lst:\r\n        if type(i) == int and i > max_val:\r\n            max_val = i\r\n    return max_val"}
{"task_id": "Mbpp/57", "completion": "def find_Max_Num(digits):\r\n    digits.sort(reverse=True)\r\n    result = \"\"\r\n    for digit in digits:\r\n        result += str(digit)\r\n    return int(result)"}
{"task_id": "Mbpp/295", "completion": "def sum_div(n):\r\n    \"\"\"\r\n    This function takes a number n as input and returns the sum of all its divisors.\r\n    \"\"\"\r\n    divisors = []\r\n    for i in range(1, n+1):\r\n        if n % i == 0:\r\n            divisors.append(i)\r\n    return sum(divisors)"}
{"task_id": "Mbpp/296", "completion": "def get_Inv_Count(arr):\r\n    n = len(arr)\r\n    inv_count = 0\r\n    for i in range(n):\r\n        for j in range(i+1, n):\r\n            if arr[i] > arr[j]:\r\n                inv_count += 1\r\n    return inv_count"}
{"task_id": "Mbpp/297", "completion": "def flatten_list(nested_list):\r\n    \"\"\"\r\n    Flatten a nested list into a single list\r\n    \"\"\"\r\n    flat_list = []\r\n    for item in nested_list:\r\n        if type(item) == list:\r\n            flat_list.extend(flatten_list(item))\r\n        else:\r\n            flat_list.append(item)\r\n    return flat_list"}
{"task_id": "Mbpp/299", "completion": "def max_aggregate(lst):\r\n    max_name = ''\r\n    max_score = 0\r\n    for name, score in lst:\r\n        if score > max_score:\r\n            max_name = name\r\n            max_score = score\r\n        elif score == max_score and name < max_name:\r\n            max_name = name\r\n    return (max_name, max_score)\r\n\r\nassert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)"}
{"task_id": "Mbpp/300", "completion": "import math\r\n\r\ndef count_binary_seq(n):\r\n    # Initialize variables\r\n    count = 0\r\n    total_count = 0\r\n    \r\n    # Loop through all possible binary sequences of length 2n\r\n    for i in range(2**(2*n):\r\n        # Check if the sum of first n bits is equal to the sum of last n bits\r\n        if sum(int(digit) for digit in bin(i)[:n]) == sum(int(digit) for digit in bin(i)[-n:]):\r\n            count += 1\r\n            \r\n    # Calculate the total count of binary sequences of length 2n\r\n    total_count = 2**(2*n)\r\n    \r\n    # Return the count of binary sequences that satisfy the condition\r\n    return count/total_count"}
{"task_id": "Mbpp/301", "completion": "def dict_depth(d):\r\n    if isinstance(d, dict):\r\n        return 1 + max(dict_depth(v) for v in d.values()) if d else 0\r\n    else:\r\n        return 0"}
{"task_id": "Mbpp/305", "completion": "def start_withp(words):\r\n    result = []\r\n    for word in words:\r\n        if word.startswith('p'):\r\n            result.append(word.split()[0])\r\n    return tuple(result)"}
{"task_id": "Mbpp/306", "completion": "def max_sum_increasing_subseq(arr, i, k):\r\n    n = len(arr)\r\n    dp = [0] * n\r\n    dp[0] = arr[0]\r\n    dp[1] = max(arr[0], arr[1])\r\n    \r\n    for i in range(2, n):\r\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\r\n    \r\n    for i in range(2, n):\r\n        for j in range(i):\r\n            if arr[i] > arr[j] and dp[i] < dp[j] + arr[i]:\r\n                dp[i] = dp[j] + arr[i]\r\n    \r\n    return dp[k-1]"}
{"task_id": "Mbpp/308", "completion": "def large_product(list1, list2, n):\r\n    \"\"\"\r\n    This function takes two lists and an integer n as input and returns a list of n largest products of pairs of factors from the two lists.\r\n    \"\"\"\r\n    # Sorting the lists in descending order\r\n    list1.sort(reverse=True)\r\n    list2.sort(reverse=True)\r\n    \r\n    # Initializing an empty list to store the products\r\n    products = []\r\n    \r\n    # Iterating through the lists and selecting one factor from each list\r\n    for i in range(n):\r\n        product = list1[i] * list2[i]\r\n        products.append(product)\r\n    \r\n    # Returning the list of products\r\n    return products"}
{"task_id": "Mbpp/309", "completion": "def maximum(a, b):\r\n    if a > b:\r\n        return a\r\n    else:\r\n        return b"}
{"task_id": "Mbpp/58", "completion": "def opposite_Signs(a, b):\r\n    if a*b < 0:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/310", "completion": "def string_to_tuple(string):\r\n    return tuple(string)"}
{"task_id": "Mbpp/311", "completion": "def set_left_most_unset_bit(n):\r\n    return n | (1 << (n.bit_length())"}
{"task_id": "Mbpp/312", "completion": "import math\r\n\r\ndef volume_cone(radius, height):\r\n    return (1/3) * math.pi * radius**2 * height"}
{"task_id": "Mbpp/388", "completion": "def highest_Power_of_2(n):\r\n    power = 1\r\n    while power * 2 <= n:\r\n        power *= 2\r\n    return power"}
{"task_id": "Mbpp/389", "completion": "def find_lucas(n):\r\n    if n == 0:\r\n        return 2\r\n    elif n == 1:\r\n        return 1\r\n    else:\r\n        return find_lucas(n-1) + find_lucas(n-2)"}
{"task_id": "Mbpp/390", "completion": "def add_string(lst, format_str):\r\n    return [format_str.format(x) for x in lst]"}
{"task_id": "Mbpp/391", "completion": "def convert_list_dictionary(students, subjects, grades):\r\n    result = []\r\n    for i in range(len(students)):\r\n        result.append({students[i]: {subjects[i]: grades[i]}})\r\n    return result"}
{"task_id": "Mbpp/392", "completion": "def get_max_sum(n):\r\n    memo = {}\r\n    def f(x):\r\n        if x in memo:\r\n            return memo[x]\r\n        if x == 1:\r\n            return 0\r\n        elif x % 10 == 1:\r\n            return 1\r\n        elif x % 10 == 3:\r\n            return 2\r\n        elif x % 10 == 4:\r\n            return 3\r\n        elif x % 10 == 5:\r\n            return 4\r\n        else:\r\n            memo[x] = max(f(x//2) + f(x//3) + f(x//4) + f(x//5), x)\r\n            return memo[x]\r\n    return f(n)"}
{"task_id": "Mbpp/394", "completion": "def check_distinct(tup):\r\n    return len(tup) == len(set(tup))"}
{"task_id": "Mbpp/395", "completion": "def first_non_repeating_character(s):\r\n    char_count = {}\r\n    for char in s:\r\n        if char in char_count:\r\n            char_count[char] += 1\r\n        else:\r\n            char_count[char] = 1\r\n    \r\n    for char in s:\r\n        if char_count[char] == 1:\r\n            return char\r\n    \r\n    return None"}
{"task_id": "Mbpp/59", "completion": "def is_octagonal(n):\r\n    \"\"\"\r\n    Returns the nth octagonal number.\r\n    \"\"\"\r\n    return n * (n * 2 - 1)"}
{"task_id": "Mbpp/396", "completion": "def check_char(string):\r\n    if string[0] == string[-1]:\r\n        return \"Valid\"\r\n    else:\r\n        return \"Invalid\""}
{"task_id": "Mbpp/397", "completion": "def median_numbers(num1, num2, num3):\r\n    numbers = [num1, num2, num3]\r\n    numbers.sort()\r\n    median = numbers[1]\r\n    return median"}
{"task_id": "Mbpp/398", "completion": "def sum_of_digits(lst):\r\n    \"\"\"\r\n    This function takes a list of numbers as input and returns the sum of digits of each number in the list.\r\n    \"\"\"\r\n    result = []\r\n    for num in lst:\r\n        sum = 0\r\n        for digit in str(num):\r\n            sum += int(digit)\r\n        result.append(sum)\r\n    return result"}
{"task_id": "Mbpp/400", "completion": "def extract_freq(lst):\r\n    return len(set(lst))"}
{"task_id": "Mbpp/404", "completion": "def minimum(a, b):\r\n    if a < b:\r\n        return a\r\n    else:\r\n        return b"}
{"task_id": "Mbpp/405", "completion": "def check_tuplex(tup, element):\r\n    if element in tup:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/406", "completion": "def find_Parity(num):\r\n    if num % 2 == 0:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/407", "completion": "def rearrange_bigger(num):\r\n    num = str(num)\r\n    num_list = list(num)\r\n    num_list.sort(reverse=True)\r\n    num_list = [int(i) for i in num_list]\r\n    result = ''\r\n    for i in num_list:\r\n        result += str(i)\r\n    return int(result)"}
{"task_id": "Mbpp/409", "completion": "def min_product_tuple(lst):\r\n    min_product = float('inf')\r\n    for i in range(len(lst)):\r\n        for j in range(i+1, len(lst)):\r\n            product = lst[i][0] * lst[j][1]\r\n            if product < min_product:\r\n                min_product = product\r\n    return min_product"}
{"task_id": "Mbpp/410", "completion": "def min_val(lst):\r\n    min_val = lst[0]\r\n    for i in lst:\r\n        if type(i) == int and i < min_val:\r\n            min_val = i\r\n    return min_val"}
{"task_id": "Mbpp/61", "completion": "def count_Substrings(s):\r\n    count = 0\r\n    n = len(s)\r\n    for i in range(n):\r\n        for j in range(i+1, n+1):\r\n            substr = s[i:j]\r\n            if sum(int(d) for d in substr) == len(substr):\r\n                count += 1\r\n    return count"}
{"task_id": "Mbpp/412", "completion": "def remove_odd(lst):\r\n    return [num for num in lst if num % 2 == 0]"}
{"task_id": "Mbpp/413", "completion": "def extract_nth_element(lst, n):\r\n    return [t[n] for t in lst]"}
{"task_id": "Mbpp/414", "completion": "def overlapping(seq1, seq2):\r\n    for i in seq1:\r\n        if i in seq2:\r\n            return True\r\n    return False"}
{"task_id": "Mbpp/415", "completion": "def max_Product(arr):\r\n    max_product = arr[0] * arr[1]\r\n    min_product = arr[0]\r\n    max_pair = (arr[0], arr[1])\r\n    for i in range(1, len(arr)):\r\n        if arr[i] * max_product > max_product:\r\n            min_product = max_product\r\n            max_product = arr[i]\r\n        elif arr[i] * min_product < min_product:\r\n            min_product = arr[i]\r\n        else:\r\n            min_product = min(min_product, arr[i])\r\n        if max_product * min_product > max_product:\r\n            max_pair = (max_product, min_product)\r\n    return max_pair"}
{"task_id": "Mbpp/418", "completion": "def Find_Max(lst):\r\n    max_length = 0\r\n    max_element = []\r\n    for i in lst:\r\n        if len(i) > max_length:\r\n            max_length = len(i)\r\n            max_element = i\r\n    return max_element"}
{"task_id": "Mbpp/419", "completion": "def round_and_sum(numbers):\r\n    total = 0\r\n    for num in numbers:\r\n        total += round(num)\r\n    return total * len(numbers)\r\n\r\nassert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50]) == 243"}
{"task_id": "Mbpp/420", "completion": "def cube_Sum(n):\r\n    sum = 0\r\n    for i in range(2, 2*n, 2):\r\n        sum += i**3\r\n    return sum"}
{"task_id": "Mbpp/421", "completion": "def concatenate_tuple(tup, delimiter=\"-\"):\r\n    return delimiter.join(str(x) for x in tup)"}
{"task_id": "Mbpp/422", "completion": "def find_Average_Of_Cube(n):\r\n    sum = 0\r\n    for i in range(1, n+1):\r\n        sum += i**3\r\n    return sum/n"}
{"task_id": "Mbpp/424", "completion": "def extract_rear(tup):\r\n    \"\"\"\r\n    This function takes a tuple of strings as input and returns a list of the last character of each string.\r\n    \"\"\"\r\n    result = []\r\n    for string in tup:\r\n        result.append(string[-1])\r\n    return result"}
{"task_id": "Mbpp/4", "completion": "import heapq\r\n\r\ndef heap_queue_largest(numbers, n):\r\n    heap = []\r\n    for num in numbers:\r\n        heapq.heappush(heap, num)\r\n        if len(heap) > n:\r\n            heapq.heappop(heap)\r\n    return sorted(heap, reverse=True)"}
{"task_id": "Mbpp/62", "completion": "def smallest_num(lst):\r\n    return min(lst)"}
{"task_id": "Mbpp/425", "completion": "def count_element_in_list(lst, element):\r\n    count = 0\r\n    for sublist in lst:\r\n        if element in sublist:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/426", "completion": "def filter_oddnumbers(numbers):\r\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/427", "completion": "def change_date_format(date):\r\n    year, month, day = date.split('-')\r\n    return f\"{day}-{month}-{year}\""}
{"task_id": "Mbpp/428", "completion": "def shell_sort(arr):\r\n    n = len(arr)\r\n    gap = n // 2\r\n    while gap > 0:\r\n        for i in range(gap, n):\r\n            temp = arr[i]\r\n            j = i\r\n            while j >= gap and arr[j - gap] > temp:\r\n                arr[j] = arr[j - gap]\r\n                j -= gap\r\n            arr[j] = temp\r\n        gap //= 2\r\n    return arr"}
{"task_id": "Mbpp/429", "completion": "def and_tuples(t1, t2):\r\n    return tuple(x & y for x, y in zip(t1, t2))"}
{"task_id": "Mbpp/430", "completion": "def parabola_directrix(a, b, c):\r\n    \"\"\"\r\n    This function takes three parameters a, b, and c, which represent the coefficients of the equation of a parabola in standard form: y^2 = ax^2 + bx + c.\r\n    It returns the directrix of the parabola, which is the line that is perpendicular to the focus and passes through the origin.\r\n    \"\"\"\r\n    # Calculate the slope of the directrix\r\n    slope = -1/2 * a\r\n    # Calculate the y-intercept of the directrix\r\n    y_int = -c/b\r\n    # Return the equation of the directrix in the form y = mx + b\r\n    return slope, y_int"}
{"task_id": "Mbpp/431", "completion": "def common_element(list1, list2):\r\n    for i in list1:\r\n        for j in list2:\r\n            if i == j:\r\n                return True\r\n    return False"}
{"task_id": "Mbpp/432", "completion": "def median_trapezium(a, b, c):\r\n    \"\"\"\r\n    This function takes three parameters a, b, and c which represent the lengths of the three sides of a trapezium.\r\n    It returns the median length of the trapezium.\r\n    \"\"\"\r\n    return (a+b+c)/2"}
{"task_id": "Mbpp/433", "completion": "def check_greater(arr, num):\r\n    for i in arr:\r\n        if i > num:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/435", "completion": "def last_Digit(num):\r\n    return num % 10"}
{"task_id": "Mbpp/63", "completion": "def max_difference(lst):\r\n    max_diff = 0\r\n    for i in range(len(lst)):\r\n        for j in range(i+1, len(lst)):\r\n            diff = lst[j][0] - lst[i][1]\r\n            if diff > max_diff:\r\n                max_diff = diff\r\n    return max_diff"}
{"task_id": "Mbpp/436", "completion": "def neg_nos(lst):\r\n    \"\"\"\r\n    This function takes a list as input and returns a new list containing only the negative numbers from the input list.\r\n    \"\"\"\r\n    neg_lst = []\r\n    for num in lst:\r\n        if num < 0:\r\n            neg_lst.append(num)\r\n    return neg_lst"}
{"task_id": "Mbpp/437", "completion": "def remove_odd(string):\r\n    new_string = \"\"\r\n    for char in string:\r\n        if char.isalpha() and ord(char) % 2 == 0:\r\n            new_string += char\r\n    return new_string"}
{"task_id": "Mbpp/438", "completion": "def count_bidirectional(lst):\r\n    count = 0\r\n    seen = set()\r\n    for pair in lst:\r\n        if pair[::-1] in seen:\r\n            count += 1\r\n        else:\r\n            seen.add(pair)\r\n    return count"}
{"task_id": "Mbpp/439", "completion": "def multiple_to_single(lst):\r\n    result = 0\r\n    for num in lst:\r\n        result = result * 10 + num\r\n    return result"}
{"task_id": "Mbpp/440", "completion": "\r\ndef find_adverb_position(sentence):\r\n    adverbs = ['clearly', 'quickly', 'slowly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quickly', 'quick"}
{"task_id": "Mbpp/441", "completion": "def surfacearea_cube(size):\r\n    return 6 * size ** 2"}
{"task_id": "Mbpp/442", "completion": "def positive_count(arr):\r\n    count = 0\r\n    for num in arr:\r\n        if num > 0:\r\n            count += 1\r\n    return count/len(arr)"}
{"task_id": "Mbpp/445", "completion": "def index_multiplication(t1, t2):\r\n    result = []\r\n    for i in range(len(t1)):\r\n        result.append(t1[i] * t2[i])\r\n    return tuple(result)"}
{"task_id": "Mbpp/446", "completion": "def count_Occurrence(tuple_list, list_elements):\r\n    count_dict = {}\r\n    for element in list_elements:\r\n        count_dict[element] = tuple_list.count(element)\r\n    return count_dict"}
{"task_id": "Mbpp/447", "completion": "def cube_nums(lst):\r\n    return [x**3 for x in lst]"}
{"task_id": "Mbpp/64", "completion": "def sort_tuples_by_second_value(tuples_list):\r\n    return sorted(tuples_list, key=lambda x: x[1])"}
{"task_id": "Mbpp/448", "completion": "def cal_sum(n):\r\n    \"\"\"\r\n    This function calculates the sum of Perrin numbers up to n.\r\n    \"\"\"\r\n    perrin_sum = 0\r\n    for i in range(1, n+1):\r\n        perrin_sum += i * i * i * i\r\n    return perrin_sum"}
{"task_id": "Mbpp/450", "completion": "def extract_string(lst, size):\r\n    return [s for s in lst if len(s) >= size]"}
{"task_id": "Mbpp/451", "completion": "def remove_whitespaces(string):\r\n    return ''.join(string.split())"}
{"task_id": "Mbpp/453", "completion": "def sumofFactors(n):\r\n    factors = []\r\n    for i in range(1, n+1):\r\n        if n % i == 0:\r\n            if i % 2 == 0:\r\n                factors.append(i)\r\n    return sum(factors)"}
{"task_id": "Mbpp/454", "completion": "def text_match_wordz(text):\r\n    if 'z' in text:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/455", "completion": "def check_monthnumb_number(month_number):\r\n    \"\"\"\r\n    This function takes a month number as input and returns True if it has 31 days, otherwise False.\r\n    \"\"\"\r\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\r\n        return True\r\n    elif month_number in [4, 6, 9, 11]:\r\n        return False\r\n    elif month_number == 2:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/456", "completion": "def reverse_string_list(lst):\r\n    return [string[::-1] for string in lst]"}
{"task_id": "Mbpp/457", "completion": "def Find_Min(lst):\r\n    min_len = len(lst[0])\r\n    min_sublist = lst[0]\r\n    for sublist in lst:\r\n        if len(sublist) < min_len:\r\n            min_len = len(sublist)\r\n            min_sublist = sublist\r\n    return min_sublist"}
{"task_id": "Mbpp/458", "completion": "def rectangle_area(width, height):\r\n    return width * height"}
{"task_id": "Mbpp/459", "completion": "def remove_uppercase(s):\r\n    return ''.join(c for c in s if c.islower() or not c.isalpha())"}
{"task_id": "Mbpp/65", "completion": "def recursive_list_sum(lst):\r\n    total = 0\r\n    for item in lst:\r\n        if isinstance(item, list):\r\n            total += recursive_list_sum(item)\r\n        else:\r\n            total += item\r\n    return total"}
{"task_id": "Mbpp/460", "completion": "def Extract(lst):\r\n    return [sublst[0] for sublst in lst]"}
{"task_id": "Mbpp/461", "completion": "def upper_ctr(string):\r\n    count = 0\r\n    for char in string:\r\n        if char.isupper():\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/462", "completion": "def combinations_list(lst):\r\n    \"\"\"\r\n    This function takes a list as input and returns all possible combinations of the elements in the list.\r\n    \"\"\"\r\n    # Initialize an empty list to store the combinations\r\n    combinations = []\r\n    # Initialize an empty list to store the current combination\r\n    current_combination = []\r\n    # Loop through the list and add each element to the current combination\r\n    for i in range(len(lst)):\r\n        current_combination.append(lst[i])\r\n        # Create a new list with the current combination and add it to the combinations list\r\n        combinations.append(current_combination[:])\r\n        # Loop through the remaining elements of the list and add them to the current combination\r\n        for j in range(i+1, len(lst)):\r\n            current_combination.append(lst[j])\r\n            # Create a new list with the current combination and add it to the combinations list\r\n            combinations.append(current_combination[:])\r\n            # Remove the last element from the current combination to continue the loop\r\n            current_combination.pop()\r\n    return combinations"}
{"task_id": "Mbpp/463", "completion": "def max_subarray_product(arr):\r\n    max_product = arr[0]\r\n    min_product = arr[0]\r\n    result = arr[0]\r\n    for i in range(1, len(arr)):\r\n        if arr[i] < 0:\r\n            max_product, min_product = min_product, max_product\r\n        max_product = max(arr[i], max_product * arr[i])\r\n        min_product = min(arr[i], min_product * arr[i])\r\n        result = max(result, max_product)\r\n    return result"}
{"task_id": "Mbpp/465", "completion": "def drop_empty(d):\r\n    return {k: v for k, v in d.items() if v is not None}"}
{"task_id": "Mbpp/468", "completion": "def max_product(arr):\r\n    n = len(arr)\r\n    if n == 0:\r\n        return 0\r\n    elif n == 1:\r\n        return arr[0]\r\n    elif n == 2:\r\n        return max(arr[0], arr[1])\r\n    else:\r\n        max_product = arr[0]\r\n        min_product = arr[0]\r\n        result = arr[0]\r\n        for i in range(1, n):\r\n            if arr[i] > max_product:\r\n                max_product = arr[i]\r\n            elif arr[i] < min_product:\r\n                min_product = arr[i]\r\n            result = max(result * max_product, result * min_product)\r\n            if result < 0:\r\n                result = max(result * max_product, result * min_product)\r\n        return result"}
{"task_id": "Mbpp/470", "completion": "def add_pairwise(tup):\r\n    result = []\r\n    for i in range(len(tup)-1):\r\n        result.append(tup[i] + tup[i+1])\r\n    return tuple(result)"}
{"task_id": "Mbpp/471", "completion": "def find_remainder(arr, n):\r\n    result = 1\r\n    for num in arr:\r\n        result = (result * num) % n\r\n    return result"}
{"task_id": "Mbpp/472", "completion": "def check_Consecutive(lst):\r\n    \"\"\"\r\n    This function takes a list as input and returns True if the list contains consecutive numbers, else False.\r\n    \"\"\"\r\n    for i in range(len(lst)-1):\r\n        if lst[i+1] - lst[i] == 1:\r\n            continue\r\n        else:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/473", "completion": "def tuple_intersection(t1, t2):\r\n    t1_set = set(t1)\r\n    t2_set = set(t2)\r\n    intersection = t1_set.intersection(t2_set)\r\n    return tuple(intersection)\r\n\r\nassert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)], [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}"}
{"task_id": "Mbpp/66", "completion": "def pos_count(lst):\r\n    count = 0\r\n    for num in lst:\r\n        if num > 0:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/474", "completion": "def replace_char(string, old_char, new_char):\r\n    \"\"\"\r\n    This function replaces all occurrences of a character in a string with another character.\r\n    \"\"\"\r\n    return string.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "completion": "def sort_counter(counter):\r\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)"}
{"task_id": "Mbpp/476", "completion": "def big_sum(arr):\r\n    return arr[0] + arr[-1]"}
{"task_id": "Mbpp/477", "completion": "def is_lower(string):\r\n    return string.lower()"}
{"task_id": "Mbpp/478", "completion": "def remove_lowercase(string):\r\n    return ''.join([char for char in string if char.isupper() or char.isdigit()])"}
{"task_id": "Mbpp/479", "completion": "def first_digit(num):\r\n    return int(str(num)[0])"}
{"task_id": "Mbpp/554", "completion": "def Split(lst):\r\n    odd_lst = []\r\n    for num in lst:\r\n        if num % 2 != 0:\r\n            odd_lst.append(num)\r\n    return odd_lst"}
{"task_id": "Mbpp/555", "completion": "def difference(n):\r\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\r\n    sum_of_numbers = sum(range(1, n+1))\r\n    return sum_of_cubes - sum_of_numbers"}
{"task_id": "Mbpp/556", "completion": "def find_Odd_Pair(arr, n):\r\n    count = 0\r\n    for i in range(n):\r\n        for j in range(i+1, n):\r\n            if (arr[i]^arr[j])%2!=0:\r\n                count+=1\r\n    return count"}
{"task_id": "Mbpp/557", "completion": "def toggle_string(s):\r\n    return s.swapcase()"}
{"task_id": "Mbpp/67", "completion": "def bell_number(n):\r\n    \"\"\"\r\n    Returns the nth Bell number.\r\n    \"\"\"\r\n    if n == 0:\r\n        return 1\r\n    elif n == 1:\r\n        return 1\r\n    else:\r\n        bell = [0] * (n+1)\r\n        bell[0] = 1\r\n        bell[1] = 1\r\n        for i in range(2, n+1):\r\n            bell[i] = 0\r\n            for j in range(i):\r\n                bell[i] += bell[i-j]*bell[j]\r\n        return bell[n]"}
{"task_id": "Mbpp/558", "completion": "def digit_distance_nums(num1, num2):\r\n    \"\"\"\r\n    This function takes two integers as input and returns the sum of the per-digit difference between them.\r\n    \"\"\"\r\n    # Convert the integers to strings to be able to iterate over each digit\r\n    num1_str = str(num1)\r\n    num2_str = str(num2)\r\n    \r\n    # Initialize the sum variable to store the sum of the per-digit difference\r\n    sum_diff = 0\r\n    \r\n    # Iterate over each digit in the string representation of num1\r\n    for i in range(len(num1_str)):\r\n        # Convert the digit to an integer and subtract the corresponding digit in num2\r\n        diff = int(num1_str[i]) - int(num2_str[i])\r\n        # If the difference is negative, make it positive\r\n        if diff < 0:\r\n            diff = -diff\r\n        # Add the absolute value of the difference to the sum\r\n        sum_diff += diff\r\n    \r\n    return sum_diff"}
{"task_id": "Mbpp/559", "completion": "def max_sub_array_sum(lst, k):\r\n    max_sum = float('-inf')\r\n    current_sum = 0\r\n    max_start = 0\r\n    max_end = 0\r\n    start = 0\r\n    \r\n    for end, num in enumerate(lst):\r\n        current_sum += num\r\n        \r\n        if current_sum > max_sum:\r\n            max_sum = current_sum\r\n            max_end = end\r\n        \r\n        if current_sum > k:\r\n            current_sum -= lst[start]\r\n            start += 1\r\n            \r\n    return max_sum"}
{"task_id": "Mbpp/560", "completion": "def union_elements(tup1, tup2):\r\n    return sorted(set(tup1) | set(tup2))"}
{"task_id": "Mbpp/562", "completion": "def Find_Max_Length(lst):\r\n    max_length = 0\r\n    for sublist in lst:\r\n        if len(sublist) > max_length:\r\n            max_length = len(sublist)\r\n    return max_length"}
{"task_id": "Mbpp/563", "completion": "def extract_values(string):\r\n    \"\"\"\r\n    This function extracts values between quotation marks from a string and returns them as a list.\r\n    \"\"\"\r\n    values = []\r\n    start = False\r\n    current_value = \"\"\r\n    for char in string:\r\n        if char == '\"':\r\n            if start:\r\n                values.append(current_value)\r\n                current_value = \"\"\r\n                start = False\r\n            else:\r\n                start = True\r\n        elif start:\r\n            current_value += char\r\n    return values"}
{"task_id": "Mbpp/564", "completion": "def count_Pairs(lst):\r\n    count = 0\r\n    for i in range(len(lst)):\r\n        for j in range(i+1, len(lst)):\r\n            if lst[i] != lst[j]:\r\n                count += 1\r\n    return count"}
{"task_id": "Mbpp/565", "completion": "def split(string):\r\n    return list(string)"}
{"task_id": "Mbpp/566", "completion": "def sum_digits(n):\r\n    \"\"\"\r\n    This function takes a non-negative integer as input and returns the sum of its digits.\r\n    \"\"\"\r\n    # Initialize a variable to store the sum of digits\r\n    sum = 0\r\n    \r\n    # Convert the integer to a string to iterate over each digit\r\n    num_str = str(n)\r\n    \r\n    # Iterate over each digit in the string and add it to the sum\r\n    for digit in num_str:\r\n        sum += int(digit)\r\n        \r\n    return sum"}
{"task_id": "Mbpp/567", "completion": "def issort_list(lst):\r\n    \"\"\"\r\n    This function takes a list as input and returns True if the list is sorted in ascending order, False otherwise.\r\n    \"\"\"\r\n    for i in range(len(lst)-1):\r\n        if lst[i] > lst[i+1]:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/568", "completion": "def empty_list(n):\r\n    return [{} for i in range(n)]"}
{"task_id": "Mbpp/68", "completion": "def is_monotonic(arr):\r\n    \"\"\"\r\n    This function takes an array as input and returns True if the array is monotonic, False otherwise.\r\n    A monotonic array is an array in which the elements are either all increasing or all decreasing.\r\n    \"\"\"\r\n    # Check if the array has at least two elements\r\n    if len(arr) < 2:\r\n        return True\r\n    \r\n    # Check if the array is increasing\r\n    increasing = arr[0] <= arr[1]\r\n    for i in range(1, len(arr)-1):\r\n        if (increasing and arr[i] > arr[i+1]) or (not increasing and arr[i] < arr[i+1]):\r\n            return False\r\n    \r\n    # Check if the array is decreasing\r\n    decreasing = arr[0] >= arr[1]\r\n    for i in range(1, len(arr)-1):\r\n        if (increasing and arr[i] < arr[i+1]) or (not decreasing and arr[i] > arr[i+1]):\r\n            return False\r\n    \r\n    return True"}
{"task_id": "Mbpp/569", "completion": "def sort_sublists(lst):\r\n    \"\"\"\r\n    Sorts each sublist of strings in a given list of lists.\r\n    \"\"\"\r\n    for i in range(len(lst)):\r\n        lst[i].sort()\r\n    return lst"}
{"task_id": "Mbpp/572", "completion": "def remove_duplicates(lst):\r\n    \"\"\"\r\n    This function takes a list of lists as input and returns a new list with duplicates removed.\r\n    \"\"\"\r\n    new_lst = []\r\n    for num in lst:\r\n        if num not in new_lst:\r\n            new_lst.append(num)\r\n    return new_lst\r\n\r\ndef two_unique_nums(lst):\r\n    \"\"\"\r\n    This function takes a list of numbers as input and returns a new list with only two unique numbers.\r\n    \"\"\"\r\n    new_lst = remove_duplicates(lst)\r\n    if len(new_lst) > 2:\r\n        new_lst = new_lst[:2]\r\n    return new_lst\r\n\r\nassert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]"}
{"task_id": "Mbpp/573", "completion": "def unique_product(lst):\r\n    unique_nums = set(lst)\r\n    product = 1\r\n    for num in unique_nums:\r\n        product *= num\r\n    return product"}
{"task_id": "Mbpp/574", "completion": "def surfacearea_cylinder(radius, height):\r\n    \"\"\"\r\n    This function takes in two arguments, radius and height of the cylinder and returns the surface area of the cylinder.\r\n    \"\"\"\r\n    import math\r\n    surface_area = 2*math.pi*radius*height + 2*math.pi*radius**2\r\n    return surface_area"}
{"task_id": "Mbpp/576", "completion": "def is_Sub_Array(list1, list2):\r\n    \"\"\"\r\n    This function takes two lists as input and returns True if list1 is a sublist of list2, else False.\r\n    \"\"\"\r\n    if len(list1) > len(list2):\r\n        return False\r\n    for i in range(len(list2) - len(list1) + 1):\r\n        if list2[i:i+len(list1)] == list1:\r\n            return True\r\n    return False"}
{"task_id": "Mbpp/577", "completion": "def last_Digit_Factorial(n):\r\n    \"\"\"\r\n    This function takes an integer n as input and returns the last digit of n! (factorial of n).\r\n    \"\"\"\r\n    # Initialize a variable to store the result\r\n    result = 1\r\n    \r\n    # Iterate from n to 1 and multiply each number with the result\r\n    for i in range(n, 1, -1):\r\n        result *= i\r\n    \r\n    # Return the last digit of the result\r\n    return result % 10"}
{"task_id": "Mbpp/578", "completion": "def interleave_lists(list1, list2, list3):\r\n    assert len(list1) == len(list2) == len(list3)\r\n    result = []\r\n    for i in range(len(list1)):\r\n        result.append(list1[i])\r\n        result.append(list2[i])\r\n        result.append(list3[i])\r\n    return result"}
{"task_id": "Mbpp/579", "completion": "def find_dissimilar(t1, t2):\r\n    \"\"\"\r\n    This function takes two tuples as input and returns a tuple containing the dissimilar elements.\r\n    \"\"\"\r\n    dissimilar_elements = []\r\n    for i in t1:\r\n        if i not in t2:\r\n            dissimilar_elements.append(i)\r\n    for j in t2:\r\n        if j not in t1:\r\n            dissimilar_elements.append(j)\r\n    return tuple(dissimilar_elements)"}
{"task_id": "Mbpp/580", "completion": "def extract_even(nested_tuple):\r\n    result = []\r\n    for element in nested_tuple:\r\n        if isinstance(element, tuple):\r\n            result.append(extract_even(element))\r\n        elif element % 2 == 0:\r\n            result.append(element)\r\n    return tuple(result)"}
{"task_id": "Mbpp/581", "completion": "def surface_Area(base_edge, height):\r\n    return 2 * base_edge * height + base_edge ** 2"}
{"task_id": "Mbpp/69", "completion": "def is_sublist(lst, sublst):\r\n    \"\"\"\r\n    Checks whether a list contains a given sublist or not.\r\n    \r\n    Args:\r\n    lst: the list to check\r\n    sublst: the sublist to look for\r\n    \r\n    Returns:\r\n    True if the sublist is found in the list, False otherwise\r\n    \"\"\"\r\n    if len(sublst) == 0:\r\n        return True\r\n    for i in range(len(lst)):\r\n        if lst[i] == sublst[0]:\r\n            if lst[i:i+len(sublst)] == sublst:\r\n                return True\r\n    return False"}
{"task_id": "Mbpp/582", "completion": "def is_dict_empty(d):\r\n    return len(d) == 0"}
{"task_id": "Mbpp/583", "completion": "def catalan_number(n):\r\n    \"\"\"\r\n    Returns the nth Catalan number.\r\n    \"\"\"\r\n    if n == 0 or n == 1:\r\n        return 1\r\n    else:\r\n        return (2 * (2 * n - 1) * catalan_number(n - 1) // (n + 1))"}
{"task_id": "Mbpp/585", "completion": "def expensive_items(data, n):\r\n    sorted_data = sorted(data, key=lambda x: x['price'], reverse=True)\r\n    return sorted_data[:n]"}
{"task_id": "Mbpp/586", "completion": "def split_Arr(arr, n):\r\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "completion": "def list_tuple(lst):\r\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "completion": "def big_diff(lst):\r\n    \"\"\"\r\n    This function takes a list as input and returns the difference between the largest and smallest value in the list.\r\n    \"\"\"\r\n    return max(lst) - min(lst)"}
{"task_id": "Mbpp/589", "completion": "def perfect_squares(start, end):\r\n    \"\"\"\r\n    This function takes two numbers as input and returns a list of perfect squares between them.\r\n    \"\"\"\r\n    perfect_squares = []\r\n    for i in range(start, end+1):\r\n        if i**0.5 == int(i**0.5):\r\n            perfect_squares.append(i**2)\r\n    return perfect_squares"}
{"task_id": "Mbpp/590", "completion": "import cmath\r\n\r\ndef polar_rect(r, theta):\r\n    x = r * cmath.cos(theta)\r\n    y = r * cmath.sin(theta)\r\n    return (x, y)"}
{"task_id": "Mbpp/591", "completion": "def swap_List(lst):\r\n    lst[0], lst[-1] = lst[-1], lst[0]\r\n    return lst"}
{"task_id": "Mbpp/592", "completion": "def sum_of_product(n):\r\n    \"\"\"\r\n    This function takes a positive integer n as input and returns the sum of the product of consecutive binomial coefficients.\r\n    \"\"\"\r\n    # Initialize the sum variable to 0\r\n    sum = 0\r\n    # Loop through the range of n\r\n    for i in range(1, n+1):\r\n        # Calculate the binomial coefficient for i and i+1\r\n        binomial_i = 1\r\n        binomial_i_plus_1 = 1\r\n        for j in range(i):\r\n            binomial_i *= i\r\n            binomial_i_plus_1 *= (i+1)\r\n        # Calculate the product of the binomial coefficients and add it to the sum variable\r\n        sum += binomial_i * binomial_i_plus_1\r\n    return sum"}
{"task_id": "Mbpp/70", "completion": "def get_equal(tuples):\r\n    \"\"\"\r\n    This function takes a list of tuples as input and returns True if all the tuples have equal length, False otherwise.\r\n    \"\"\"\r\n    if not tuples:\r\n        return True\r\n    \r\n    length = len(tuples[0])\r\n    for tup in tuples:\r\n        if len(tup) != length:\r\n            return False\r\n    \r\n    return True"}
{"task_id": "Mbpp/593", "completion": "def removezero_ip(ip_address):\r\n    \"\"\"\r\n    This function takes an IP address as input and returns the IP address without leading zeroes.\r\n    \"\"\"\r\n    # Split the IP address into a list of octets\r\n    octets = ip_address.split('.')\r\n    # Initialize an empty list to store the octets without leading zeroes\r\n    new_octets = []\r\n    # Loop through each octet in the list\r\n    for octet in octets:\r\n        # If the octet starts with a zero, remove the leading zero\r\n        if octet.startswith('0'):\r\n            new_octets.append(str(int(octet)))\r\n        else:\r\n            new_octets.append(octet)\r\n    # Join the octets back together with dots and return the result\r\n    return '.'.join(new_octets)"}
{"task_id": "Mbpp/594", "completion": "def diff_even_odd(lst):\r\n    even_num = None\r\n    odd_num = None\r\n    for num in lst:\r\n        if num % 2 == 0:\r\n            if even_num is None:\r\n                even_num = num\r\n            else:\r\n                return num - even_num\r\n        else:\r\n            if odd_num is None:\r\n                odd_num = num\r\n            else:\r\n                return num - odd_num"}
{"task_id": "Mbpp/595", "completion": "def min_Swaps(binary1, binary2):\r\n    count = 0\r\n    for i in range(len(binary1)):\r\n        if binary1[i] != binary2[i]:\r\n            binary1 = binary1[:i] + binary2[i] + binary1[i+1:]\r\n            binary2 = binary2[:i] + binary1[i] + binary2[i+1:]\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/596", "completion": "import sys\r\n\r\ndef tuple_size(tup):\r\n    return sys.getsizeof(tup)"}
{"task_id": "Mbpp/597", "completion": "def find_kth(arr1, arr2, k):\r\n    \"\"\"\r\n    This function takes two sorted arrays and an integer k as input and returns the kth element from the concatenated array.\r\n    \"\"\"\r\n    # Initialize two pointers for both arrays\r\n    i = j = 0\r\n    # Initialize a counter to keep track of the current index in the concatenated array\r\n    count = 0\r\n    # Initialize a variable to store the length of the concatenated array\r\n    length = len(arr1) + len(arr2)\r\n    \r\n    # Loop through the concatenated array until we reach the kth element\r\n    while count < k:\r\n        # If the current index in arr1 is less than the length of arr1, increment i\r\n        if i < len(arr1):\r\n            i += 1\r\n        # If the current index in arr2 is less than the length of arr2, increment j\r\n        if j < len(arr2):\r\n            j += 1\r\n        # If both i and j are less than their respective array lengths, compare the elements at i and j\r\n        if i < len(arr1) and j < len(arr2):\r\n            # If the element at i is less than the element at j, increment count and move to the next element in arr1\r\n            if arr1[i-1] < arr2[j-1]:\r\n                count += 1\r\n                i += 1\r\n            # If the element at i is greater than or equal to the element at j, increment count and move to the next element in arr2\r\n            else:\r\n                count += len(arr1) - i + 1\r\n                j += 1\r\n        # If only arr1 is left, return the kth element of arr1\r\n        elif i < len(arr1):\r\n            return arr1[i-1]\r\n        # If only arr2 is left, return the kth element of arr2\r\n        elif j < len(arr2):\r\n            return arr2[j-1]\r\n    \r\n    # If we reach here, the kth element has been found\r\n    return arr1[i-1]"}
{"task_id": "Mbpp/598", "completion": "def armstrong_number(num):\r\n    # initialize sum and number of digits\r\n    sum = 0\r\n    n = num\r\n    # find the number of digits in the number\r\n    n_digits = len(str(num))\r\n    # calculate the sum of the cube of each digit\r\n    while n > 0:\r\n        digit = n % 10\r\n        sum += digit ** n_digits\r\n        n //= 10\r\n    # check if the sum is equal to the original number\r\n    if sum == num:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/599", "completion": "def sum_average(n):\r\n    sum = 0\r\n    for i in range(1, n+1):\r\n        sum += i\r\n    avg = sum / n\r\n    return (sum, avg)"}
{"task_id": "Mbpp/600", "completion": "def is_Even(num):\r\n    if num % 2 == 0:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/602", "completion": "def first_repeated_char(s):\r\n    \"\"\"\r\n    This function takes a string as input and returns the first repeated character in the string.\r\n    If there are no repeated characters, it returns None.\r\n    \"\"\"\r\n    char_count = {}\r\n    for char in s:\r\n        if char in char_count:\r\n            char_count[char] += 1\r\n        else:\r\n            char_count[char] = 1\r\n    for char in s:\r\n        if char_count[char] > 1:\r\n            return char\r\n    return None"}
{"task_id": "Mbpp/603", "completion": "def get_ludic(n):\r\n    lucid_numbers = []\r\n    for i in range(1, n+1):\r\n        if all(i % j != 0 for j in range(2, int(i**0.5)+1)) and i % 1 != 0:\r\n            lucid_numbers.append(i)\r\n    return lucid_numbers"}
{"task_id": "Mbpp/71", "completion": "def comb_sort(arr):\r\n    n = len(arr)\r\n    shrink_factor = 1.3\r\n    sorted = False\r\n    while not sorted:\r\n        sorted = True\r\n        i = 0\r\n        while i < n - 1:\r\n            if arr[i] > arr[i + 1]:\r\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\r\n                sorted = False\r\n            i += 1\r\n            gap = int(n / shrink_factor)\r\n            if gap > 1:\r\n                i = min(i + gap, n - 1)\r\n        if gap > 1:\r\n            shrink_factor = shrink_factor * 1.3\r\n            n = n - gap\r\n    return arr"}
{"task_id": "Mbpp/604", "completion": "def reverse_words(string):\r\n    words = string.split()\r\n    reversed_words = [word[::-1] for word in words]\r\n    return \" \".join(reversed_words)"}
{"task_id": "Mbpp/605", "completion": "def prime_num(n):\r\n    if n < 2:\r\n        return False\r\n    for i in range(2, int(n ** 0.5) + 1):\r\n        if n % i == 0:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/606", "completion": "def radian_degree(degree):\r\n    return degree * (3.1415926535897932384/180)"}
{"task_id": "Mbpp/607", "completion": "import re\r\n\r\ndef find_literals(string, pattern):\r\n    match = re.search(pattern, string)\r\n    if match:\r\n        return match.group(), match.start(), match.end()\r\n    else:\r\n        return None, None, None"}
{"task_id": "Mbpp/608", "completion": "def bell_Number(n):\r\n    if n == 1:\r\n        return 1\r\n    elif n == 2:\r\n        return 2\r\n    else:\r\n        bell = [1, 1]\r\n        for i in range(2, n+1):\r\n            bell.append(0)\r\n            for j in range(i):\r\n                bell[i] = bell[j] * (i - j) // (j + 1) + bell[j+1] * (j + 1)\r\n        return bell[n]"}
{"task_id": "Mbpp/610", "completion": "def remove_kth_element(lst, k):\r\n    return lst[:k] + lst[k+1:]"}
{"task_id": "Mbpp/611", "completion": "def max_of_nth(matrix, n):\r\n    max_val = float('-inf')\r\n    for row in matrix:\r\n        if row[n] > max_val:\r\n            max_val = row[n]\r\n    return max_val"}
{"task_id": "Mbpp/612", "completion": "def merge(lst):\r\n    return [list(x) for x in zip(*lst)]"}
{"task_id": "Mbpp/614", "completion": "def cummulative_sum(lst):\r\n    total = 0\r\n    for tup in lst:\r\n        for num in tup:\r\n            total += num\r\n    return total"}
{"task_id": "Mbpp/615", "completion": "def average_tuple(tuples):\r\n    result = []\r\n    for tup in tuples:\r\n        avg = sum(tup)/len(tup)\r\n        result.append(avg)\r\n    return result"}
{"task_id": "Mbpp/6", "completion": "def differ_At_One_Bit_Pos(num1, num2):\r\n    # Convert the numbers to binary strings\r\n    bin1 = bin(num1)[2:].zfill(8)\r\n    bin2 = bin(num2)[2:].zfill(8)\r\n    \r\n    # Initialize a counter to keep track of the number of differences\r\n    diff_count = 0\r\n    \r\n    # Loop through each bit position and compare the bits\r\n    for i in range(8):\r\n        if bin1[i] != bin2[i]:\r\n            diff_count += 1\r\n            \r\n    # If there is only one difference, return True, else return False\r\n    return diff_count == 1"}
{"task_id": "Mbpp/72", "completion": "def dif_Square(n):\r\n    for i in range(1, int(n/2)+1):\r\n        for j in range(1, int(n/2)+1):\r\n            if i*i + j*j == n:\r\n                return True\r\n    return False"}
{"task_id": "Mbpp/616", "completion": "def tuple_modulo(t1, t2):\r\n    assert len(t1) == len(t2), \"Both tuples should have the same length\"\r\n    result = []\r\n    for i in range(len(t1)):\r\n        result.append(t1[i] % t2[i])\r\n    return tuple(result)"}
{"task_id": "Mbpp/618", "completion": "def div_list(list1, list2):\r\n    \"\"\"\r\n    This function takes two lists as input and returns a new list containing the element-wise division of the two input lists.\r\n    \"\"\"\r\n    result = []\r\n    for i in range(len(list1)):\r\n        result.append(list1[i]/list2[i])\r\n    return result"}
{"task_id": "Mbpp/619", "completion": "def move_num(string):\r\n    nums = []\r\n    non_nums = []\r\n    for char in string:\r\n        if char.isdigit():\r\n            nums.append(char)\r\n        else:\r\n            non_nums.append(char)\r\n    return ''.join(non_nums) + ''.join(nums)"}
{"task_id": "Mbpp/620", "completion": "def largest_subset(numbers):\r\n    def is_divisible(a, b):\r\n        return a % b == 0 or b % a == 0\r\n    \r\n    def find_largest_subset(numbers, i=0, subset=set()):\r\n        if i == len(numbers):\r\n            return len(subset)\r\n        \r\n        max_size = 0\r\n        for j in range(i, len(numbers)):\r\n            if is_divisible(numbers[i], numbers[j]):\r\n                subset.add(numbers[j])\r\n                max_size = max(max_size, find_largest_subset(numbers, j+1, subset))\r\n                subset.remove(numbers[j])\r\n        \r\n        return max_size + 1\r\n    \r\n    return find_largest_subset(numbers)"}
{"task_id": "Mbpp/622", "completion": "def get_median(list1, list2, size):\r\n    \"\"\"\r\n    This function takes two sorted lists of the same size and returns their median value.\r\n    \"\"\"\r\n    if size % 2 == 0:\r\n        # If the size of the lists is even, the median is the average of the two middle values.\r\n        return (list1[size//2] + list2[size//2]) / 2\r\n    else:\r\n        # If the size of the lists is odd, the median is the middle value.\r\n        return list1[size//2]"}
{"task_id": "Mbpp/623", "completion": "def nth_nums(lst, n):\r\n    return [num**n for num in lst]"}
{"task_id": "Mbpp/624", "completion": "def is_upper(string):\r\n    return string.upper()"}
{"task_id": "Mbpp/626", "completion": "import math\r\n\r\ndef triangle_area(radius):\r\n    if radius < 0:\r\n        return None\r\n    else:\r\n        # Calculate the area of the largest triangle that can be inscribed in a semicircle with the given radius\r\n        # using Heron's formula\r\n        a = 2 * radius * math.sin(math.pi / 3)\r\n        b = 2 * radius * math.cos(math.pi / 6)\r\n        c = radius\r\n        s = (a + b + c) / 2\r\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\r\n        return area"}
{"task_id": "Mbpp/628", "completion": "def replace_spaces(string):\r\n    return string.replace(\" \", \"%20\")"}
{"task_id": "Mbpp/629", "completion": "def Split(lst):\r\n    even_numbers = []\r\n    for num in lst:\r\n        if num % 2 == 0:\r\n            even_numbers.append(num)\r\n    return even_numbers"}
{"task_id": "Mbpp/74", "completion": "def is_samepatterns(patterns, strings):\r\n    \"\"\"\r\n    This function takes two lists as input: patterns and strings.\r\n    It returns True if the strings follow the sequence given in the patterns array, else False.\r\n    \"\"\"\r\n    \r\n    # Initialize a variable to keep track of the index of the current pattern\r\n    index = 0\r\n    \r\n    # Loop through each string in the strings list\r\n    for string in strings:\r\n        \r\n        # Check if the current string matches the pattern at the current index\r\n        if string == patterns[index]:\r\n            \r\n            # If it matches, increment the index\r\n            index += 1\r\n            \r\n            # If the index becomes greater than the length of the patterns list, return True\r\n            if index == len(patterns):\r\n                return True\r\n        \r\n        # If the current string does not match the pattern at the current index, return False\r\n        else:\r\n            return False"}
{"task_id": "Mbpp/630", "completion": "def get_coordinates(coord):\r\n    x, y = coord\r\n    coordinates = []\r\n    for i in range(x-1, x+2):\r\n        for j in range(y-1, y+2):\r\n            if i != x or j != y:\r\n                coordinates.append((i, j))\r\n    return coordinates"}
{"task_id": "Mbpp/631", "completion": "def replace_spaces(string):\r\n    return string.replace(' ', '_').replace('_', ' ')"}
{"task_id": "Mbpp/632", "completion": "def move_zero(lst):\r\n    \"\"\"\r\n    This function takes a list as input and moves all the zeroes to the end of the list.\r\n    \"\"\"\r\n    # Initialize an empty list to store non-zero elements\r\n    non_zero = []\r\n    # Iterate through the input list\r\n    for i in lst:\r\n        # If the element is not zero, append it to the non_zero list\r\n        if i != 0:\r\n            non_zero.append(i)\r\n    # Append the zeroes to the end of the non_zero list\r\n    non_zero += [0] * lst.count(0)\r\n    # Return the non_zero list\r\n    return non_zero"}
{"task_id": "Mbpp/633", "completion": "def pair_xor_Sum(lst, n):\r\n    \"\"\"\r\n    This function takes a list of integers and an integer as input and returns the sum of xor of all pairs of numbers in the list.\r\n    \"\"\"\r\n    result = 0\r\n    for i in range(len(lst)):\r\n        for j in range(i+1, len(lst)):\r\n            result += lst[i] ^ lst[j]\r\n    return result ^ n"}
{"task_id": "Mbpp/635", "completion": "def heap_sort(arr):\r\n    n = len(arr)\r\n    for i in range(n//2 - 1, -1, -1):\r\n        heapify(arr, n, i)\r\n    for i in range(n-1, 0, -1):\r\n        arr[0], arr[i] = arr[i], arr[0]\r\n        heapify(arr, i, 0)\r\n    return arr\r\n\r\ndef heapify(arr, n, i):\r\n    largest = i\r\n    left = 2*i + 1\r\n    right = 2*i + 2\r\n    if left < n and arr[left] > arr[largest]:\r\n        largest = left\r\n    if right < n and arr[right] > arr[largest]:\r\n        largest = right\r\n    if largest != i:\r\n        arr[i], arr[largest] = arr[largest], arr[i]\r\n        heapify(arr, n, largest)\r\n\r\nassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"task_id": "Mbpp/637", "completion": "def noprofit_noloss(amount1, amount2):\r\n    if amount1 == amount2:\r\n        return True\r\n    elif amount1 > amount2:\r\n        return False\r\n    else:\r\n        return True"}
{"task_id": "Mbpp/638", "completion": "def wind_chill(wind_velocity, temperature):\r\n    \"\"\"\r\n    Calculates the wind chill index based on the formula:\r\n    wind_chill = 13.12 + 0.6215 * temperature - 11.37 * wind_velocity**0.16 + 0.3965 * temperature * wind_velocity**0.16\r\n    \"\"\"\r\n    wind_chill = 13.12 + 0.6215 * temperature - 11.37 * wind_velocity**0.16 + 0.3965 * temperature * wind_velocity**0.16\r\n    return round(wind_chill)"}
{"task_id": "Mbpp/639", "completion": "def sum_names(names):\r\n    total_length = 0\r\n    for name in names:\r\n        if name[0].isupper():\r\n            total_length += len(name)\r\n    return total_length"}
{"task_id": "Mbpp/640", "completion": "def remove_parenthesis(string):\r\n    \"\"\"\r\n    This function takes a string as input and removes the parenthesis and what is inbetween them from the string.\r\n    \"\"\"\r\n    # Using regular expression to find the pattern of parenthesis and remove it from the string\r\n    return re.sub(r'\\([^)]*\\)', '', string[0])"}
{"task_id": "Mbpp/641", "completion": "def is_nonagonal(n):\r\n    return n * (n * n * (n * 2 - 1)"}
{"task_id": "Mbpp/75", "completion": "def find_tuples(lst, k):\r\n    result = []\r\n    for tup in lst:\r\n        if all(x % k == 0 for x in tup):\r\n            result.append(tup)\r\n    return result"}
{"task_id": "Mbpp/643", "completion": "def text_match_wordz_middle(text):\r\n    return 'z' in text[1:-1]"}
{"task_id": "Mbpp/644", "completion": "def reverse_Array_Upto_K(arr, k):\r\n    \"\"\"\r\n    This function takes an array and a position k as input and returns the array with elements reversed up to k.\r\n    \"\"\"\r\n    # Reversing the array up to k\r\n    for i in range(k//2):\r\n        arr[i], arr[k-i-1] = arr[k-i-1], arr[i]\r\n    return arr\r\n\r\n# Testing the function\r\nassert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6],4) == [4, 3, 2, 1, 5, 6]"}
{"task_id": "Mbpp/720", "completion": "def add_dict_to_tuple(tup, dict_val):\r\n    return tup + (dict_val,)"}
{"task_id": "Mbpp/721", "completion": "def maxAverageOfPath(matrix):\r\n    n = len(matrix)\r\n    dp = [[0] * n for _ in range(n)]\r\n    dp[0][0] = matrix[0][0]\r\n    for i in range(1, n):\r\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\r\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\r\n    for i in range(1, n):\r\n        for j in range(1, n):\r\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\r\n    return dp[n-1][n-1] / (n-1)\r\n\r\n# Test the function with the given example\r\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2"}
{"task_id": "Mbpp/722", "completion": "def filter_data(data, min_height, min_weight):\r\n    filtered_data = {}\r\n    for key, value in data.items():\r\n        if value[0] > min_height and value[1] > min_weight:\r\n            filtered_data[key] = value\r\n    return filtered_data"}
{"task_id": "Mbpp/723", "completion": "def count_same_pair(list1, list2):\r\n    count = 0\r\n    for i in range(len(list1)):\r\n        if list1[i] == list2[i]:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/724", "completion": "def power_base_sum(base, power):\r\n    \"\"\"\r\n    This function takes base and power as arguments and returns the sum of all digits of the base raised to the specified power.\r\n    \"\"\"\r\n    result = 0\r\n    for i in range(1, power+1):\r\n        result += base ** i\r\n    return result"}
{"task_id": "Mbpp/725", "completion": "def extract_quotation(string):\r\n    \"\"\"\r\n    Extracts values between quotation marks \" \" of the given string.\r\n    \"\"\"\r\n    # Initialize an empty list to store the values between quotation marks\r\n    values = []\r\n    # Initialize a flag to keep track of whether we are inside a quotation or not\r\n    inside_quotation = False\r\n    # Initialize a variable to store the current value being extracted\r\n    current_value = \"\"\r\n    # Loop through each character in the string\r\n    for char in string:\r\n        # If we encounter a quotation mark, toggle the flag\r\n        if char == '\"':\r\n            inside_quotation = not inside_quotation\r\n        # If we are inside a quotation, add the character to the current value\r\n        elif inside_quotation:\r\n            current_value += char\r\n        # If we are not inside a quotation and encounter a space, add the current value to the list and reset it\r\n        elif char == \" \":\r\n            if current_value:\r\n                values.append(current_value)\r\n                current_value = \"\"\r\n    # Add the last value to the list\r\n    if current_value:\r\n        values.append(current_value)\r\n    # Return the list of values\r\n    return values"}
{"task_id": "Mbpp/726", "completion": "def multiply_elements(t):\r\n    result = []\r\n    for i in range(len(t)-1):\r\n        result.append(t[i]*t[i+1])\r\n    return tuple(result)"}
{"task_id": "Mbpp/728", "completion": "def sum_list(a, b):\r\n    return [a[i] + b[i] for i in range(len(a))]"}
{"task_id": "Mbpp/77", "completion": "def is_Divisible_by_11(num):\r\n    if num % 11 == 0:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/730", "completion": "def consecutive_duplicates(lst):\r\n    result = []\r\n    prev = None\r\n    for item in lst:\r\n        if item != prev:\r\n            result.append(item)\r\n            prev = item\r\n    return result"}
{"task_id": "Mbpp/731", "completion": "import math\r\n\r\ndef lateralsurface_cone(r, h):\r\n    return 2 * math.pi * r * h"}
{"task_id": "Mbpp/732", "completion": "def replace_specialchar(string):\r\n    return string.replace(' ',':').replace(',',':').replace('.',':')"}
{"task_id": "Mbpp/733", "completion": "def find_first_occurrence(arr, num):\r\n    \"\"\"\r\n    Find the index of the first occurrence of a given number in a sorted array.\r\n    \"\"\"\r\n    left, right = 0, len(arr) - 1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if arr[mid] == num:\r\n            # If the middle element is equal to the target, check if it's the first occurrence\r\n            if mid == 0 or arr[mid - 1] < num:\r\n                return mid\r\n            else:\r\n                right = mid - 1\r\n        elif arr[mid] < num:\r\n            # If the middle element is less than the target, search in the right half\r\n            left = mid + 1\r\n        else:\r\n            # If the middle element is greater than the target, search in the left half\r\n            right = mid - 1\r\n    # If the target is not found, return -1\r\n    return -1"}
{"task_id": "Mbpp/734", "completion": "def sum_of_subarray_prod(arr):\r\n    n = len(arr)\r\n    total_sum = 0\r\n    for i in range(n):\r\n        for j in range(i, n):\r\n            product = 1\r\n            for k in range(i, j+1):\r\n                product *= arr[k]\r\n            total_sum += product\r\n    return total_sum"}
{"task_id": "Mbpp/735", "completion": "def toggle_middle_bits(num):\r\n    # Convert the number to binary and remove the first and last bits\r\n    binary_num = bin(num)[2:-1]\r\n    \r\n    # Toggle the bits in the middle\r\n    middle_bits = ''.join(str(int(not int(bit)) for bit in binary_num)\r\n    \r\n    # Convert the toggled bits back to decimal and add the first and last bits\r\n    result = int(binary_num[0] + middle_bits + binary_num[-1], 2)\r\n    \r\n    return result"}
{"task_id": "Mbpp/736", "completion": "def left_insertion(arr, val):\r\n    \"\"\"\r\n    This function takes in a sorted array and a value to be inserted and returns the index where the value should be inserted in the array.\r\n    \"\"\"\r\n    for i in range(len(arr)):\r\n        if arr[i] > val:\r\n            return i\r\n    return len(arr)"}
{"task_id": "Mbpp/737", "completion": "import re\r\n\r\ndef check_str(string):\r\n    vowels = \"aeiouAEIOU\"\r\n    pattern = re.compile(r\"^[\" + vowels + \"]\")\r\n    if pattern.match(string):\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/739", "completion": "def find_Index(n):\r\n    i = 1\r\n    while True:\r\n        triangular_num = i*(i+1)//2\r\n        if len(str(triangular_num)) == n:\r\n            return i\r\n        i += 1"}
{"task_id": "Mbpp/740", "completion": "def tuple_to_dict(tup):\r\n    \"\"\"\r\n    This function takes a tuple as input and returns a dictionary with adjacent elements as key-value pairs.\r\n    \"\"\"\r\n    result = {}\r\n    for i in range(0, len(tup), 2):\r\n        result[tup[i]] = tup[i+1]\r\n    return result"}
{"task_id": "Mbpp/79", "completion": "def word_len(word):\r\n    return len(word) % 2 != 0"}
{"task_id": "Mbpp/741", "completion": "def all_Characters_Same(string):\r\n    return len(set(string)) == 1"}
{"task_id": "Mbpp/742", "completion": "def area_tetrahedron(a, b, c, d):\r\n    \"\"\"\r\n    Calculates the area of a tetrahedron with side lengths a, b, c, and d.\r\n    Returns the area of the tetrahedron.\r\n    \"\"\"\r\n    s = (a + b + c) / 2\r\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\r\n    return area"}
{"task_id": "Mbpp/743", "completion": "def rotate_right(lst, n):\r\n    \"\"\"\r\n    This function takes a list and a number n as input and returns the list rotated n positions to the right.\r\n    \"\"\"\r\n    # If n is greater than the length of the list, rotate the list by the length of the list\r\n    if n > len(lst):\r\n        n = n % len(lst)\r\n    # Reverse the whole list\r\n    lst = lst[::-1]\r\n    # Reverse the first n elements\r\n    lst[:n] = lst[:n][::-1]\r\n    # Reverse the remaining elements\r\n    lst[n:] = lst[n:][::-1]\r\n    # Reverse the whole list again to get the final result\r\n    lst = lst[::-1]\r\n    return lst"}
{"task_id": "Mbpp/744", "completion": "def check_none(tup):\r\n    for i in tup:\r\n        if i is None:\r\n            return True\r\n    return False"}
{"task_id": "Mbpp/745", "completion": "def divisible_by_digits(startnum, endnum):\r\n    def is_divisible(num):\r\n        for digit in str(num):\r\n            if num % int(digit) != 0:\r\n                return False\r\n        return True\r\n\r\n    return [num for num in range(startnum, endnum+1) if is_divisible(num)]"}
{"task_id": "Mbpp/746", "completion": "import math\r\n\r\ndef sector_area(radius, angle):\r\n    if angle > 360:\r\n        return None\r\n    else:\r\n        return radius ** 2 * angle * math.sin(math.radians(angle)) / 360"}
{"task_id": "Mbpp/748", "completion": "def capital_words_spaces(string):\r\n    words = string.split()\r\n    result = []\r\n    for word in words:\r\n        if word[0].isupper():\r\n            result.append(word + ' ')\r\n        else:\r\n            result.append(word)\r\n    return ''.join(result)"}
{"task_id": "Mbpp/749", "completion": "def sort_numeric_strings(lst):\r\n    return sorted(lst, key=lambda x: int(x))"}
{"task_id": "Mbpp/750", "completion": "def add_tuple(lst, tup):\r\n    lst.extend(tup)\r\n    return lst"}
{"task_id": "Mbpp/751", "completion": "def check_min_heap(arr):\r\n    n = len(arr)\r\n    for i in range(n//2):\r\n        if arr[i] > arr[2*i+1] or arr[i] > arr[2*i+2]:\r\n            return False\r\n        if 2*i+2 < n and arr[2*i+1] > arr[2*i+2]:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/80", "completion": "def tetrahedral_number(n):\r\n    return n * (n + 1) * (n + 2) // 2"}
{"task_id": "Mbpp/752", "completion": "def jacobsthal_num(n):\r\n    if n == 0:\r\n        return 0\r\n    elif n == 1:\r\n        return 1\r\n    else:\r\n        return jacobsthal_num(n-1) + jacobsthal_num(n-2) + 2*jacobsthal_num(n-3)"}
{"task_id": "Mbpp/753", "completion": "def min_k(lst, k):\r\n    return sorted(lst, key=lambda x: x[1])[:k]"}
{"task_id": "Mbpp/754", "completion": "def extract_index_list(l1, l2, l3):\r\n    common_elements = []\r\n    for i in range(len(l1)):\r\n        if l1[i] == l2[i] == l3[i]:\r\n            common_elements.append(l1[i])\r\n    return common_elements"}
{"task_id": "Mbpp/755", "completion": "def second_smallest(lst):\r\n    \"\"\"\r\n    This function takes a list of numbers as input and returns the second smallest number in the list.\r\n    \"\"\"\r\n    lst.sort()\r\n    return lst[1]"}
{"task_id": "Mbpp/757", "completion": "def count_reverse_pairs(lst):\r\n    count = 0\r\n    for i in range(len(lst)):\r\n        for j in range(i+1, len(lst)):\r\n            if lst[i][::-1] == lst[j]:\r\n                count += 1\r\n    return count"}
{"task_id": "Mbpp/758", "completion": "def count_lists(lst):\r\n    \"\"\"\r\n    This function takes a list of lists as input and returns a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurences in the original list.\r\n    \"\"\"\r\n    count_dict = {}\r\n    for sublist in lst:\r\n        tup = tuple(sublist)\r\n        if tup in count_dict:\r\n            count_dict[tup] += 1\r\n        else:\r\n            count_dict[tup] = 1\r\n    return count_dict"}
{"task_id": "Mbpp/759", "completion": "def is_decimal(num):\r\n    try:\r\n        float(num)\r\n        return True\r\n    except ValueError:\r\n        return False\r\n\r\nassert is_decimal('123.11')==True"}
{"task_id": "Mbpp/760", "completion": "def unique_Element(lst):\r\n    return len(set(lst)) == 1"}
{"task_id": "Mbpp/762", "completion": "def check_monthnumber_number(month_number):\r\n    if month_number in [4, 6, 9, 11]:\r\n        return True\r\n    elif month_number in [1, 3, 5, 7, 8, 10, 12]:\r\n        return False\r\n    elif month_number in [2]:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/763", "completion": "def find_min_diff(arr, n):\r\n    arr.sort()\r\n    min_diff = float('inf')\r\n    for i in range(n-1):\r\n        diff = arr[i+1] - arr[i]\r\n        if diff < min_diff:\r\n            min_diff = diff\r\n    return min_diff"}
{"task_id": "Mbpp/82", "completion": "import math\r\n\r\ndef volume_sphere(radius):\r\n    return (4/3) * math.pi * (radius ** 3)"}
{"task_id": "Mbpp/764", "completion": "def number_ctr(string):\r\n    count = 0\r\n    for char in string:\r\n        if char.isdigit():\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/765", "completion": "def is_polite(n):\r\n    \"\"\"\r\n    Returns the nth polite number.\r\n    \"\"\"\r\n    def is_polite(num):\r\n        return sum(1 for i in range(1, num) if num % i == 0)\r\n    \r\n    def polite_numbers():\r\n        count = 0\r\n        num = 1\r\n        while True:\r\n            if is_polite(num) == num:\r\n                count += 1\r\n                if count == n:\r\n                    return num\r\n            num += 1\r\n    \r\n    return polite_numbers()"}
{"task_id": "Mbpp/766", "completion": "def pair_wise(lst):\r\n    pairs = []\r\n    for i in range(len(lst)-1):\r\n        pairs.append((lst[i], lst[i+1]))\r\n    return pairs"}
{"task_id": "Mbpp/767", "completion": "def get_pairs_count(numbers, sum):\r\n    count = 0\r\n    for i in range(len(numbers)):\r\n        for j in range(i+1, len(numbers)):\r\n            if numbers[i] + numbers[j] == sum:\r\n                count += 1\r\n    return count"}
{"task_id": "Mbpp/769", "completion": "def Diff(list1, list2):\r\n    return [x for x in list1 if x not in list2]"}
{"task_id": "Mbpp/770", "completion": "def odd_num_sum(n):\r\n    sum = 0\r\n    for i in range(1, n+1, 2):\r\n        sum += i**4\r\n    return sum"}
{"task_id": "Mbpp/771", "completion": "def check_expression(expression):\r\n    stack = []\r\n    for char in expression:\r\n        if char in [\"(\", \"{\", \"[\"]:\r\n            stack.append(char)\r\n        elif char in [\")\", \"}\", \"]\"]:\r\n            if not stack:\r\n                return False\r\n            if (char == \")\" and stack[-1] == \"(\") or (char == \"}\" and stack[-1] == \"{\") or (char == \"]\" and stack[-1] == \"[\"):\r\n                stack.pop()\r\n            else:\r\n                return False\r\n    return len(stack) == 0"}
{"task_id": "Mbpp/772", "completion": "def remove_length(string, k):\r\n    words = string.split()\r\n    result = []\r\n    for word in words:\r\n        if len(word) != k:\r\n            result.append(word)\r\n    return ' '.join(result)"}
{"task_id": "Mbpp/773", "completion": "def occurance_substring(string, substring):\r\n    if substring in string:\r\n        return (substring, string.index(substring), string.rindex(substring))\r\n    else:\r\n        return None"}
{"task_id": "Mbpp/775", "completion": "def odd_position(lst):\r\n    for i in range(1, len(lst), 2):\r\n        if lst[i] % 2 == 0:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/83", "completion": "def get_Char(string):\r\n    sum = 0\r\n    for char in string:\r\n        sum += ord(char)\r\n    return chr(sum % 26 + 97)"}
{"task_id": "Mbpp/777", "completion": "def find_sum(lst):\r\n    \"\"\"\r\n    This function takes a list as input and returns the sum of non-repeated elements in the list.\r\n    \"\"\"\r\n    non_repeated_sum = 0\r\n    for i in lst:\r\n        if lst.count(i) == 1:\r\n            non_repeated_sum += i\r\n    return non_repeated_sum"}
{"task_id": "Mbpp/778", "completion": "def pack_consecutive_duplicates(lst):\r\n    result = []\r\n    sublist = []\r\n    for i in range(len(lst)):\r\n        if i == 0 or lst[i] != lst[i-1]:\r\n            sublist = [lst[i]]\r\n            result.append(sublist)\r\n        else:\r\n            sublist.append(lst[i])\r\n    return result"}
{"task_id": "Mbpp/780", "completion": "from itertools import combinations\r\n\r\ndef find_combinations(lst):\r\n    result = []\r\n    for i in range(1, len(lst)+1):\r\n        for combo in combinations(lst, i):\r\n            total = sum(combo)\r\n            result.append(total)\r\n    return result\r\n\r\nlst = [(2, 4), (6, 7), (5, 1), (6, 10)]\r\nprint(find_combinations(lst))"}
{"task_id": "Mbpp/781", "completion": "def count_divisors(n):\r\n    count = 0\r\n    for i in range(1, n+1):\r\n        if n % i == 0:\r\n            count += 1\r\n    if count % 2 == 0:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/782", "completion": "def odd_length_sum(arr):\r\n    n = len(arr)\r\n    sum = 0\r\n    for i in range(n):\r\n        for j in range(i+1, n):\r\n            for k in range(j+1, n):\r\n                if k-j+1 % 2 != 0:\r\n                    sum += arr[j:k+1].sum()\r\n    return sum"}
{"task_id": "Mbpp/783", "completion": "def rgb_to_hsv(r, g, b):\r\n    r, g, b = r/255.0, g/255.0, b/255.0\r\n    cmax = max(r, g, b)\r\n    cmin = min(r, g, b)\r\n    delta = cmax - cmin\r\n    if delta == 0:\r\n        hue = 0\r\n    elif cmax == r:\r\n        hue = 60 * ((g - b) / delta % 6)\r\n    elif cmax == g:\r\n        hue = 60 * ((b - r) / delta + 2)\r\n    else:\r\n        hue = 60 * ((r - g) / delta + 4)\r\n    if cmax == 0:\r\n        sat = 0\r\n    else:\r\n        sat = delta / cmax\r\n    val = cmax\r\n    return hue, sat, val"}
{"task_id": "Mbpp/784", "completion": "def mul_even_odd(lst):\r\n    even_product = 1\r\n    odd_product = 1\r\n    for num in lst:\r\n        if num % 2 == 0:\r\n            even_product *= num\r\n        else:\r\n            odd_product *= num\r\n    return even_product * odd_product"}
{"task_id": "Mbpp/785", "completion": "def tuple_str_int(tup_str):\r\n    return tuple(map(int, tup_str.strip('()').split(',')))"}
{"task_id": "Mbpp/786", "completion": "def right_insertion(arr, val):\r\n    left = 0\r\n    right = len(arr) - 1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if arr[mid] < val:\r\n            left = mid + 1\r\n        else:\r\n            right = mid - 1\r\n    return left"}
{"task_id": "Mbpp/787", "completion": "def text_match_three(text):\r\n    if text[0] == 'a' and text[1:4] == 'bbb':\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/84", "completion": "def sequence(n):\r\n    if n == 1:\r\n        return 1\r\n    elif n == 2:\r\n        return 1\r\n    elif n == 3:\r\n        return 2\r\n    else:\r\n        a = 1\r\n        b = 1\r\n        c = 2\r\n        i = 4\r\n        while i <= n:\r\n            d = a + b\r\n            a = b\r\n            b = c\r\n            c = d\r\n            i += 1\r\n        return c"}
{"task_id": "Mbpp/788", "completion": "def new_tuple(lst, string):\r\n    return tuple(lst + [string])"}
{"task_id": "Mbpp/790", "completion": "def even_position(lst):\r\n    for i in range(0, len(lst), 2):\r\n        if lst[i] % 2 != 0:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/791", "completion": "def remove_nested(tup):\r\n    \"\"\"\r\n    This function takes a tuple as input and removes any nested tuples from it.\r\n    \"\"\"\r\n    result = []\r\n    for item in tup:\r\n        if type(item) == tuple:\r\n            result.extend(item)\r\n        else:\r\n            result.append(item)\r\n    return tuple(result)"}
{"task_id": "Mbpp/792", "completion": "def count_list(lst):\r\n    count = 0\r\n    for i in lst:\r\n        if type(i) == list:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/793", "completion": "def last(arr, x):\r\n    \"\"\"\r\n    Returns the last position of an element in a sorted array.\r\n    \"\"\"\r\n    n = len(arr)\r\n    for i in range(n-1, -1, -1):\r\n        if arr[i] == x:\r\n            return i\r\n    return -1"}
{"task_id": "Mbpp/794", "completion": "def text_starta_endb(string):\r\n    return string.startswith('a') and string.endswith('b')"}
{"task_id": "Mbpp/796", "completion": "def return_sum(d):\r\n    return sum(d.values())"}
{"task_id": "Mbpp/797", "completion": "def sum_in_range(l, r):\r\n    \"\"\"\r\n    This function takes two arguments l and r, where l is the starting number and r is the ending number of the range.\r\n    It returns the sum of all odd numbers within the range l and r.\r\n    \"\"\"\r\n    sum = 0\r\n    for i in range(l, r+1):\r\n        if i % 2 != 0:\r\n            sum += i\r\n    return sum"}
{"task_id": "Mbpp/798", "completion": "def sum_array(arr):\r\n    return sum(arr)"}
{"task_id": "Mbpp/799", "completion": "def left_rotate(num, d):\r\n    return ((num << d) | (num >> (32 - d)) & 0xFFFFFFFF)"}
{"task_id": "Mbpp/85", "completion": "import math\r\n\r\ndef surfacearea_sphere(radius):\r\n    return 4 * math.pi * radius ** 2"}
{"task_id": "Mbpp/800", "completion": "def remove_all_spaces(string):\r\n    return string.replace(\" \", \"\")"}
{"task_id": "Mbpp/801", "completion": "def test_three_equal(a, b, c):\r\n    count = 0\r\n    if a == b == c:\r\n        count += 1\r\n    if a != b and b == c:\r\n        count += 1\r\n    if a == b and b != c:\r\n        count += 1\r\n    if a != b and a == c:\r\n        count += 1\r\n    if a != b and b != c and a == c:\r\n        count += 1\r\n    return count"}
{"task_id": "Mbpp/803", "completion": "def is_perfect_square(n):\r\n    if n < 0:\r\n        return False\r\n    else:\r\n        i = 0\r\n        while (i * i) <= n:\r\n            i += 1\r\n        return i * i == n"}
{"task_id": "Mbpp/804", "completion": "def is_product_even(numbers):\r\n    product = 1\r\n    for num in numbers:\r\n        product *= num\r\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "completion": "def max_sum_list(lst):\r\n    max_sum = 0\r\n    max_lst = []\r\n    for sublist in lst:\r\n        if sum(sublist) > max_sum:\r\n            max_sum = sum(sublist)\r\n            max_lst = sublist\r\n    return max_lst"}
{"task_id": "Mbpp/806", "completion": "def max_run_uppercase(s):\r\n    max_run = 0\r\n    current_run = 0\r\n    for char in s:\r\n        if char.isupper():\r\n            current_run += 1\r\n        else:\r\n            max_run = max(max_run, current_run)\r\n            current_run = 0\r\n    return max(max_run, current_run)"}
{"task_id": "Mbpp/807", "completion": "def first_odd(numbers):\r\n    for num in numbers:\r\n        if num % 2 != 0:\r\n            return num\r\n    return None"}
{"task_id": "Mbpp/808", "completion": "def check_K(tup, k):\r\n    \"\"\"\r\n    This function takes a tuple and an integer k as input and returns True if k is present in the tuple, else False.\r\n    \"\"\"\r\n    if k in tup:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/809", "completion": "def check_smaller(tup1, tup2):\r\n    \"\"\"\r\n    This function takes two tuples as input and returns True if each element of the second tuple is smaller than its corresponding element in the first tuple, otherwise False.\r\n    \"\"\"\r\n    for i in range(len(tup1)):\r\n        if tup1[i] < tup2[i]:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/7", "completion": "def find_char_long(string):\r\n    words = string.split()\r\n    result = []\r\n    for word in words:\r\n        if len(word) >= 4:\r\n            result.append(word)\r\n    return result"}
{"task_id": "Mbpp/86", "completion": "def centered_hexagonal_number(n):\r\n    \"\"\"\r\n    Returns the nth centered hexagonal number.\r\n    \"\"\"\r\n    return (n * (2 * n - 1))"}
{"task_id": "Mbpp/87", "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\r\n    merged_dict = dict1.copy()\r\n    merged_dict.update(dict2)\r\n    merged_dict.update(dict3)\r\n    return merged_dict"}
{"task_id": "Mbpp/88", "completion": "def freq_count(lst):\r\n    freq = {}\r\n    for i in lst:\r\n        if i in freq:\r\n            freq[i] += 1\r\n        else:\r\n            freq[i] = 1\r\n    return freq"}
{"task_id": "Mbpp/89", "completion": "def closest_num(n):\r\n    \"\"\"\r\n    This function takes an integer n as input and returns the closest smaller number than n.\r\n    \"\"\"\r\n    # Convert n to a string and split it into a list of digits\r\n    digits = [int(d) for d in str(n)]\r\n    # Sort the digits in descending order\r\n    digits.sort(reverse=True)\r\n    # Convert the digits back to a number\r\n    closest = int(''.join(str(d) for d in digits))\r\n    # If the closest number is less than n, return it\r\n    if closest < n:\r\n        return closest\r\n    # Otherwise, return None\r\n    else:\r\n        return None"}
{"task_id": "Mbpp/90", "completion": "def len_log(words):\r\n    max_length = 0\r\n    for word in words:\r\n        if len(word) > max_length:\r\n            max_length = len(word)\r\n    return max_length"}
{"task_id": "Mbpp/91", "completion": "def find_substring(lst, substr):\r\n    for string in lst:\r\n        if substr in string:\r\n            return True\r\n    return False"}
{"task_id": "Mbpp/92", "completion": "def is_undulating(n):\r\n    \"\"\"\r\n    Checks whether a number is undulating or not.\r\n    A number is undulating if it alternates between odd and even digits.\r\n    \"\"\"\r\n    digits = [int(d) for d in str(n)]\r\n    for i in range(len(digits) - 1):\r\n        if digits[i] % 2 == 0 and digits[i+1] % 2 == 0:\r\n            return False\r\n        elif digits[i] % 2 == 1 and digits[i+1] % 2 == 1:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/93", "completion": "def power(a, b):\r\n    return a ** b"}
{"task_id": "Mbpp/94", "completion": "def index_minimum(lst):\r\n    \"\"\"\r\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\r\n    \"\"\"\r\n    return min(lst, key=lambda x: x[1])[0]"}
{"task_id": "Mbpp/95", "completion": "def Find_Min_Length(lst):\r\n    min_length = len(lst[0])\r\n    for i in lst:\r\n        if len(i) < min_length:\r\n            min_length = len(i)\r\n    return min_length"}
{"task_id": "Mbpp/8", "completion": "def square_nums(lst):\r\n    return [x**2 for x in lst]"}
{"task_id": "Mbpp/96", "completion": "def divisor(n):\r\n    count = 0\r\n    for i in range(1, n+1):\r\n        if n % i == 0:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/97", "completion": "def frequency_lists(lst):\r\n    freq_dict = {}\r\n    for sublist in lst:\r\n        for item in sublist:\r\n            if item in freq_dict:\r\n                freq_dict[item] += 1\r\n            else:\r\n                freq_dict[item] = 1\r\n    return freq_dict"}
{"task_id": "Mbpp/98", "completion": "import math\r\n\r\ndef multiply_num(lst):\r\n    product = 1\r\n    for num in lst:\r\n        product *= num\r\n    return product / len(lst)"}
{"task_id": "Mbpp/99", "completion": "def decimal_to_binary(num):\r\n    if num == 0:\r\n        return '0'\r\n    else:\r\n        return bin(num)[2:]"}
{"task_id": "Mbpp/100", "completion": "def next_smallest_palindrome(n):\r\n    if n % 10 == 0:\r\n        return n + 1\r\n    \r\n    # Convert the integer to a string and reverse it\r\n    s = str(n)\r\n    s = s + s[::-1]\r\n    \r\n    # Increment the integer by 1 until it is a palindrome\r\n    while s != s[::-1]:\r\n        n += 1\r\n        s = str(n)\r\n        s = s + s[::-1]\r\n    \r\n    return int(s)"}
{"task_id": "Mbpp/101", "completion": "def kth_element(arr, k):\r\n    return arr[k-1]"}
{"task_id": "Mbpp/102", "completion": "def snake_to_camel(snake_str):\r\n    words = snake_str.split('_')\r\n    return words[0] + ''.join(word.title() for word in words[1:])"}
{"task_id": "Mbpp/103", "completion": "def eulerian_num(n, m):\r\n    if n == 1:\r\n        return 1\r\n    elif m == 1:\r\n        return 1\r\n    else:\r\n        return (n + 1) * eulerian_num(n - 1, m) + eulerian_num(n - 1, m - 1)"}
{"task_id": "Mbpp/104", "completion": "def sort_sublists(lst):\r\n    \"\"\"\r\n    Sorts each sublist of strings in a given list of lists.\r\n    \"\"\"\r\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/105", "completion": "def count_true_booleans(lst):\r\n    count = 0\r\n    for item in lst:\r\n        if item == True:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/9", "completion": "def find_Rotations(s):\r\n    n = len(s)\r\n    if n == 0:\r\n        return 0\r\n    \r\n    for i in range(n):\r\n        if s[i] != s[i%n]:\r\n            return i+1\r\n    \r\n    return 0"}
{"task_id": "Mbpp/106", "completion": "def add_lists(lst, tup):\r\n    return tup + tuple(lst)"}
{"task_id": "Mbpp/108", "completion": "def merge_sorted_list(list1, list2, list3):\r\n    # Combine the three lists into one list\r\n    combined_list = list1 + list2 + list3\r\n    # Sort the combined list\r\n    combined_list.sort()\r\n    return combined_list"}
{"task_id": "Mbpp/109", "completion": "def odd_Equivalent(binary_string, rotations):\r\n    # Convert the binary string to a list of integers\r\n    binary_list = list(map(int, binary_string))\r\n    \r\n    # Rotate the list by the given number of rotations\r\n    binary_list = binary_list[-rotations:] + binary_list[:-rotations]\r\n    \r\n    # Count the number of odd digits in the rotated list\r\n    odd_count = sum(1 for digit in binary_list if digit % 2 == 1)\r\n    \r\n    return odd_count"}
{"task_id": "Mbpp/111", "completion": "def common_in_nested_lists(lists):\r\n    common = set()\r\n    for lst in lists:\r\n        for num in lst:\r\n            if all(num in lst2 for lst2 in lists):\r\n                common.add(num)\r\n    return common"}
{"task_id": "Mbpp/113", "completion": "def check_integer(s: str) -> bool:\r\n    try:\r\n        int(s)\r\n        return True\r\n    except ValueError:\r\n        return False"}
{"task_id": "Mbpp/115", "completion": "def empty_dicts(lst):\r\n    for d in lst:\r\n        if d:\r\n            return False\r\n    return True"}
{"task_id": "Mbpp/116", "completion": "def tuple_to_int(tup):\r\n    \"\"\"\r\n    Convert a tuple of positive integers into a single integer.\r\n    \"\"\"\r\n    result = 0\r\n    for digit in tup:\r\n        result = result * 10 + digit\r\n    return result"}
{"task_id": "Mbpp/117", "completion": "def list_to_float(lst):\r\n    \"\"\"\r\n    Converts all possible convertible elements in a list of lists to floats.\r\n    \"\"\"\r\n    result = []\r\n    for sublist in lst:\r\n        subresult = []\r\n        for item in sublist:\r\n            try:\r\n                subresult.append(float(item))\r\n            except ValueError:\r\n                subresult.append(item)\r\n        result.append(tuple(subresult))\r\n    return result"}
{"task_id": "Mbpp/118", "completion": "def string_to_list(string):\r\n    return string.split()"}
{"task_id": "Mbpp/119", "completion": "def search(arr):\r\n    \"\"\"\r\n    Given a sorted array, find the element that appears only once.\r\n    \"\"\"\r\n    # Initialize variables\r\n    i = 0\r\n    j = 1\r\n    \r\n    # Loop through the array until the end\r\n    while j < len(arr):\r\n        # If the current element is the same as the next element, increment j\r\n        if arr[i] == arr[j]:\r\n            j += 1\r\n        # If the current element is different from the next element, increment i\r\n        else:\r\n            i += 1\r\n            # If the next element is different from the next element, swap them\r\n            if j < len(arr) - 1 and arr[i] != arr[j+1]:\r\n                arr[i], arr[j] = arr[j], arr[i]\r\n            # If the next element is the same as the next element, increment j\r\n            else:\r\n                j += 1\r\n    \r\n    # Return the element that appears only once\r\n    return arr[i]"}
{"task_id": "Mbpp/11", "completion": "def remove_Occ(string, char):\r\n    first = string.find(char)\r\n    last = string.rfind(char)\r\n    if first == -1 or last == -1:\r\n        return string\r\n    elif first == last:\r\n        return string[:first] + string[first+1:]\r\n    else:\r\n        return string[:first] + string[first+1:last] + string[last+1:]"}
{"task_id": "Mbpp/120", "completion": "def max_product_tuple(lst):\r\n    max_product = 0\r\n    for i in range(len(lst)):\r\n        for j in range(i+1, len(lst)):\r\n            product = lst[i][0] * lst[j][0]\r\n            if abs(product) > abs(max_product):\r\n                max_product = product\r\n    return abs(max_product)"}
{"task_id": "Mbpp/123", "completion": "def amicable_numbers_sum(n):\r\n    def is_amicable(num):\r\n        sum_of_divisors = sum(d for d in range(1, num) if num % d == 0)\r\n        return sum_of_divisors\r\n\r\n    def is_amicable_pair(num1, num2):\r\n        return is_amicable(num1) == num2 and is_amicable(num2) == num1\r\n\r\n    total = 0\r\n    for num in range(1, n+1):\r\n        if is_amicable_pair(num, is_amicable(num)):\r\n            total += num\r\n    return total"}
{"task_id": "Mbpp/124", "completion": "import math\r\n\r\ndef angle_complex(z):\r\n    \"\"\"\r\n    Returns the angle of a complex number in radians.\r\n    \"\"\"\r\n    return math.atan2(z.imag, z.real)"}
{"task_id": "Mbpp/125", "completion": "def find_length(binary_string):\r\n    max_diff = 0\r\n    count_0 = 0\r\n    count_1 = 0\r\n    for i in binary_string:\r\n        if i == '0':\r\n            count_0 += 1\r\n        else:\r\n            count_1 += 1\r\n        if count_0 > 0 and count_1 > 0:\r\n            max_diff = max(max_diff, count_0 + count_1)\r\n    return max_diff"}
{"task_id": "Mbpp/126", "completion": "def sum_common_divisors(num1, num2):\r\n    divisors = []\r\n    for i in range(1, min(num1, num2) + 1):\r\n        if num1 % i == 0 and num2 % i == 0:\r\n            divisors.append(i)\r\n    return sum(divisors)"}
{"task_id": "Mbpp/127", "completion": "def multiply_int(a, b):\r\n    return a * b"}
{"task_id": "Mbpp/128", "completion": "def long_words(n, sentence):\r\n    words = sentence.split()\r\n    long_words = []\r\n    for word in words:\r\n        if len(word) > n:\r\n            long_words.append(word)\r\n    return long_words"}
{"task_id": "Mbpp/129", "completion": "def magic_square_test(matrix):\r\n    n = len(matrix)\r\n    magic_sum = sum(range(1, n*n+1))\r\n    \r\n    # Check if all rows and columns have the same sum\r\n    for i in range(n):\r\n        row_sum = sum(matrix[i])\r\n        col_sum = sum(matrix[j][i] for j in range(n))\r\n        if row_sum != magic_sum or col_sum != magic_sum:\r\n            return False\r\n    \r\n    # Check if the diagonal elements have the same sum\r\n    diag1_sum = sum(matrix[i][i] for i in range(n))\r\n    diag2_sum = sum(matrix[i][n-i-1] for i in range(n))\r\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\r\n        return False\r\n    \r\n    # Check if the matrix is a square\r\n    if n*n != len(set(matrix[0])):\r\n        return False\r\n    \r\n    return True"}
{"task_id": "Mbpp/130", "completion": "def max_occurrences(lst):\r\n    from collections import Counter\r\n    c = Counter(lst)\r\n    return max(c, key=c.get)"}
{"task_id": "Mbpp/131", "completion": "def reverse_vowels(s):\r\n    vowels = \"aeiouAEIOU\"\r\n    vowels_list = []\r\n    non_vowels_list = []\r\n    for char in s:\r\n        if char in vowels:\r\n            vowels_list.append(char)\r\n        else:\r\n            non_vowels_list.append(char)\r\n    reversed_vowels = vowels_list[::-1]\r\n    reversed_vowels_str = \"\".join(reversed_vowels)\r\n    return \"\".join(non_vowels_list) + reversed_vowels_str"}
{"task_id": "Mbpp/12", "completion": "def sort_matrix(matrix):\r\n    # Calculate the sum of each row and store it in a list\r\n    row_sums = [sum(row) for row in matrix]\r\n    \r\n    # Sort the rows based on their sum\r\n    sorted_rows = sorted(matrix, key=lambda row: sum(row))\r\n    \r\n    # Return the sorted matrix\r\n    return sorted_rows"}
{"task_id": "Mbpp/132", "completion": "def tup_string(tup):\r\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "completion": "def sum_negativenum(lst):\r\n    \"\"\"\r\n    This function takes a list of numbers as input and returns the sum of all negative numbers in the list.\r\n    \"\"\"\r\n    # Initialize a variable to store the sum of negative numbers\r\n    neg_sum = 0\r\n    \r\n    # Loop through each number in the list\r\n    for num in lst:\r\n        # If the number is negative, add it to the neg_sum variable\r\n        if num < 0:\r\n            neg_sum += num\r\n    \r\n    # Return the sum of negative numbers\r\n    return neg_sum"}
{"task_id": "Mbpp/135", "completion": "def hexagonal_num(n):\r\n    return n * (2*n - 1)"}
{"task_id": "Mbpp/137", "completion": "import math\r\n\r\ndef zero_count(arr):\r\n    zero_count = 0\r\n    non_zero_count = 0\r\n    for num in arr:\r\n        if num == 0:\r\n            zero_count += 1\r\n        else:\r\n            non_zero_count += 1\r\n    return zero_count / non_zero_count\r\n\r\nassert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)"}
{"task_id": "Mbpp/138", "completion": "def is_Sum_Of_Powers_Of_Two(n):\r\n    \"\"\"\r\n    This function takes an integer n as input and returns True if it can be represented as sum of non-zero powers of 2, else False.\r\n    \"\"\"\r\n    # Initialize a variable to store the sum of powers of 2\r\n    sum_powers_of_2 = 0\r\n    \r\n    # Initialize a variable to store the power of 2\r\n    power = 1\r\n    \r\n    # Loop through all powers of 2 from 1 to n\r\n    while power <= n:\r\n        # If the current power of 2 is a factor of n, add it to the sum_powers_of_2\r\n        if n % power == 0:\r\n            sum_powers_of_2 += power\r\n            # Divide n by the current power of 2 to get the remaining value\r\n            n //= power\r\n        else:\r\n            # Increment the power of 2 by 1\r\n            power *= 2\r\n    \r\n    # If the sum_powers_of_2 is equal to n, then it can be represented as sum of non-zero powers of 2\r\n    if sum_powers_of_2 == n:\r\n        return True\r\n    else:\r\n        return False"}
{"task_id": "Mbpp/139", "completion": "import math\r\n\r\ndef circle_circumference(radius):\r\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/140", "completion": "def extract_singly(lst):\r\n    flat_list = []\r\n    for sublist in lst:\r\n        for item in sublist:\r\n            flat_list.append(item)\r\n    return set(flat_list)"}
{"task_id": "Mbpp/141", "completion": "def pancake_sort(lst):\r\n    n = len(lst)\r\n    for i in range(n-1, 0, -1):\r\n        max_index = i\r\n        for j in range(0, i):\r\n            if lst[j] > lst[max_index]:\r\n                max_index = j\r\n        if max_index != i:\r\n            lst[max_index], lst[i] = lst[i], lst[max_index]\r\n            lst[0:max_index+1] = lst[max_index::-1]\r\n            lst[0:i+1] = lst[i::-1]\r\n    return lst"}
{"task_id": "Mbpp/142", "completion": "def count_samepair(list1, list2, list3):\r\n    count = 0\r\n    for i in range(len(list1)):\r\n        if list1[i] == list2[i] == list3[i]:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/143", "completion": "def find_lists(tup):\r\n    count = 0\r\n    for item in tup:\r\n        if isinstance(item, list):\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/14", "completion": "def find_Volume(base, height, thickness):\r\n    return base * height * thickness"}
{"task_id": "Mbpp/145", "completion": "def max_Abs_Diff(arr):\r\n    return max(abs(arr[i] - arr[j]) for i in range(len(arr)) for j in range(len(arr)) if i != j)"}
{"task_id": "Mbpp/160", "completion": "def find_solution(a, b, n):\r\n    if n % a == 0:\r\n        return (n // a, 0)\r\n    elif b == 0:\r\n        return None\r\n    else:\r\n        q = n // b\r\n        r = n % b\r\n        if r == 0:\r\n            return (q, 0)\r\n        else:\r\n            x, y = find_solution(b, a, r)\r\n            if x is None:\r\n                return None\r\n            else:\r\n                return (x, y - q)"}
{"task_id": "Mbpp/161", "completion": "def remove_elements(list1, list2):\r\n    return [x for x in list1 if x not in list2]"}
{"task_id": "Mbpp/162", "completion": "def sum_series(n):\r\n    sum = 0\r\n    for i in range(n//2+1):\r\n        sum += n - 2*i\r\n    return sum"}
{"task_id": "Mbpp/164", "completion": "def are_equivalent(a, b):\r\n    \"\"\"\r\n    Returns True if the sum of divisors of a and b are equal, False otherwise.\r\n    \"\"\"\r\n    divisors_a = set()\r\n    divisors_b = set()\r\n    \r\n    # Find divisors of a\r\n    for i in range(1, a+1):\r\n        if a % i == 0:\r\n            divisors_a.add(i)\r\n    \r\n    # Find divisors of b\r\n    for i in range(1, b+1):\r\n        if b % i == 0:\r\n            divisors_b.add(i)\r\n    \r\n    # Check if the sum of divisors of a and b are equal\r\n    return sum(divisors_a) == sum(divisors_b)"}
{"task_id": "Mbpp/165", "completion": "def count_char_position(string):\r\n    count = 0\r\n    for i in range(len(string)):\r\n        if string[i].lower() == chr(i+97):\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/166", "completion": "def find_even_pair(lst):\r\n    count = 0\r\n    for i in range(len(lst)):\r\n        for j in range(i+1, len(lst)):\r\n            if (lst[i] ^ lst[j]) % 2 == 0:\r\n                count += 1\r\n    return count"}
{"task_id": "Mbpp/167", "completion": "def next_power_of_2(n):\r\n    \"\"\"\r\n    Returns the smallest power of 2 greater than or equal to n.\r\n    \"\"\"\r\n    return 1 if n == 0 else 2**(n-1).bit_length()"}
{"task_id": "Mbpp/168", "completion": "def frequency(lst, num):\r\n    count = 0\r\n    for i in lst:\r\n        if i == num:\r\n            count += 1\r\n    return count"}
{"task_id": "Mbpp/170", "completion": "def sum_range_list(lst, start, end):\r\n    \"\"\"\r\n    This function takes a list of numbers and two indices as input and returns the sum of numbers in the range between the two indices.\r\n    \"\"\"\r\n    # Initialize the sum variable to 0\r\n    total = 0\r\n    # Loop through the list from the start index to the end index\r\n    for i in range(start, end+1):\r\n        # Add the current element to the total\r\n        total += lst[i]\r\n    # Return the total sum\r\n    return total"}
