{"task_id": "HumanEval/6", "completion": "\n    ```python\n    def parse_nested_parens(paren_string: str) -> List[int]:\n        \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        For each of the group, output the deepest level of nesting of parentheses.\n        E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n        >>> parse_nested_parens('(()()) ((())) () ((())()())')\n        [2, 3, 1, 3]\n        \"\"\"\n        paren_string = paren_string.replace(' ', '')\n        paren_stack = []\n        max_depth = 0\n        depth_list = []\n        for paren in paren_string:\n            if paren == '(':\n                paren_stack.append(paren)\n                depth_list.append(len(paren_stack))\n            elif paren == ')':\n                paren_stack.pop()\n                depth_list.append(len(paren_stack))\n        return depth_list\n    ```\n\n    ### Explanation:\n    ```\n    def parse_nested_parens(paren_string: str) -> List[int]:\n        \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        For each of the group, output the deepest level of nesting of parentheses.\n        E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n        >>> parse_nested_parens('(()()) ((())) () ((())()())')\n        [2, 3, 1, 3]\n        \"\"\"\n        paren_string = paren_string.replace(' ', '')\n        paren_stack = []\n        max_depth = 0\n        depth_list = []\n        for paren in paren_string:\n            if paren == '(':\n                paren_stack.append(paren)\n                depth_list.append(len(paren_stack))\n            elif paren == ')':\n                paren_stack.pop()\n                depth_list.append(len(paren_stack))\n        return depth_list\n    ```\n    The function takes in a string of parentheses and returns a list of integers representing the deepest level of nesting of parentheses.\n\n    The first step is to remove all spaces from the string.\n\n    Next, we create a list to store the deepest level of nesting of parentheses.\n\n    We create a stack to store the parentheses.\n\n    We iterate through the string and append '(' to the stack if the character is '(' and pop the last element from the stack if the character is ')'.\n\n    We append the length of the stack to the list if the character is '(' and append the length of the stack minus one to the list if the character is ')'.\n\n    We return the list.\n\n    ### Example:\n    ```\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    ```\n    \"\"\"\n", "all_code": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n\n    ### Instruction:\n    Create a Python script for this problem:\n    Write a solution to the following problem:\n```python\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n```\n\n    ### Response:\n    ```python\n    def parse_nested_parens(paren_string: str) -> List[int]:\n        \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        For each of the group, output the deepest level of nesting of parentheses.\n        E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n        >>> parse_nested_parens('(()()) ((())) () ((())()())')\n        [2, 3, 1, 3]\n        \"\"\"\n        paren_string = paren_string.replace(' ', '')\n        paren_stack = []\n        max_depth = 0\n        depth_list = []\n        for paren in paren_string:\n            if paren == '(':\n                paren_stack.append(paren)\n                depth_list.append(len(paren_stack))\n            elif paren == ')':\n                paren_stack.pop()\n                depth_list.append(len(paren_stack))\n        return depth_list\n    ```\n\n    ### Explanation:\n    ```\n    def parse_nested_parens(paren_string: str) -> List[int]:\n        \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        For each of the group, output the deepest level of nesting of parentheses.\n        E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n        >>> parse_nested_parens('(()()) ((())) () ((())()())')\n        [2, 3, 1, 3]\n        \"\"\"\n        paren_string = paren_string.replace(' ', '')\n        paren_stack = []\n        max_depth = 0\n        depth_list = []\n        for paren in paren_string:\n            if paren == '(':\n                paren_stack.append(paren)\n                depth_list.append(len(paren_stack))\n            elif paren == ')':\n                paren_stack.pop()\n                depth_list.append(len(paren_stack))\n        return depth_list\n    ```\n    The function takes in a string of parentheses and returns a list of integers representing the deepest level of nesting of parentheses.\n\n    The first step is to remove all spaces from the string.\n\n    Next, we create a list to store the deepest level of nesting of parentheses.\n\n    We create a stack to store the parentheses.\n\n    We iterate through the string and append '(' to the stack if the character is '(' and pop the last element from the stack if the character is ')'.\n\n    We append the length of the stack to the list if the character is '(' and append the length of the stack minus one to the list if the character is ')'.\n\n    We return the list.\n\n    ### Example:\n    ```\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    ```\n    \"\"\"\n"}
