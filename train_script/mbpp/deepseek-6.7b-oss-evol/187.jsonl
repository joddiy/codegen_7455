{"task_id": "Mbpp/407", "completion": "\n```python\ndef rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    \n    # Find the pivot position\n    pivot = -1\n    for i in range(len(digits)-1, 0, -1):\n        if digits[i] > digits[i-1]:\n            pivot = i-1\n            break\n    \n    # If no pivot is found, the number is already the biggest possible\n    if pivot == -1:\n        return n\n    \n    # Find the smallest digit on the right of the pivot that is greater than the pivot\n    for i in range(len(digits)-1, pivot, -1):\n        if digits[i] > digits[pivot]:\n            digits[i], digits[pivot] = digits[pivot], digits[i]\n            break\n    \n    # Reverse the digits from the pivot+1 to the end\n    digits[pivot+1:] = digits[:pivot:-1]\n    \n    # Convert the list of digits back to a number and return\n    return int(''.join(map(str, digits)))\n\nassert rearrange_bigger(12)==21\n```\n\nThis script works by first converting the number into a list of digits. It then finds the pivot position, which is the position where the digits are in ascending order. If no pivot is found, the number is already the biggest possible, so it returns the original number. If a pivot is found, it finds the smallest digit on the right of the pivot that is greater than the pivot, and swaps them. It then reverses the digits from the pivot+1 to the end, effectively creating the next bigger number. Finally, it converts the list of digits back to a number and returns it.", "all_code": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n\n    ### Instruction:\n    Create a Python script for this problem:\n    Write a function to create the next bigger number by rearranging the digits of a given number. Your code should satisfy the following assertion:\n```python\nassert rearrange_bigger(12)==21\n```\n\n    ### Response:\n```python\ndef rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    \n    # Find the pivot position\n    pivot = -1\n    for i in range(len(digits)-1, 0, -1):\n        if digits[i] > digits[i-1]:\n            pivot = i-1\n            break\n    \n    # If no pivot is found, the number is already the biggest possible\n    if pivot == -1:\n        return n\n    \n    # Find the smallest digit on the right of the pivot that is greater than the pivot\n    for i in range(len(digits)-1, pivot, -1):\n        if digits[i] > digits[pivot]:\n            digits[i], digits[pivot] = digits[pivot], digits[i]\n            break\n    \n    # Reverse the digits from the pivot+1 to the end\n    digits[pivot+1:] = digits[:pivot:-1]\n    \n    # Convert the list of digits back to a number and return\n    return int(''.join(map(str, digits)))\n\nassert rearrange_bigger(12)==21\n```\n\nThis script works by first converting the number into a list of digits. It then finds the pivot position, which is the position where the digits are in ascending order. If no pivot is found, the number is already the biggest possible, so it returns the original number. If a pivot is found, it finds the smallest digit on the right of the pivot that is greater than the pivot, and swaps them. It then reverses the digits from the pivot+1 to the end, effectively creating the next bigger number. Finally, it converts the list of digits back to a number and returns it."}
