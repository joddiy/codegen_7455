{"task_id": "Mbpp/721", "completion": "\n    Here is a Python solution using dynamic programming. The idea is to build a 2D array dp where dp[i][j] is the maximum average of a path ending at cell (i, j). We initialize dp[0][0] to be the cost of the top-left cell and then for each cell (i, j), we update dp[i][j] to be the maximum of dp[i-1][j] and dp[i][j-1] plus the cost of cell (i, j). Finally, we return the maximum average of a path which is dp[N-1][N-1] divided by the number of cells in the path.\n\n```python\ndef maxAverageOfPath(matrix):\n    N = len(matrix)\n    dp = [[0]*N for _ in range(N)]\n    dp[0][0] = matrix[0][0]\n\n    # Initialize the first row\n    for i in range(1, N):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Initialize the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill in the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    max_average = dp[N-1][N-1] / (N*N)\n\n    return max_average\n\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n```\n\nThis solution has a time complexity of O(N^2) and a space complexity of O(N^2), where N is the size of the matrix.", "all_code": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n\n    ### Instruction:\n    Create a Python script for this problem:\n    Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path. Your code should satisfy the following assertion:\n```python\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n```\n\n    ### Response:\n    Here is a Python solution using dynamic programming. The idea is to build a 2D array dp where dp[i][j] is the maximum average of a path ending at cell (i, j). We initialize dp[0][0] to be the cost of the top-left cell and then for each cell (i, j), we update dp[i][j] to be the maximum of dp[i-1][j] and dp[i][j-1] plus the cost of cell (i, j). Finally, we return the maximum average of a path which is dp[N-1][N-1] divided by the number of cells in the path.\n\n```python\ndef maxAverageOfPath(matrix):\n    N = len(matrix)\n    dp = [[0]*N for _ in range(N)]\n    dp[0][0] = matrix[0][0]\n\n    # Initialize the first row\n    for i in range(1, N):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Initialize the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill in the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    max_average = dp[N-1][N-1] / (N*N)\n\n    return max_average\n\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n```\n\nThis solution has a time complexity of O(N^2) and a space complexity of O(N^2), where N is the size of the matrix."}
