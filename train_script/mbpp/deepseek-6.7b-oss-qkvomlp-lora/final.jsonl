{"task_id": "Mbpp/2", "completion": "def similar_elements(list1, list2):\n    return set(list1).intersection(set(list2))"}
{"task_id": "Mbpp/3", "completion": "\n    def is_not_prime(num):\n        if num <= 1:\n            return True\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return True\n        return False\n    ```\n    The `is_not_prime` function takes a number as input and returns `True` if the number is not a prime number, and `False` otherwise. It uses a simple algorithm to check if the number is divisible by any number other than 1 and itself. If the number is divisible by any number other than 1 and itself, it returns `True`, indicating that the number is not a prime number. Otherwise, it returns `False`, indicating that the number is a prime number."}
{"task_id": "Mbpp/16", "completion": "\n    def text_lowercase_underscore(input_string):\n        return all(char.islower() or char == '_' for char in input_string)\n    ```\n    The `text_lowercase_underscore` function takes an input string and uses the `all` function to check if all characters in the string are either lowercase letters or underscores. If all characters satisfy this condition, the function returns True; otherwise, it returns False."}
{"task_id": "Mbpp/171", "completion": "\n    def perimeter_pentagon(side_length):\n        return 5 * side_length\n    ```\n    The `perimeter_pentagon` function takes the length of the side of a regular pentagon as input and returns the perimeter of the pentagon. The perimeter of a regular pentagon is 5 times the length of its side."}
{"task_id": "Mbpp/172", "completion": "def count_occurance(input_string):\n    count = 0\n    index = 0\n    while index < len(input_string):\n        if input_string[index:index+3] == 'std':\n            count += 1\n            index += 3\n        else:\n            index += 1\n    return count"}
{"task_id": "Mbpp/222", "completion": "\n    def check_type(tup):\n        data_type = type(tup[0])\n        for item in tup:\n            if type(item) != data_type:\n                return False\n        return True\n    ```\n    The `check_type` function takes a tuple as input and checks if all the elements have the same data type. It initializes the data type with the type of the first element in the tuple. Then, it iterates through the tuple, checking if the type of each element is the same as the initial data type. If any element has a different data type, the function returns False. If all elements have the same data type, the function returns True."}
{"task_id": "Mbpp/223", "completion": "def is_majority(arr, n, x):\n    # Find the index of the first occurrence of x in the sorted array\n    low = binary_search(arr, 0, n-1, x)\n\n    # If x is not present in the array, return False\n    if low == -1:\n        return False\n\n    # If x is present in the array, check if it is the majority element\n    if (low + n//2 < n) and arr[low + n//2] == x:\n        return True\n    else:\n        return False\n\ndef binary_search(arr, low, high, x):\n    if high >= low:\n        mid = (high + low) // 2\n        if (mid == 0 or x > arr[mid - 1]) and arr[mid] == x:\n            return mid\n        elif x > arr[mid]:\n            return binary_search(arr, (mid + 1), high, x)\n        else:\n            return binary_search(arr, low, (mid - 1), x)\n    return -1"}
{"task_id": "Mbpp/224", "completion": "\n    def count_Set_Bits(num):\n        count = 0\n        while num:\n            num &= num - 1\n            count += 1\n        return count\n    ```\n    The `count_Set_Bits` function uses a bitwise AND operation to count the number of set bits in the given number. It iteratively clears the least significant set bit and increments the count until the number becomes 0. The final count is returned as the result."}
{"task_id": "Mbpp/226", "completion": "def odd_values_string(input_string):\n    return input_string[::2]"}
{"task_id": "Mbpp/227", "completion": "\n    def min_of_three(a, b, c):\n        return min(a, b, c)\n    ```\n    The `min_of_three` function takes three numbers as input and returns the minimum of the three numbers using the `min` function. This solution satisfies the given assertion."}
{"task_id": "Mbpp/229", "completion": "def re_arrange_array(arr, n):\n    j = 0\n    for i in range(n):\n        if arr[i] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            j += 1\n    return arr"}
{"task_id": "Mbpp/230", "completion": "def replace_blank(string, character):\n    return string.replace(\" \", character)"}
{"task_id": "Mbpp/232", "completion": "def larg_nnum(lst, n):\n    lst.sort(reverse=True)\n    return lst[:n]"}
{"task_id": "Mbpp/17", "completion": "def square_perimeter(side_length):\n    return 4 * side_length"}
{"task_id": "Mbpp/233", "completion": "import math\n\ndef lateral_surface_cylinder(radius, height):\n    lateral_area = 2 * math.pi * radius * height\n    return lateral_area\n\n# Test the function\nassert math.isclose(lateral_surface_cylinder(10, 5), 314.15000000000003, rel_tol=0.001)"}
{"task_id": "Mbpp/234", "completion": "def volume_cube(side_length):\n    return side_length ** 3"}
{"task_id": "Mbpp/235", "completion": "\n    def even_bit_set_number(n):\n        return n | 0b10101010101010101010101010101010\n    ```\n    The `even_bit_set_number` function takes an integer `n` as input and returns the number with all even bits set. It does this by using the bitwise OR operation with the binary number `0b10101010101010101010101010101010`, which has all even bits set. This ensures that all even bits of the input number are set to 1."}
{"task_id": "Mbpp/237", "completion": "def check_occurences(tuples_list):\n    occurences = {}\n    for tup in tuples_list:\n        if tup in occurences:\n            occurences[tup] += 1\n        else:\n            occurences[tup] = 1\n    return occurences"}
{"task_id": "Mbpp/238", "completion": "\n    def number_of_substrings(s):\n        count = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                if s[i:j]:\n                    count += 1\n        return count\n    ```\n    The `number_of_substrings` function iterates through all possible substrings of the input string `s` and counts the non-empty ones. It returns the total count of non-empty substrings."}
{"task_id": "Mbpp/239", "completion": "\ndef get_total_number_of_sequences(m, n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 4\n    if n == 5:\n        return 8\n    if n == 6:\n        return 16\n    if n == 7:\n        return 32\n    if n == 8:\n        return 64\n    if n == 9:\n        return 128\n    if n == 10:\n        return 256\n    if n == 11:\n        return 512\n    if n == 12:\n        return 1024\n    if n == 13:\n        return 2048\n    if n == 14:\n        return 4096\n    if n == 15:\n        return 8192\n    if n == 16:\n        return 16384\n    if n == 17:\n        return 32768\n    if n == 18:\n        return 65536\n    if n == 19:\n        return 131072\n    if n == 20:\n        return 262144\n    if n == 21:\n        return 524288\n    if n == 22:\n        return 1048576\n    if n == 23:\n        return 2097152\n    if n == 24:\n        return 4194304\n    if n == 25:\n        return 8388608\n    if n == 26:\n        return 16777216\n    if n == 27:\n        return 33554432\n    if n == 28:\n        return 67108864\n    if n == 29:\n        return 134217728\n    if n == 30:\n        return 268435456\n    if n == 31:\n        return 536870912\n    if n == 32:\n        return 1073741824\n    if n == 33:\n        return 2147483648\n    if n == 34:\n        return 4294967296\n    if n == 35:\n        return 8589934592\n    if n == 36:\n        return 17179869184\n    if n == 37:\n        return 34359738368\n    if n == 38:\n        return 68719476736\n    if n == 39:\n        return 137438953472\n    if n == 40:\n        return 274877906944\n    if n == 41:\n        return 549755813888\n    if n == 42:\n        return 1099511627776\n    if n == 43:\n        return 2199023255552\n    if n == 44:\n        return 4398046511104\n    if n == 45:\n        return 8796093022208\n    if n == 46:\n        return 1759218604"}
{"task_id": "Mbpp/240", "completion": "def replace_list(list1, list2):\n    list1[-1] = list2\n    return list1"}
{"task_id": "Mbpp/242", "completion": "def count_charac(string):\n    return len(string)\n\n# Test the function\nassert count_charac(\"python programming\")==18"}
{"task_id": "Mbpp/244", "completion": "\n    import math\n\n    def next_Perfect_Square(num):\n        next_square = math.ceil(math.sqrt(num)) ** 2\n        return next_square\n\n    # Test the function\n    assert next_Perfect_Square(35) == 36\n    ```\n\n    The `next_Perfect_Square` function takes a number as input and returns the next perfect square greater than the given number. It uses the `math.ceil` function to round up the square root of the input number and then squares the result to find the next perfect square. The assertion at the end of the script tests the function with the given example."}
{"task_id": "Mbpp/245", "completion": "def max_sum(arr):\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n\n    inc[0] = arr[0]\n    for i in range(1, n):\n        inc[i] = max(inc[i-1], arr[i])\n\n    dec[n-1] = arr[n-1]\n    for i in range(n-2, -1, -1):\n        dec[i] = max(dec[i+1], arr[i])\n\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n\n    return max_sum"}
{"task_id": "Mbpp/18", "completion": "def remove_dirty_chars(first_string, second_string):\n    clean_string = \"\"\n    for char in first_string:\n        if char not in second_string:\n            clean_string += char\n    return clean_string"}
{"task_id": "Mbpp/247", "completion": "\n    def lps(s):\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-1, -1, -1):\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i+1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        return dp[0][n-1]\n    ```\n    The `lps` function uses dynamic programming to find the length of the longest palindromic subsequence in the given string. It initializes a 2D array `dp` to store the lengths of palindromic subsequences, and then fills it up using nested loops. Finally, it returns the length of the longest palindromic subsequence in the given string."}
{"task_id": "Mbpp/249", "completion": "def intersection_array(arr1, arr2):\n    set1 = set(arr1)\n    set2 = set(arr2)\n    return list(set1.intersection(set2))"}
{"task_id": "Mbpp/250", "completion": "def count_X(tuple, element):\n    return tuple.count(element)"}
{"task_id": "Mbpp/251", "completion": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result"}
{"task_id": "Mbpp/252", "completion": "\n    import cmath\n\n    def convert(complex_number):\n        polar_coordinates = cmath.polar(complex_number)\n        return polar_coordinates\n    ```\n\n    The `convert` function takes a complex number as input and uses the `cmath.polar` function to convert it to polar coordinates. The function returns the polar coordinates as a tuple of the magnitude and the phase. The assertion provided in the problem description is satisfied by the provided solution."}
{"task_id": "Mbpp/253", "completion": "def count_integer(lst):\n    return sum(1 for x in lst if isinstance(x, int))"}
{"task_id": "Mbpp/255", "completion": "def combinations_colors(colors, n):\n    if n == 0:\n        return [()]\n    else:\n        result = []\n        for i in range(len(colors)):\n            sub_combinations = combinations_colors(colors, n-1)\n            for combination in sub_combinations:\n                result.append((colors[i],) + combination)\n        return result"}
{"task_id": "Mbpp/256", "completion": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n+1, i):\n                primes[j] = False\n    return sum(primes)"}
{"task_id": "Mbpp/257", "completion": "def swap_numbers(num1, num2):\n    return (num2, num1)\n\n# Test the function\nassert swap_numbers(10,20)==(20,10)"}
{"task_id": "Mbpp/259", "completion": "def maximize_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        max_element = max(tuple1[i][0], tuple2[i][0])\n        result.append((max_element, max(tuple1[i][1], tuple2[i][1])))\n    return tuple(result)"}
{"task_id": "Mbpp/19", "completion": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))"}
{"task_id": "Mbpp/260", "completion": "\n    def newman_prime(n):\n        primes = [2, 3]\n        if n <= 2:\n            return primes[n-1]\n        for i in range(3, n+1):\n            is_prime = True\n            for j in range(2, int(i**0.5)+1):\n                if i % j == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                primes.append(i)\n        return primes[n-1]\n\n    # Test the function\n    assert newman_prime(3) == 7\n    ```"}
{"task_id": "Mbpp/261", "completion": "def division_elements(tuple1, tuple2):\n    result = tuple(a // b for a, b in zip(tuple1, tuple2))\n    return result"}
{"task_id": "Mbpp/262", "completion": "def split_two_parts(lst, L):\n    first_part = lst[:L]\n    second_part = lst[L:]\n    return first_part, second_part"}
{"task_id": "Mbpp/264", "completion": "def dog_age(human_age):\n    if human_age <= 2:\n        return human_age * 10.5\n    else:\n        return 21 + (human_age - 2) * 4"}
{"task_id": "Mbpp/265", "completion": "def list_split(lst, n):\n    result = []\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n    return result"}
{"task_id": "Mbpp/266", "completion": "\n    def lateralsurface_cube(side_length):\n        return 4 * side_length * side_length\n    ```\n    The `lateralsurface_cube` function takes the side length of a cube as input and returns the lateral surface area of the cube. The lateral surface area of a cube is calculated as 4 times the square of the side length."}
{"task_id": "Mbpp/267", "completion": "def square_Sum(n):\n    sum = 0\n    for i in range(1, 2*n, 2):\n        sum += i**2\n    return sum"}
{"task_id": "Mbpp/268", "completion": "\n    def find_star_num(n):\n        return (n * (n + 1)) // 2\n    ```\n    The `find_star_num` function takes an integer `n` as input and returns the n'th star number. The formula for finding the n'th star number is `(n * (n + 1)) // 2`, which is equivalent to `n * (n + 1) / 2`."}
{"task_id": "Mbpp/269", "completion": "def ascii_value(char):\n    return ord(char)"}
{"task_id": "Mbpp/270", "completion": "def sum_even_and_even_index(lst):\n    return sum(lst[1::2])"}
{"task_id": "Mbpp/20", "completion": "\n    def is_woodall(num):\n        # Check if the number is divisible by 2\n        if num % 2 == 0:\n            return False\n        \n        # Check if the number is divisible by 3\n        if num % 3 == 0:\n            return False\n        \n        # Check if the number is divisible by 5\n        if num % 5 == 0:\n            return False\n        \n        # Check if the number is divisible by 7\n        if num % 7 == 0:\n            return False\n        \n        # Check if the number is divisible by 11\n        if num % 11 == 0:\n            return False\n        \n        # Check if the number is divisible by 13\n        if num % 13 == 0:\n            return False\n        \n        # Check if the number is divisible by 17\n        if num % 17 == 0:\n            return False\n        \n        # Check if the number is divisible by 19\n        if num % 19 == 0:\n            return False\n        \n        # Check if the number is divisible by 23\n        if num % 23 == 0:\n            return False\n        \n        # Check if the number is divisible by 29\n        if num % 29 == 0:\n            return False\n        \n        # Check if the number is divisible by 31\n        if num % 31 == 0:\n            return False\n        \n        # Check if the number is divisible by 37\n        if num % 37 == 0:\n            return False\n        \n        # Check if the number is divisible by 41\n        if num % 41 == 0:\n            return False\n        \n        # Check if the number is divisible by 43\n        if num % 43 == 0:\n            return False\n        \n        # Check if the number is divisible by 47\n        if num % 47 == 0:\n            return False\n        \n        # Check if the number is divisible by 53\n        if num % 53 == 0:\n            return False\n        \n        # Check if the number is divisible by 59\n        if num % 59 == 0:\n            return False\n        \n        # Check if the number is divisible by 61\n        if num % 61 == 0:\n            return False\n        \n        # Check if the number is divisible by 67\n        if num % 67 == 0:\n            return False\n        \n        # Check if the number is divisible by 71\n        if num % 71 == 0:\n            return False\n        \n        # Check if the number is divisible by 73\n        if num % 73 == 0:\n            return False\n        \n        # Check if the number is divisible by 79\n        if num % 79 == 0:\n            return False\n        \n        # Check if the number is divisible by 83\n        if num % 83 == 0:\n            return False\n        \n        # Check if the number is divisible by 89\n        if num % 89 == 0:\n            return False\n        \n        # Check if the number is divisible by 97\n        if num % 97 == 0:\n            return False\n        \n        # If the number is not divisible by any of the above numbers, it is a woodall number\n        return True\n    ```"}
{"task_id": "Mbpp/271", "completion": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum"}
{"task_id": "Mbpp/272", "completion": "def rear_extract(tuples_list):\n    return [tup[2] for tup in tuples_list]"}
{"task_id": "Mbpp/273", "completion": "def substract_elements(tuple1, tuple2):\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Tuples must have the same length\")\n    result = tuple(a - b for a, b in zip(tuple1, tuple2))\n    return result"}
{"task_id": "Mbpp/274", "completion": "\n    def even_binomial_Coeff_Sum(n):\n        sum = 0\n        for i in range(n+1):\n            if i % 2 == 0:\n                sum += binomial_coefficient(n, i)\n        return sum\n\n    def binomial_coefficient(n, k):\n        if k == 0 or k == n:\n            return 1\n        else:\n            return binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n    ```\n\n    The `even_binomial_Coeff_Sum` function calculates the sum of even index binomial coefficients using the `binomial_coefficient` function. The `binomial_coefficient` function calculates the binomial coefficient of a given n and k. The assertion in the problem description is satisfied by the provided solution."}
{"task_id": "Mbpp/276", "completion": "\n    import math\n\n    def volume_cylinder(radius, height):\n        return math.pi * radius**2 * height\n\n    assert math.isclose(volume_cylinder(10,5), 1570.7500000000002, rel_tol=0.001)\n    ```\n\n    The `volume_cylinder` function takes the radius and height of a cylinder and returns the volume using the formula `pi * radius^2 * height`. The assertion at the end of the script verifies that the function returns the correct volume for the given radius and height."}
{"task_id": "Mbpp/277", "completion": "def dict_filter(dictionary, n):\n    filtered_dict = {key: value for key, value in dictionary.items() if value >= n}\n    return filtered_dict"}
{"task_id": "Mbpp/278", "completion": "def count_first_elements(tup):\n    count = 0\n    for element in tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count"}
{"task_id": "Mbpp/279", "completion": "def is_num_decagonal(n):\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/280", "completion": "def sequential_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return (True, i)\n    return (False, -1)"}
{"task_id": "Mbpp/281", "completion": "def all_unique(lst):\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/56", "completion": "def check(num):\n    # Reverse the number\n    rev_num = 0\n    temp = num\n    while temp > 0:\n        rev_num = rev_num * 10 + temp % 10\n        temp //= 10\n\n    # Check if the number is one less than twice its reverse\n    return num == (rev_num * 2) - 1\n\n# Test the function\nassert check(70) == False"}
{"task_id": "Mbpp/282", "completion": "def sub_list(list1, list2):\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must have the same length\")\n    result = [list1[i] - list2[i] for i in range(len(list1))]\n    return result"}
{"task_id": "Mbpp/283", "completion": "def validate(num):\n    num_str = str(num)\n    for digit in num_str:\n        if num_str.count(digit) > int(digit):\n            return False\n    return True"}
{"task_id": "Mbpp/284", "completion": "def check_element(lst, element):\n    return all(item == element for item in lst)"}
{"task_id": "Mbpp/285", "completion": "import re\n\ndef text_match_two_three(text):\n    pattern = r'a(b{2,3})'\n    return bool(re.search(pattern, text))\n\n# Test cases\nassert text_match_two_three(\"ac\")==(False)\nassert text_match_two_three(\"abc\")==(True)\nassert text_match_two_three(\"abbb\")==(True)\nassert text_match_two_three(\"abbbb\")==(True)\nassert text_match_two_three(\"abbbbb\")==(False)"}
{"task_id": "Mbpp/286", "completion": "def max_sub_array_sum_repeated(arr, k, n):\n    max_sum = float('-inf')\n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, i + n * k):\n            curr_sum += arr[j % n]\n            max_sum = max(max_sum, curr_sum)\n    return max_sum"}
{"task_id": "Mbpp/287", "completion": "\n    def square_Sum(n):\n        return sum(i**2 for i in range(2, 2*n+1, 2))\n    ```\n    The `square_Sum` function takes an integer `n` as input and returns the sum of squares of the first `n` even natural numbers. It uses a generator expression to calculate the squares of the even numbers and then uses the `sum` function to calculate the total sum."}
{"task_id": "Mbpp/290", "completion": "def max_length(lst):\n    max_len = max(len(sublist) for sublist in lst)\n    max_sublist = [sublist for sublist in lst if len(sublist) == max_len][0]\n    return max_len, max_sublist"}
{"task_id": "Mbpp/292", "completion": "\n    def find(a, b):\n        return a // b\n    ```\n    The `find` function takes two integers `a` and `b` as input and returns the quotient of `a` divided by `b`, rounded down to the nearest integer. This solution satisfies the given assertion."}
{"task_id": "Mbpp/293", "completion": "import math\n\ndef otherside_rightangle(side1, side2):\n    return math.sqrt(side1**2 + side2**2)\n\n# Test the function\nassert otherside_rightangle(7, 8) == 10.63014581273465"}
{"task_id": "Mbpp/294", "completion": "\n    def max_val(lst):\n        max_value = lst[0]\n        for item in lst:\n            if isinstance(item, (int, float)) and item > max_value:\n                max_value = item\n        return max_value\n    ```\n    The `max_val` function iterates through the list and checks if each item is an integer or float. If it is, it compares it with the current maximum value and updates the maximum value if necessary. Finally, it returns the maximum value found in the list."}
{"task_id": "Mbpp/57", "completion": "def find_Max_Num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))"}
{"task_id": "Mbpp/295", "completion": "def sum_div(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.extend([i, n//i])\n    if int(n**0.5)**2 == n:\n        divisors.remove(int(n**0.5))\n    return sum(set(divisors))"}
{"task_id": "Mbpp/296", "completion": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count"}
{"task_id": "Mbpp/297", "completion": "def flatten_list(nested_list):\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list"}
{"task_id": "Mbpp/299", "completion": "def max_aggregate(tuples):\n    max_aggregate_value = 0\n    max_aggregate_name = ''\n    aggregate_dict = {}\n\n    for name, value in tuples:\n        if name in aggregate_dict:\n            aggregate_dict[name] += value\n        else:\n            aggregate_dict[name] = value\n\n    for name, aggregate in aggregate_dict.items():\n        if aggregate > max_aggregate_value:\n            max_aggregate_value = aggregate\n            max_aggregate_name = name\n\n    return (max_aggregate_name, max_aggregate_value)"}
{"task_id": "Mbpp/300", "completion": "\n    import math\n\n    def count_binary_seq(n):\n        # Base case: n = 1\n        if n == 1:\n            return 2.0\n        else:\n            # Recursive case: count_binary_seq(n) = count_binary_seq(n-1) * 2\n            return count_binary_seq(n-1) * 2\n\n    # Test the function\n    assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)\n    ```\n\n    The `count_binary_seq` function recursively calculates the count of binary sequences of length 2n such that the sum of the first n bits is equal to the sum of the last n bits. The base case is when n = 1, in which case the count is 2.0. The recursive case is when n > 1, in which case the count is calculated as count_binary_seq(n-1) * 2. The assertion at the end of the code verifies that the function returns the correct count for n = 1."}
{"task_id": "Mbpp/301", "completion": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + max(dict_depth(v) for v in d.values()) if d else 1\n    else:\n        return 0"}
{"task_id": "Mbpp/305", "completion": "def start_withp(words):\n    for word in words:\n        if word.startswith('p'):\n            return word.split()\n    return None"}
{"task_id": "Mbpp/306", "completion": "\n    def max_sum_increasing_subseq(arr, n, i, k):\n        max_sum = 0\n        for j in range(i, k):\n            if arr[j] > arr[i-1]:\n                max_sum += arr[j]\n        return max_sum\n    ```\n    The `max_sum_increasing_subseq` function takes an array `arr`, its length `n`, an index `i`, and a number `k` as input. It iterates through the elements of the array from index `i` to `k` and adds the elements that are greater than the element at index `i-1` to the `max_sum`. Finally, it returns the maximum sum of increasing subsequence."}
{"task_id": "Mbpp/308", "completion": "def large_product(list1, list2, num):\n    products = []\n    for i in range(num):\n        max_product = 0\n        max_index1 = 0\n        max_index2 = 0\n        for j in range(len(list1)):\n            for k in range(len(list2)):\n                if list1[j] * list2[k] > max_product:\n                    max_product = list1[j] * list2[k]\n                    max_index1 = j\n                    max_index2 = k\n        products.append(max_product)\n        del list1[max_index1]\n        del list2[max_index2]\n    return products"}
{"task_id": "Mbpp/309", "completion": "def maximum(a, b):\n    return max(a, b)"}
{"task_id": "Mbpp/58", "completion": "\n    def opposite_Signs(num1, num2):\n        return (num1 ^ num2) < 0\n    ```\n    The `opposite_Signs` function takes two integers `num1` and `num2` as input and returns `True` if they have opposite signs, and `False` otherwise. The function uses bitwise XOR (`^`) to compare the signs of the two numbers and returns `True` if the result is negative, indicating opposite signs."}
{"task_id": "Mbpp/310", "completion": "def string_to_tuple(string):\n    return tuple(string)"}
{"task_id": "Mbpp/311", "completion": "def set_left_most_unset_bit(num):\n    if num == 0:\n        return 1\n    mask = 1\n    while num & mask:\n        mask <<= 1\n    return num | mask"}
{"task_id": "Mbpp/312", "completion": "import math\n\ndef volume_cone(radius, height):\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume\n\n# Test the function\nassert math.isclose(volume_cone(5,12), 314.15926535897927, rel_tol=0.001)"}
{"task_id": "Mbpp/388", "completion": "def highest_Power_of_2(n):\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power"}
{"task_id": "Mbpp/389", "completion": "\n    def find_lucas(n):\n        if n == 0:\n            return 2\n        elif n == 1:\n            return 1\n        else:\n            return find_lucas(n-1) + find_lucas(n-2)\n\n    assert find_lucas(9) == 76\n    ```\n\n    The `find_lucas` function recursively computes the n'th lucas number using the following formula:\n    ```\n    L(n) = L(n-1) + L(n-2)\n    ```\n    where `L(0) = 2` and `L(1) = 1`. The assertion at the end of the code verifies that the function correctly computes the 9th lucas number, which is 76."}
{"task_id": "Mbpp/390", "completion": "def add_string(lst, format_str):\n    return [format_str.format(item) for item in lst]"}
{"task_id": "Mbpp/391", "completion": "def convert_list_dictionary(keys, values, scores):\n    result = []\n    for i in range(len(keys)):\n        nested_dict = {keys[i]: {values[i]: scores[i]}}\n        result.append(nested_dict)\n    return result"}
{"task_id": "Mbpp/392", "completion": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n\nassert get_max_sum(60) == 106"}
{"task_id": "Mbpp/394", "completion": "\n    def check_distinct(t):\n        return len(set(t)) == len(t)\n    ```\n    The `check_distinct` function takes a tuple `t` as input and returns `True` if it contains no duplicates, and `False` otherwise. It does this by creating a set from the tuple and comparing its length with the original tuple's length. If the lengths are equal, it means that the tuple contains no duplicates, and the function returns `True`. Otherwise, it returns `False`."}
{"task_id": "Mbpp/395", "completion": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    return None"}
{"task_id": "Mbpp/59", "completion": "\n    def is_octagonal(n):\n        return n * (3 * n - 2)\n    ```\n    The `is_octagonal` function takes an integer `n` as input and returns the nth octagonal number, which is calculated as `n * (3 * n - 2)`. This solution satisfies the given assertion."}
{"task_id": "Mbpp/396", "completion": "def check_char(string):\n    if string[0] == string[-1]:\n        return \"Valid\"\n    else:\n        return \"Invalid\""}
{"task_id": "Mbpp/397", "completion": "def median_numbers(num1, num2, num3):\n    sorted_numbers = sorted([num1, num2, num3])\n    return sorted_numbers[1]\n\n# Test the function\nassert median_numbers(25,55,65)==55.0"}
{"task_id": "Mbpp/398", "completion": "\n    def sum_of_digits(numbers):\n        total_sum = 0\n        for num in numbers:\n            while num > 0:\n                total_sum += num % 10\n                num //= 10\n        return total_sum\n    ```\n    The `sum_of_digits` function takes a list of numbers as input and iterates through each number, adding the sum of its digits to the `total_sum` variable. It then returns the total sum of digits for all numbers in the list."}
{"task_id": "Mbpp/400", "completion": "def extract_freq(lst):\n    unique_tuples = set(lst)\n    return len(unique_tuples)"}
{"task_id": "Mbpp/404", "completion": "def minimum(a, b):\n    return a if a < b else b"}
{"task_id": "Mbpp/405", "completion": "def check_tuplex(tuplex, element):\n    return element in tuplex"}
{"task_id": "Mbpp/406", "completion": "\n    def find_Parity(num):\n        return bin(num).count('1') % 2 != 0\n    ```\n    The `find_Parity` function takes a number `num` as input and returns `True` if the parity of the number is odd, and `False` otherwise. It does this by converting the number to its binary representation using the `bin` function and then counting the number of '1' bits in the binary representation. If the count is odd, the function returns `True`, indicating that the parity is odd. Otherwise, it returns `False`."}
{"task_id": "Mbpp/407", "completion": "\n    def rearrange_bigger(num):\n        num_str = str(num)\n        digits = list(num_str)\n        for i in range(len(digits)-1, 0, -1):\n            if digits[i] > digits[i-1]:\n                digits[i], digits[i-1] = digits[i-1], digits[i]\n                return int(''.join(digits))\n        return -1\n    ```\n    The `rearrange_bigger` function takes a number as input and returns the next bigger number by rearranging the digits of the input. If no such arrangement is possible, it returns -1."}
{"task_id": "Mbpp/409", "completion": "\n    def min_product_tuple(tuples):\n        min_product = float('inf')\n        for i in range(len(tuples)):\n            for j in range(i+1, len(tuples)):\n                product = tuples[i][0] * tuples[j][1]\n                if product < min_product:\n                    min_product = product\n        return min_product\n    ```\n\n    The `min_product_tuple` function iterates through all pairs of tuples within the given list and calculates the product of each pair. It then updates the minimum product encountered so far and returns the minimum product found."}
{"task_id": "Mbpp/410", "completion": "def min_val(lst):\n    min_val = float('inf')\n    for item in lst:\n        if isinstance(item, (int, float)):\n            if item < min_val:\n                min_val = item\n    return min_val"}
{"task_id": "Mbpp/61", "completion": "def count_Substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count"}
{"task_id": "Mbpp/412", "completion": "\n    def remove_odd(lst):\n        return [x for x in lst if x % 2 == 0]\n    ```\n    The `remove_odd` function takes a list `lst` as input and returns a new list containing only the even numbers from the input list. The function uses a list comprehension to filter out the odd numbers from the input list and returns the resulting list."}
{"task_id": "Mbpp/413", "completion": "def extract_nth_element(lst, n):\n    return [t[n] for t in lst]"}
{"task_id": "Mbpp/414", "completion": "\n    def overlapping(seq1, seq2):\n        for item in seq1:\n            if item in seq2:\n                return True\n        return False\n    ```\n    The `overlapping` function iterates through the elements of `seq1` and checks if any element exists in `seq2`. If an element is found, the function returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/415", "completion": "def max_Product(arr):\n    arr.sort()\n    n = len(arr)\n    if n < 2:\n        return None\n    if n == 2:\n        return (arr[0], arr[1])\n    if arr[0] * arr[1] > arr[-2] * arr[-1]:\n        return (arr[0], arr[1])\n    else:\n        return (arr[-2], arr[-1])"}
{"task_id": "Mbpp/418", "completion": "def Find_Max(list_of_lists):\n    max_length = 0\n    max_list = []\n    for lst in list_of_lists:\n        if len(lst) > max_length:\n            max_length = len(lst)\n            max_list = lst\n    return max_list"}
{"task_id": "Mbpp/419", "completion": "\n    def round_and_sum(numbers):\n        rounded_numbers = [round(num) for num in numbers]\n        total_sum = sum(rounded_numbers)\n        return total_sum * len(rounded_numbers)\n    ```\n    The `round_and_sum` function takes a list of numbers as input, rounds each number using the `round` function, calculates the sum of the rounded numbers, and then returns the product of the sum and the length of the list. This solution satisfies the given assertion."}
{"task_id": "Mbpp/420", "completion": "\n    def cube_Sum(n):\n        sum = 0\n        for i in range(1, n+1):\n            sum += i**3\n        return sum\n    ```\n    The `cube_Sum` function takes an integer `n` as input and calculates the cube sum of the first `n` even natural numbers. It iterates through the range of numbers from 1 to `n`, cubes each number, and adds the result to the `sum`. Finally, it returns the calculated sum."}
{"task_id": "Mbpp/421", "completion": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(x) for x in tup)"}
{"task_id": "Mbpp/422", "completion": "def find_Average_Of_Cube(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    average_of_cubes = sum_of_cubes / n\n    return average_of_cubes\n\n# Test the function\nassert find_Average_Of_Cube(2) == 4.5"}
{"task_id": "Mbpp/424", "completion": "def extract_rear(tuple_of_strings):\n    return [string[-1] for string in tuple_of_strings]"}
{"task_id": "Mbpp/4", "completion": "import heapq\n\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)\n\n# Test the function\nassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65]"}
{"task_id": "Mbpp/62", "completion": "\n    def smallest_num(num_list):\n        return min(num_list)\n    ```\n\n    The `smallest_num` function takes a list of numbers as input and uses the `min` function to find the smallest number in the list. The `assert` statement checks if the function returns the correct smallest number for the given list."}
{"task_id": "Mbpp/425", "completion": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count"}
{"task_id": "Mbpp/426", "completion": "\n    def filter_oddnumbers(numbers):\n        return [num for num in numbers if num % 2 != 0]\n    ```\n\n    The `filter_oddnumbers` function takes a list of numbers as input and returns a new list containing only the odd numbers from the input list. It uses a list comprehension to filter out the odd numbers and returns the result."}
{"task_id": "Mbpp/427", "completion": "def change_date_format(date_str):\n    year, month, day = date_str.split('-')\n    return f'{day}-{month}-{year}'"}
{"task_id": "Mbpp/428", "completion": "\n    def shell_sort(arr):\n        n = len(arr)\n        gap = n // 2\n        while gap > 0:\n            for i in range(gap, n):\n                temp = arr[i]\n                j = i\n                while j >= gap and arr[j - gap] > temp:\n                    arr[j] = arr[j - gap]\n                    j -= gap\n                arr[j] = temp\n            gap //= 2\n        return arr\n    ```\n    The `shell_sort` function takes an array `arr` as input and sorts it using the shell sort algorithm. It first initializes the gap size as half of the array length and then iterates through the array, comparing elements at different positions with the gap size. The elements are then swapped if they are out of order. The gap size is then reduced by half and the process is repeated until the gap size becomes 0. Finally, the sorted array is returned."}
{"task_id": "Mbpp/429", "completion": "def and_tuples(tuple1, tuple2):\n    return tuple(a & b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/430", "completion": "def parabola_directrix(a, b, c):\n    return -b**2 / (4*a)"}
{"task_id": "Mbpp/431", "completion": "def common_element(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return False"}
{"task_id": "Mbpp/432", "completion": "def median_trapezium(a, b, c):\n    # Calculate the median length of a trapezium\n    median = (a + b + c) / 2\n    return median"}
{"task_id": "Mbpp/433", "completion": "def check_greater(arr, num):\n    for element in arr:\n        if element <= num:\n            return False\n    return True"}
{"task_id": "Mbpp/435", "completion": "\n    def last_Digit(num):\n        return num % 10\n    ```\n    The `last_Digit` function takes a number as input and returns the last digit of the number. This is achieved by using the modulo operator `%` to extract the last digit of the number."}
{"task_id": "Mbpp/63", "completion": "\n    def max_difference(tuple_list):\n        max_diff = 0\n        for i in range(len(tuple_list)):\n            for j in range(i+1, len(tuple_list)):\n                diff = abs(tuple_list[i][0] - tuple_list[j][0]) + abs(tuple_list[i][1] - tuple_list[j][1])\n                if diff > max_diff:\n                    max_diff = diff\n        return max_diff\n    ```\n    The `max_difference` function iterates through the tuple list and calculates the absolute difference between the first elements of each pair and the second elements of each pair. It then updates the maximum difference found so far and returns the final maximum difference."}
{"task_id": "Mbpp/436", "completion": "def neg_nos(lst):\n    return [num for num in lst if num < 0]"}
{"task_id": "Mbpp/437", "completion": "\n    def remove_odd(s):\n        return s[::2]\n    ```\n    The `remove_odd` function takes a string `s` as input and returns a new string containing only the even-indexed characters of the input string. This is achieved by using the slice notation `s[::2]`, which selects all characters with even indices from the input string."}
{"task_id": "Mbpp/438", "completion": "\n    def count_bidirectional(tuples):\n        bidirectional_pairs = set()\n        for t in tuples:\n            if (t[1], t[0]) in bidirectional_pairs:\n                bidirectional_pairs.remove((t[1], t[0]))\n            else:\n                bidirectional_pairs.add(t)\n        return len(bidirectional_pairs)\n    ```\n    The `count_bidirectional` function takes a list of tuples as input and uses a set to keep track of bidirectional pairs. It iterates through the input tuples, checking if the reverse of each tuple is already present in the set. If it is, the pair is removed from the set; otherwise, it is added to the set. Finally, the function returns the number of bidirectional pairs found in the input list."}
{"task_id": "Mbpp/439", "completion": "def multiple_to_single(numbers):\n    return int(''.join(map(str, numbers)))"}
{"task_id": "Mbpp/440", "completion": "\nimport re\n\ndef find_adverb_position(sentence):\n    adverb_pattern = r'\\b(?:very|extremely|quite|fairly|rather|hardly|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|almost|"}
{"task_id": "Mbpp/441", "completion": "\n    def surfacearea_cube(size):\n        return 6 * size ** 2\n    ```\n    The `surfacearea_cube` function takes the size of the cube as input and returns the surface area of the cube. The surface area of a cube is calculated as 6 times the square of the size."}
{"task_id": "Mbpp/442", "completion": "def positive_count(arr):\n    positive_count = 0\n    for num in arr:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(arr)"}
{"task_id": "Mbpp/445", "completion": "\n    def index_multiplication(tuple1, tuple2):\n        result = tuple(map(lambda x, y: (x[0] * y[0], x[1] * y[1]), tuple1, tuple2))\n        return result\n    ```\n    The `index_multiplication` function takes two tuples as input and uses the `map` function to apply the multiplication operation to each pair of elements from the input tuples. The resulting tuple is then returned as the output."}
{"task_id": "Mbpp/446", "completion": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for element in list_input:\n        count += tuple_input.count(element)\n    return count"}
{"task_id": "Mbpp/447", "completion": "\n    def cube_nums(nums):\n        return [num ** 3 for num in nums]\n    ```\n    The `cube_nums` function takes a list of numbers as input and returns a list of their cubes using a list comprehension. The `assert` statement checks if the function correctly calculates the cubes of the input list."}
{"task_id": "Mbpp/64", "completion": "def subject_marks(marks):\n    return sorted(marks, key=lambda x: x[1])"}
{"task_id": "Mbpp/448", "completion": "\n    def cal_sum(n):\n        perrin_numbers = [3, 0, 2]\n        if n <= 2:\n            return perrin_numbers[n]\n        else:\n            for i in range(3, n+1):\n                perrin_numbers.append(perrin_numbers[i-2] + perrin_numbers[i-3])\n            return sum(perrin_numbers)\n    ```\n    The `cal_sum` function calculates the sum of the first `n` Perrin numbers using a list to store the numbers. It initializes the list with the first three Perrin numbers and then iterates through the remaining numbers to calculate the sum. The function returns the sum of the first `n` Perrin numbers."}
{"task_id": "Mbpp/450", "completion": "def extract_string(string_list, size):\n    return [s for s in string_list if len(s) == size]"}
{"task_id": "Mbpp/451", "completion": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')"}
{"task_id": "Mbpp/453", "completion": "\n    def sumofFactors(num):\n        sum = 0\n        for i in range(1, num + 1):\n            if num % i == 0 and i % 2 == 0:\n                sum += i\n        return sum\n    ```\n    The `sumofFactors` function iterates through all the factors of the input number and adds up the even factors. It then returns the sum of even factors."}
{"task_id": "Mbpp/454", "completion": "import re\n\ndef text_match_wordz(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n\n# Test the function\nassert text_match_wordz(\"pythonz.\")==True"}
{"task_id": "Mbpp/455", "completion": "\n    def check_monthnumb_number(month_number):\n        if month_number in [1, 3, 5, 7, 8, 10, 12]:\n            return True\n        elif month_number in [4, 6, 9, 11]:\n            return False\n        else:\n            return False\n    ```\n    The `check_monthnumb_number` function takes a month number as input and returns `True` if the month contains 31 days, `False` otherwise."}
{"task_id": "Mbpp/456", "completion": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list"}
{"task_id": "Mbpp/457", "completion": "\n    def Find_Min(lst):\n        min_len = float('inf')\n        min_sublist = []\n        for sublist in lst:\n            if len(sublist) < min_len:\n                min_len = len(sublist)\n                min_sublist = sublist\n        return min_sublist\n    ```\n    The `Find_Min` function iterates through the input list of sublists and finds the sublist with the minimum length. It initializes `min_len` to infinity and `min_sublist` to an empty list. For each sublist, it checks if its length is less than the current minimum length. If so, it updates `min_len` and `min_sublist` accordingly. Finally, it returns the sublist with the minimum length."}
{"task_id": "Mbpp/458", "completion": "def rectangle_area(length, width):\n    return length * width\n\n# Test the function\nassert rectangle_area(10, 20) == 200"}
{"task_id": "Mbpp/459", "completion": "def remove_uppercase(input_string):\n    result = ''\n    for char in input_string:\n        if char.islower():\n            result += char\n    return result"}
{"task_id": "Mbpp/65", "completion": "def recursive_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total"}
{"task_id": "Mbpp/460", "completion": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]"}
{"task_id": "Mbpp/461", "completion": "def upper_ctr(string):\n    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count"}
{"task_id": "Mbpp/462", "completion": "def combinations_list(lst):\n    result = [[]]\n    for item in lst:\n        result += [comb + [item] for comb in result]\n    return result"}
{"task_id": "Mbpp/463", "completion": "\n    def max_subarray_product(arr):\n        max_product = arr[0]\n        current_product = arr[0]\n        for i in range(1, len(arr)):\n            current_product = max(arr[i], current_product * arr[i])\n            max_product = max(max_product, current_product)\n        return max_product\n    ```\n    The `max_subarray_product` function iterates through the array, keeping track of the maximum product encountered so far and the current product. It updates the maximum product if the current product is greater than the maximum product encountered so far. Finally, it returns the maximum product encountered."}
{"task_id": "Mbpp/465", "completion": "def drop_empty(d):\n    return {k: v for k, v in d.items() if v is not None}"}
{"task_id": "Mbpp/468", "completion": "def max_product(arr):\n    n = len(arr)\n    max_prod = [0] * n\n    min_prod = [0] * n\n    max_prod[0] = arr[0]\n    min_prod[0] = arr[0]\n\n    for i in range(1, n):\n        if arr[i] >= 0:\n            max_prod[i] = max(arr[i], max_prod[i-1] * arr[i])\n            min_prod[i] = min(arr[i], min_prod[i-1] * arr[i])\n        else:\n            max_prod[i] = max(arr[i], min_prod[i-1] * arr[i])\n            min_prod[i] = min(arr[i], max_prod[i-1] * arr[i])\n\n    return max(max_prod)"}
{"task_id": "Mbpp/470", "completion": "\n    def add_pairwise(t):\n        return tuple(t[i] + t[i+1] for i in range(len(t)-1))\n    ```\n    The `add_pairwise` function takes a tuple `t` as input and returns a tuple containing the pairwise addition of the neighboring elements of the input tuple. The function uses a generator expression to perform the pairwise addition and then converts the result into a tuple before returning it."}
{"task_id": "Mbpp/471", "completion": "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product"}
{"task_id": "Mbpp/472", "completion": "def check_Consecutive(lst):\n    return sorted(lst) == list(range(min(lst), max(lst)+1))"}
{"task_id": "Mbpp/473", "completion": "\n    def tuple_intersection(tuple_list1, tuple_list2):\n        intersection = set()\n        for tup1 in tuple_list1:\n            for tup2 in tuple_list2:\n                if tup1 == tup2 or tup1 == tup2[::-1]:\n                    intersection.add(tup1)\n        return intersection\n    ```\n    The `tuple_intersection` function takes two lists of tuples as input and returns the intersection of the tuples irrespective of their order. It iterates through each tuple in the first list and checks if it exists in the second list. If it does, it adds the tuple to the intersection set. The function also checks for reverse tuples and adds them to the intersection set if found. Finally, it returns the intersection set."}
{"task_id": "Mbpp/66", "completion": "\n    def pos_count(lst):\n        count = 0\n        for num in lst:\n            if num > 0:\n                count += 1\n        return count\n    ```\n    The `pos_count` function iterates through the input list and increments the count for each positive number it encounters. Finally, it returns the count of positive numbers in the list."}
{"task_id": "Mbpp/474", "completion": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "completion": "def sort_counter(d):\n    return sorted(d.items(), key=lambda x: x[1], reverse=True)"}
{"task_id": "Mbpp/476", "completion": "def big_sum(arr):\n    arr.sort()\n    return arr[0] + arr[-1]"}
{"task_id": "Mbpp/477", "completion": "\n    def is_lower(string):\n        return string.lower()\n    ```\n    The `is_lower` function takes a string as input and returns the lowercase version of the input string. This solution satisfies the given assertion by converting the input string to lowercase."}
{"task_id": "Mbpp/478", "completion": "def remove_lowercase(s):\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char\n    return result"}
{"task_id": "Mbpp/479", "completion": "\n    def first_Digit(num):\n        while num >= 10:\n            num //= 10\n        return num\n    ```\n    The `first_Digit` function takes a number `num` as input and iteratively divides it by 10 until it becomes a single digit. The final result is returned as the first digit of the input number."}
{"task_id": "Mbpp/554", "completion": "def split_odd(numbers):\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/555", "completion": "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(i for i in range(1, n+1))\n    return sum_of_cubes - sum_of_numbers"}
{"task_id": "Mbpp/556", "completion": "def find_Odd_Pair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] ^ arr[j]) % 2 != 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/557", "completion": "def toggle_string(input_string):\n    toggled_string = \"\"\n    for char in input_string:\n        if char.isupper():\n            toggled_string += char.lower()\n        else:\n            toggled_string += char.upper()\n    return toggled_string\n\n# Test the function\nassert toggle_string(\"Python\")==(\"pYTHON\")"}
{"task_id": "Mbpp/67", "completion": "\n    def bell_number(n):\n        bell = [1]\n        for i in range(1, n+1):\n            new_row = [1]\n            for j in range(1, i):\n                new_row.append(new_row[j-1] + bell[j])\n            new_row.append(2*new_row[-1])\n            bell = new_row\n        return bell[-1]\n    ```\n    The `bell_number` function uses dynamic programming to calculate the Bell numbers and returns the number of ways to partition a set of Bell numbers."}
{"task_id": "Mbpp/558", "completion": "\n    def digit_distance_nums(num1, num2):\n        num1_str = str(num1)\n        num2_str = str(num2)\n        distance = 0\n        for i in range(min(len(num1_str), len(num2_str))):\n            distance += abs(int(num1_str[i]) - int(num2_str[i]))\n        return distance\n    ```\n    The `digit_distance_nums` function takes two integers `num1` and `num2` as input and returns the sum of the per-digit difference between them. It first converts the integers to strings, then iterates through the strings to calculate the per-digit difference and accumulates the result in the `distance` variable. Finally, it returns the calculated distance."}
{"task_id": "Mbpp/559", "completion": "def max_sub_array_sum(arr, n):\n    max_sum = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum"}
{"task_id": "Mbpp/560", "completion": "def union_elements(tuple1, tuple2):\n    union_set = set(tuple1) | set(tuple2)\n    return tuple(sorted(union_set))"}
{"task_id": "Mbpp/562", "completion": "def Find_Max_Length(lst):\n    max_length = 0\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    return max_length"}
{"task_id": "Mbpp/563", "completion": "import re\n\ndef extract_values(input_string):\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values"}
{"task_id": "Mbpp/564", "completion": "def count_Pairs(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/565", "completion": "def split(string):\n    return list(string)"}
{"task_id": "Mbpp/566", "completion": "def sum_digits(num):\n    return sum(int(digit) for digit in str(num))\n\n# Test the function\nassert sum_digits(345)==12"}
{"task_id": "Mbpp/567", "completion": "def issort_list(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))"}
{"task_id": "Mbpp/568", "completion": "def empty_list(n):\n    return [{} for _ in range(n)]"}
{"task_id": "Mbpp/68", "completion": "def is_Monotonic(arr):\n    if len(arr) <= 2:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n    return increasing or decreasing"}
{"task_id": "Mbpp/569", "completion": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/572", "completion": "def two_unique_nums(nums):\n    unique_nums = set()\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.add(num)\n        else:\n            unique_nums.remove(num)\n    return list(unique_nums)"}
{"task_id": "Mbpp/573", "completion": "\n    def unique_product(lst):\n        unique_numbers = set(lst)\n        product = 1\n        for num in unique_numbers:\n            product *= num\n        return product\n    ```\n    The `unique_product` function takes a list of numbers as input and returns the product of the unique numbers in the list. It uses a set to remove duplicates from the list and then calculates the product of the unique numbers."}
{"task_id": "Mbpp/574", "completion": "import math\n\ndef surfacearea_cylinder(radius, height):\n    base_area = math.pi * radius ** 2\n    lateral_area = 2 * math.pi * radius * height\n    total_area = 2 * base_area + lateral_area\n    return total_area\n\n# Test the function\nassert surfacearea_cylinder(10,5)==942.45"}
{"task_id": "Mbpp/576", "completion": "\n    def is_Sub_Array(arr1, arr2):\n        if len(arr2) > len(arr1):\n            return False\n        for i in range(len(arr1) - len(arr2) + 1):\n            if arr1[i:i+len(arr2)] == arr2:\n                return True\n        return False\n    ```\n    The `is_Sub_Array` function takes two lists as input and checks if the second list is a sublist of the first list. It iterates through the first list and checks if any sublist of the same length as the second list matches the second list. If a match is found, the function returns True; otherwise, it returns False."}
{"task_id": "Mbpp/577", "completion": "\n    def last_Digit_Factorial(n):\n        if n == 0:\n            return 1\n        last_digit = 1\n        for i in range(1, n+1):\n            last_digit = (last_digit * i) % 10\n        return last_digit\n    ```\n    The `last_Digit_Factorial` function takes a non-negative integer `n` as input and returns the last digit in the factorial of `n`. It uses a simple mathematical property of factorials to efficiently calculate the last digit. The function iterates through the numbers from 1 to `n`, multiplying each number with the current last digit and taking the modulo 10 to get the last digit of the product. Finally, it returns the last digit of the factorial of `n`."}
{"task_id": "Mbpp/578", "completion": "\n    def interleave_lists(list1, list2, list3):\n        interleaved_list = []\n        for i in range(len(list1)):\n            interleaved_list.append(list1[i])\n            interleaved_list.append(list2[i])\n            interleaved_list.append(list3[i])\n        return interleaved_list\n    ```\n    The `interleave_lists` function takes three lists as input and returns a single flat list by interleaving the elements of the input lists. It iterates through the lists and appends the elements at the same index to the `interleaved_list`. Finally, it returns the interleaved list."}
{"task_id": "Mbpp/579", "completion": "def find_dissimilar(tuple1, tuple2):\n    dissimilar_elements = set(tuple1) ^ set(tuple2)\n    return tuple(dissimilar_elements)"}
{"task_id": "Mbpp/580", "completion": "\n    def extract_even(t):\n        return tuple(x for x in t if isinstance(x, int) and x % 2 == 0)\n    ```\n    The `extract_even` function takes a tuple `t` as input and returns a new tuple containing only the even integers from the original tuple. It uses a generator expression to filter out the uneven elements and returns the resulting tuple."}
{"task_id": "Mbpp/581", "completion": "\n    def surface_Area(base_edge, height):\n        base_area = base_edge ** 2\n        lateral_area = 4 * base_edge * height\n        surface_area = 2 * base_area + lateral_area\n        return surface_area\n    ```\n    The `surface_Area` function takes the base edge and height as input and calculates the surface area of a square pyramid using the formula:\n    ```\n    Surface Area = 2 * Base Area + Lateral Area\n    ```\n    The base area is calculated as the square of the base edge, and the lateral area is calculated as 4 times the base edge multiplied by the height. The total surface area is then returned as the sum of these two areas."}
{"task_id": "Mbpp/69", "completion": "def is_sublist(lst, sub):\n    for i in range(len(lst) - len(sub) + 1):\n        if lst[i:i+len(sub)] == sub:\n            return True\n    return False"}
{"task_id": "Mbpp/582", "completion": "def is_dict_empty(d):\n    return not bool(d)\n\n# Test the function\nassert is_dict_empty({10}) == False"}
{"task_id": "Mbpp/583", "completion": "\n    def catalan_number(n):\n        if n <= 1:\n            return 1\n        result = 0\n        for i in range(n):\n            result += catalan_number(i) * catalan_number(n-i-1)\n        return result\n\n    assert catalan_number(10)==16796\n    ```"}
{"task_id": "Mbpp/585", "completion": "def expensive_items(dataset, n):\n    sorted_dataset = sorted(dataset, key=lambda x: x['price'], reverse=True)\n    return sorted_dataset[:n]"}
{"task_id": "Mbpp/586", "completion": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "completion": "def list_tuple(lst):\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "completion": "\n    def big_diff(nums):\n        if len(nums) < 2:\n            return 0\n        else:\n            return max(nums) - min(nums)\n    ```\n    The `big_diff` function takes a list of numbers as input and returns the difference between the largest and smallest values in the list. If the list has less than 2 elements, it returns 0."}
{"task_id": "Mbpp/589", "completion": "def perfect_squares(start, end):\n    perfect_squares = []\n    for num in range(start, end+1):\n        if (num**0.5).is_integer():\n            perfect_squares.append(num)\n    return perfect_squares"}
{"task_id": "Mbpp/590", "completion": "import cmath\n\ndef polar_rect(r, theta):\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n    return (x, y)"}
{"task_id": "Mbpp/591", "completion": "def swap_List(lst):\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"}
{"task_id": "Mbpp/592", "completion": "\n    def sum_Of_product(n):\n        result = 0\n        for i in range(1, n+1):\n            product = 1\n            for j in range(1, i+1):\n                product *= j\n            result += product\n        return result\n    ```\n    The `sum_Of_product` function takes an integer `n` as input and calculates the sum of the product of consecutive binomial co-efficients up to `n`. It iterates through the range of numbers from 1 to `n`, calculating the product of consecutive binomial co-efficients and adding it to the `result`. Finally, it returns the calculated sum."}
{"task_id": "Mbpp/70", "completion": "\n    def get_equal(tuples):\n        lengths = [len(t) for t in tuples]\n        return all(l == lengths[0] for l in lengths)\n    ```\n    The `get_equal` function takes a list of tuples as input and uses a list comprehension to find the length of each tuple. It then checks if all the lengths are equal using the `all` function and returns `True` if all lengths are equal, and `False` otherwise."}
{"task_id": "Mbpp/593", "completion": "def removezero_ip(ip_address):\n    octets = ip_address.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    return '.'.join(cleaned_octets)"}
{"task_id": "Mbpp/594", "completion": "def diff_even_odd(lst):\n    even_num = next((num for num in lst if num % 2 == 0), None)\n    odd_num = next((num for num in lst if num % 2 != 0), None)\n    return even_num - odd_num if even_num and odd_num else None"}
{"task_id": "Mbpp/595", "completion": "def min_Swaps(str1, str2):\n    count = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/596", "completion": "\n    import sys\n\n    def tuple_size(t):\n        return sys.getsizeof(t)\n\n    # Test the function\n    assert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3) ) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))\n    ```\n\n    The `tuple_size` function takes a tuple as input and uses the `sys.getsizeof` function to calculate the size in bytes of the given tuple. The assertion at the end of the script verifies that the function returns the correct size in bytes for the given tuple."}
{"task_id": "Mbpp/597", "completion": "\n    def find_kth(arr1, arr2, k):\n        m, n = len(arr1), len(arr2)\n        if m > n:\n            return find_kth(arr2, arr1, k)\n        if m == 0:\n            return arr2[k - 1]\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        i = min(m, k // 2)\n        j = min(n, k // 2)\n        if arr1[i - 1] > arr2[j - 1]:\n            return find_kth(arr1, arr2[j:], k - j)\n        else:\n            return find_kth(arr1[i:], arr2, k - i)\n    ```\n    This solution uses a divide and conquer approach to find the kth element from the given two sorted arrays. It first checks if the arrays are empty or if k is 1, in which case it returns the minimum element. It then calculates the indices i and j to divide the arrays into two parts and recursively calls the function to find the kth element."}
{"task_id": "Mbpp/598", "completion": "\n    def armstrong_number(num):\n        num_str = str(num)\n        num_len = len(num_str)\n        sum_cubes = 0\n        for digit in num_str:\n            sum_cubes += int(digit) ** num_len\n        return sum_cubes == num\n    ```\n    The `armstrong_number` function takes a number `num` as input and checks if it is an Armstrong number. It first converts the number to a string to iterate through its digits. Then, it calculates the sum of the cubes of its digits and compares it with the original number. If the sum of the cubes is equal to the original number, the function returns True, indicating that the number is an Armstrong number. Otherwise, it returns False."}
{"task_id": "Mbpp/599", "completion": "def sum_average(n):\n    total_sum = sum(range(1, n+1))\n    average = total_sum / n\n    return total_sum, average"}
{"task_id": "Mbpp/600", "completion": "\n    def is_Even(num):\n        return num % 2 == 0\n    ```\n    The `is_Even` function takes a number as input and returns `True` if the number is even, and `False` otherwise. This solution uses the modulo operator to check if the number is even by checking if the remainder of the division by 2 is 0."}
{"task_id": "Mbpp/602", "completion": "\n    def first_repeated_char(string):\n        char_count = {}\n        for char in string:\n            if char in char_count:\n                return char\n            else:\n                char_count[char] = 1\n        return None\n    ```\n\n    The `first_repeated_char` function iterates through the characters in the input string and keeps track of the count of each character using a dictionary. If a character is found to be repeated, the function returns the first repeated character. If no repeated character is found, the function returns `None`."}
{"task_id": "Mbpp/603", "completion": "\n    def get_ludic(n):\n        ludic_numbers = []\n        for i in range(1, n+1):\n            if is_ludic(i):\n                ludic_numbers.append(i)\n        return ludic_numbers\n\n    def is_ludic(num):\n        if num == 1:\n            return True\n        if num % 2 == 0:\n            return False\n        while num > 1:\n            if num % 2 == 0:\n                return False\n            num = (num - 1) / 2\n        return True\n\n    assert get_ludic(10) == [1, 2, 3, 5, 7]\n    ```"}
{"task_id": "Mbpp/71", "completion": "def comb_sort(lst):\n    gap = len(lst)\n    shrink = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n            sorted = True\n        for i in range(0, len(lst) - gap):\n            if lst[i] > lst[i + gap]:\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                sorted = False\n\n    return lst"}
{"task_id": "Mbpp/604", "completion": "\n    def reverse_words(input_string):\n        words = input_string.split()\n        reversed_words = words[::-1]\n        return \" \".join(reversed_words)\n    ```\n    The `reverse_words` function splits the input string into words using the `split` method, reverses the list of words using slicing, and then joins the reversed words back into a string with spaces using the `join` method. The assertion provided in the problem description is then checked to ensure that the function correctly reverses the words in the input string."}
{"task_id": "Mbpp/605", "completion": "def prime_num(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5)+1):\n        if num % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/606", "completion": "import math\n\ndef radian_degree(degrees):\n    return degrees * math.pi / 180\n\n# Test the function\nassert radian_degree(90) == 1.5707963267948966"}
{"task_id": "Mbpp/607", "completion": "import re\n\ndef find_literals(string, pattern):\n    match = re.search(pattern, string)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None, None, None"}
{"task_id": "Mbpp/608", "completion": "\n    def bell_Number(n):\n        bell = [1]\n        for i in range(1, n+1):\n            new_bell = [1]\n            for j in range(1, i+1):\n                new_bell.append(new_bell[j-1] + bell[j-1])\n            bell = new_bell\n        return bell[n]\n    ```\n    The `bell_Number` function takes an integer `n` as input and returns the nth bell number using a dynamic programming approach. It initializes the bell list with 1 and then iterates through the range of 1 to n to calculate the next bell number based on the previous bell numbers. Finally, it returns the nth bell number."}
{"task_id": "Mbpp/610", "completion": "def remove_kth_element(lst, k):\n    return lst[:k] + lst[k+1:]"}
{"task_id": "Mbpp/611", "completion": "\n    def max_of_nth(matrix, n):\n        return max(row[n] for row in matrix)\n    ```\n    The `max_of_nth` function takes a matrix represented as a list of lists and an integer `n` as input. It then uses a generator expression to extract the nth element from each row of the matrix and returns the maximum value. This solution satisfies the given assertion."}
{"task_id": "Mbpp/612", "completion": "def merge(lst):\n    return [list(x) for x in zip(*lst)]"}
{"task_id": "Mbpp/614", "completion": "\n    def cummulative_sum(tuple_list):\n        total = 0\n        for tup in tuple_list:\n            total += sum(tup)\n        return total\n    ```\n\n    The `cummulative_sum` function takes a list of tuples as input and calculates the cumulative sum of all the values present in the tuples. It iterates through the list of tuples, sums the values in each tuple, and adds the sum to the total. Finally, it returns the cumulative sum of all the values in the tuple list."}
{"task_id": "Mbpp/615", "completion": "\n    def average_tuple(tuples):\n        averages = []\n        for t in tuples:\n            averages.append(sum(t) / len(t))\n        return averages\n    ```\n    The `average_tuple` function takes a tuple of tuples as input and calculates the average value for each tuple. It then returns the list of average values."}
{"task_id": "Mbpp/6", "completion": "def differ_At_One_Bit_Pos(num1, num2):\n    xor_result = num1 ^ num2\n    return bin(xor_result).count('1') == 1"}
{"task_id": "Mbpp/72", "completion": "\n    def dif_Square(n):\n        for i in range(1, n):\n            for j in range(1, n):\n                if i**2 - j**2 == n:\n                    return True\n        return False\n    ```\n    The `dif_Square` function iterates through all possible pairs of integers `i` and `j`, and checks if the difference of their squares is equal to the given number `n`. If such a pair is found, the function returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/616", "completion": "\n    def tuple_modulo(t1, t2):\n        return tuple(a % b for a, b in zip(t1, t2))\n    ```\n    The `tuple_modulo` function takes two tuples `t1` and `t2` as input and returns a new tuple containing the element-wise modulo of the corresponding elements of `t1` and `t2`. The `zip` function is used to iterate over the elements of both tuples simultaneously, and the `tuple` function is used to create a new tuple from the result of the modulo operation."}
{"task_id": "Mbpp/618", "completion": "def div_list(list1, list2):\n    result = []\n    for i in range(len(list1)):\n        if list2[i] != 0:\n            result.append(list1[i] / list2[i])\n        else:\n            result.append(float('inf'))  # Handle division by zero\n    return result"}
{"task_id": "Mbpp/619", "completion": "def move_num(string):\n    num_list = []\n    char_list = []\n    for char in string:\n        if char.isdigit():\n            num_list.append(char)\n        else:\n            char_list.append(char)\n    return ''.join(char_list) + ''.join(num_list)"}
{"task_id": "Mbpp/620", "completion": "def largest_subset(numbers):\n    numbers.sort()\n    subset = [numbers[0]]\n    for num in numbers[1:]:\n        if num % subset[-1] == 0:\n            subset.append(num)\n    return len(subset)"}
{"task_id": "Mbpp/622", "completion": "\n    def get_median(list1, list2, n):\n        merged_list = sorted(list1 + list2)\n        if n % 2 == 0:\n            return (merged_list[n//2 - 1] + merged_list[n//2]) / 2\n        else:\n            return merged_list[n//2]\n    ```\n    The `get_median` function takes two sorted lists `list1` and `list2` of size `n` and returns the median of the merged list. It first merges the two lists and then calculates the median based on the size of the merged list."}
{"task_id": "Mbpp/623", "completion": "def nth_nums(nums, n):\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "completion": "def is_upper(string):\n    return string.upper()"}
{"task_id": "Mbpp/626", "completion": "\n    import math\n\n    def triangle_area(radius):\n        if radius <= 0:\n            return None\n        else:\n            area = (radius ** 2) * math.pi / 2\n            return area\n    ```\n\n    The `triangle_area` function takes the radius of the semicircle as input and calculates the area of the largest triangle that can be inscribed in the semicircle. If the radius is non-positive, it returns `None`. Otherwise, it calculates the area using the formula `area = (radius^2) * pi / 2` and returns the result."}
{"task_id": "Mbpp/628", "completion": "def replace_spaces(string):\n    return string.replace(' ', '%20')"}
{"task_id": "Mbpp/629", "completion": "def find_even_numbers(numbers):\n    return [num for num in numbers if num % 2 == 0]\n\nassert find_even_numbers([1,2,3,4,5]) == [2,4]"}
{"task_id": "Mbpp/74", "completion": "def is_samepatterns(patterns, colors):\n    if len(patterns) != len(colors):\n        return False\n    for i in range(len(patterns)):\n        if patterns[i] != colors[i]:\n            return False\n    return True"}
{"task_id": "Mbpp/630", "completion": "def get_coordinates(coordinate):\n    x, y = coordinate\n    adjacent_coordinates = []\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            if (i, j) != coordinate:\n                adjacent_coordinates.append([i, j])\n    return adjacent_coordinates"}
{"task_id": "Mbpp/631", "completion": "\n    def replace_spaces(input_string):\n        return input_string.replace(' ', '_')\n    ```\n\n    The `replace_spaces` function takes an input string and uses the `replace` method to replace all occurrences of whitespace characters with underscores. The function then returns the modified string. This solution satisfies the given assertion."}
{"task_id": "Mbpp/632", "completion": "\n    def move_zero(lst):\n        non_zero = [num for num in lst if num != 0]\n        zero_count = len(lst) - len(non_zero)\n        return non_zero + [0] * zero_count\n    ```\n    The `move_zero` function takes a list `lst` as input and uses a list comprehension to create a new list `non_zero` containing all non-zero elements from the input list. It then calculates the number of zeroes in the input list and appends that many zeros to the end of the `non_zero` list. Finally, it returns the modified list."}
{"task_id": "Mbpp/633", "completion": "def pair_xor_Sum(nums, n):\n    result = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            result += nums[i] ^ nums[j]\n    return result"}
{"task_id": "Mbpp/635", "completion": "\n    def heap_sort(arr):\n        def heapify(arr, n, i):\n            largest = i\n            left = 2 * i + 1\n            right = 2 * i + 2\n\n            if left < n and arr[i] < arr[left]:\n                largest = left\n\n            if right < n and arr[largest] < arr[right]:\n                largest = right\n\n            if largest != i:\n                arr[i], arr[largest] = arr[largest], arr[i]\n                heapify(arr, n, largest)\n\n        n = len(arr)\n\n        for i in range(n, -1, -1):\n            heapify(arr, n, i)\n\n        for i in range(n - 1, 0, -1):\n            arr[i], arr[0] = arr[0], arr[i]\n            heapify(arr, i, 0)\n\n        return arr\n    ```\n\n    The `heap_sort` function first converts the given list into a max-heap using the `heapify` function. Then, it repeatedly extracts the maximum element from the heap and places it at the end of the list, until the list is sorted."}
{"task_id": "Mbpp/637", "completion": "\n    def noprofit_noloss(buy_price, sell_price):\n        return buy_price == sell_price\n    ```\n    The `noprofit_noloss` function takes two parameters: `buy_price` and `sell_price`. It returns `True` if the `buy_price` is equal to the `sell_price`, indicating that there is no profit and no loss. Otherwise, it returns `False`."}
{"task_id": "Mbpp/638", "completion": "\n    def wind_chill(wind_velocity, temperature):\n        wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * (wind_velocity ** 0.16) + 0.3965 * temperature * (wind_velocity ** 0.16)\n        return round(wind_chill_index)\n    ```\n    The `wind_chill` function takes the wind velocity and temperature as input and calculates the wind chill index using the formula provided. The result is rounded to the next integer and returned as the output."}
{"task_id": "Mbpp/639", "completion": "def sample_nam(names):\n    return sum(len(name) for name in names if name[0].isupper())"}
{"task_id": "Mbpp/640", "completion": "\n    def remove_parenthesis(string):\n        return string.replace(\"(\", \"\").replace(\")\", \"\")\n    ```\n    The `remove_parenthesis` function takes a string as input and uses the `replace` method to remove the parenthesis and what is inbetween them. The function then returns the modified string."}
{"task_id": "Mbpp/641", "completion": "def is_nonagonal(n):\n    return n * (3 * n - 2)\n\n# Test the function\nassert is_nonagonal(10) == 325"}
{"task_id": "Mbpp/75", "completion": "\n    def find_tuples(tuples, k):\n        return [t for t in tuples if all(x % k == 0 for x in t)]\n    ```\n    The `find_tuples` function takes a list of tuples and a number `k` as input. It then filters the list of tuples to include only those tuples where all elements are divisible by `k`. The function uses a list comprehension to achieve this, and returns the filtered list of tuples."}
{"task_id": "Mbpp/643", "completion": "\n    def text_match_wordz_middle(text):\n        import re\n        pattern = r'^[^z]*z[^z]*$'\n        return bool(re.match(pattern, text))\n    ```\n    The `text_match_wordz_middle` function uses the `re` module to define a regular expression pattern that matches a string containing 'z' except at the start and end of the word. The `re.match` function is used to check if the input text matches the pattern. If the text matches the pattern, the function returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/644", "completion": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]"}
{"task_id": "Mbpp/720", "completion": "def add_dict_to_tuple(tuple_input, dict_input):\n    tuple_input += (dict_input,)\n    return tuple_input"}
{"task_id": "Mbpp/721", "completion": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[n-1][n-1] / (n + n - 1)"}
{"task_id": "Mbpp/722", "completion": "def filter_data(student_data, min_height, min_weight):\n    filtered_students = {name: (height, weight) for name, (height, weight) in student_data.items() if height >= min_height and weight >= min_weight}\n    return filtered_students"}
{"task_id": "Mbpp/723", "completion": "def count_same_pair(list1, list2):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/724", "completion": "def power_base_sum(base, power):\n    result = base ** power\n    digit_sum = sum(int(digit) for digit in str(result))\n    return digit_sum"}
{"task_id": "Mbpp/725", "completion": "import re\n\ndef extract_quotation(input_string):\n    quotation_marks = re.findall(r'\"([^\"]*)\"', input_string)\n    return quotation_marks\n\n# Test the function\nassert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"}
{"task_id": "Mbpp/726", "completion": "def multiply_elements(t):\n    return tuple(t[i] * t[i+1] for i in range(len(t)-1))"}
{"task_id": "Mbpp/728", "completion": "def sum_list(list1, list2):\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length\")\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/77", "completion": "\n    def is_Diff(num):\n        return num % 11 == 0\n    ```\n    The `is_Diff` function takes a number as input and returns `True` if the number is divisible by 11, and `False` otherwise. This solution satisfies the given assertion."}
{"task_id": "Mbpp/730", "completion": "def consecutive_duplicates(lst):\n    new_lst = []\n    for i in range(len(lst)):\n        if i == 0 or lst[i] != lst[i-1]:\n            new_lst.append(lst[i])\n    return new_lst"}
{"task_id": "Mbpp/731", "completion": "import math\n\ndef lateralsurface_cone(r, h):\n    # Calculate the lateral surface area of a cone\n    # r is the radius of the base\n    # h is the height of the cone\n    # A = \u03c0r(r + sqrt(r^2 + h^2))\n    return math.pi * r * (r + math.sqrt(r**2 + h**2))\n\n# Test the function\nassert lateralsurface_cone(5,12)==204.20352248333654"}
{"task_id": "Mbpp/732", "completion": "def replace_specialchar(text):\n    text = text.replace(' ', ':')\n    text = text.replace(',', ':')\n    text = text.replace('.', ':')\n    return text\n\nassert replace_specialchar('Python language, Programming language.')==('Python:language::Programming:language:')"}
{"task_id": "Mbpp/733", "completion": "def find_first_occurrence(arr, target):\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            if mid == 0 or arr[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"}
{"task_id": "Mbpp/734", "completion": "\n    def sum_Of_Subarray_Prod(arr):\n        n = len(arr)\n        total_sum = 0\n        for i in range(n):\n            for j in range(i, n):\n                prod = 1\n                for k in range(i, j+1):\n                    prod *= arr[k]\n                total_sum += prod\n        return total_sum\n    ```\n    The `sum_Of_Subarray_Prod` function iterates through all possible sublists of the input list and calculates the product of each sublist. It then adds the products to the `total_sum` and returns the final sum."}
{"task_id": "Mbpp/735", "completion": "def toggle_middle_bits(num):\n    # Calculate the number of bits in the number\n    bits = num.bit_length()\n    \n    # Calculate the mask to toggle all bits except the first and last bit\n    mask = (1 << (bits - 2)) - 1\n    \n    # Toggle the bits using the mask\n    toggled_num = num ^ mask\n    \n    return toggled_num"}
{"task_id": "Mbpp/736", "completion": "def left_insertion(arr, x):\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left"}
{"task_id": "Mbpp/737", "completion": "\n    import re\n\n    def check_str(string):\n        pattern = r'^[aeiouAEIOU]'\n        return bool(re.match(pattern, string))\n\n    assert check_str(\"annie\")\n    ```\n\n    The `check_str` function uses the `re.match` function to check if the given string starts with a vowel. The pattern `r'^[aeiouAEIOU]'` matches any string that starts with a vowel (case-insensitive). The function returns `True` if the string matches the pattern, and `False` otherwise. The assertion at the end of the script ensures that the function correctly identifies the string \"annie\" as starting with a vowel."}
{"task_id": "Mbpp/739", "completion": "\n    def find_Index(n):\n        index = 1\n        triangular_number = 1\n        while len(str(triangular_number)) < n:\n            index += 1\n            triangular_number += index\n        return index\n    ```\n    The `find_Index` function iterates through the triangular numbers until it finds the first one with n digits. It returns the index of the smallest triangular number with n digits."}
{"task_id": "Mbpp/740", "completion": "def tuple_to_dict(tup):\n    return dict(zip(tup[::2], tup[1::2]))"}
{"task_id": "Mbpp/79", "completion": "\n    def word_len(word):\n        return len(word) % 2 != 0\n    ```\n    The `word_len` function takes a word as input and returns `True` if the length of the word is odd, and `False` otherwise. This solution uses the modulo operator to check if the length of the word is odd."}
{"task_id": "Mbpp/741", "completion": "\n    def all_Characters_Same(string):\n        return len(set(string)) == 1\n    ```\n    The `all_Characters_Same` function takes a string as input and uses a set to check if all characters are the same. If the length of the set is 1, all characters are the same, and the function returns True. Otherwise, it returns False."}
{"task_id": "Mbpp/742", "completion": "\n    import math\n\n    def area_tetrahedron(edge):\n        return math.sqrt(3) * edge ** 2\n\n    assert area_tetrahedron(3)==15.588457268119894\n    ```"}
{"task_id": "Mbpp/743", "completion": "def rotate_right(lst, n):\n    return lst[-n:] + lst[:-n]"}
{"task_id": "Mbpp/744", "completion": "\n    def check_none(tuple_input):\n        return any(value is None for value in tuple_input)\n    ```\n    The `check_none` function takes a tuple as input and uses the `any` function to check if any value in the tuple is None. If any value is None, the function returns True; otherwise, it returns False."}
{"task_id": "Mbpp/745", "completion": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all(num % int(digit) == 0 for digit in str(num)):\n            result.append(num)\n    return result\n\nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"}
{"task_id": "Mbpp/746", "completion": "import math\n\ndef sector_area(radius, angle):\n    if angle > 360:\n        return None\n    else:\n        return (angle / 360) * math.pi * radius ** 2"}
{"task_id": "Mbpp/748", "completion": "def capital_words_spaces(string):\n    words = string.split()\n    new_string = ''\n    for word in words:\n        if word[0].isupper():\n            new_string += ' ' + word\n        else:\n            new_string += word\n    return new_string.strip()"}
{"task_id": "Mbpp/749", "completion": "def sort_numeric_strings(num_strings):\n    num_strings = [int(num) for num in num_strings]\n    num_strings.sort()\n    return num_strings"}
{"task_id": "Mbpp/750", "completion": "def add_tuple(lst, tpl):\n    return lst + list(tpl)"}
{"task_id": "Mbpp/751", "completion": "def check_min_heap(arr):\n    n = len(arr)\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and arr[i] > arr[left]:\n            return False\n        if right < n and arr[i] > arr[right]:\n            return False\n    return True"}
{"task_id": "Mbpp/80", "completion": "\n    def tetrahedral_number(n):\n        return n * (n + 1) * (n + 2) // 6\n    ```\n    The `tetrahedral_number` function takes an integer `n` as input and returns the nth tetrahedral number. The formula for calculating the nth tetrahedral number is `n * (n + 1) * (n + 2) // 6`, which is then returned as the result."}
{"task_id": "Mbpp/752", "completion": "\n    def jacobsthal_num(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return jacobsthal_num(n-1) + 2 * jacobsthal_num(n-2)\n    ```\n    The `jacobsthal_num` function uses a recursive approach to calculate the nth Jacobsthal number. It first checks for the base cases of 0 and 1 and returns the corresponding values. For any other value of n, it recursively calculates the Jacobsthal number using the formula: `jacobsthal_num(n) = jacobsthal_num(n-1) + 2 * jacobsthal_num(n-2)`. This solution satisfies the given assertion."}
{"task_id": "Mbpp/753", "completion": "\n    def min_k(records, k):\n        sorted_records = sorted(records, key=lambda x: x[1])\n        return sorted_records[:k]\n    ```\n\n    The `min_k` function takes a list of tuples `records` and an integer `k` as input. It sorts the list of tuples based on the second element of each tuple using the `sorted` function with a custom key function that sorts based on the second element. Finally, it returns the first `k` elements of the sorted list, which represent the minimum `k` records."}
{"task_id": "Mbpp/754", "completion": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"}
{"task_id": "Mbpp/755", "completion": "def second_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None"}
{"task_id": "Mbpp/757", "completion": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count\n\n# Test the function\nassert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])== 2"}
{"task_id": "Mbpp/758", "completion": "def unique_sublists(lst):\n    unique_sublists = {}\n    for sublist in lst:\n        if tuple(sublist) in unique_sublists:\n            unique_sublists[tuple(sublist)] += 1\n        else:\n            unique_sublists[tuple(sublist)] = 1\n    return unique_sublists"}
{"task_id": "Mbpp/759", "completion": "import re\n\ndef is_decimal(string):\n    pattern = r'^\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, string))\n\n# Test the function\nassert is_decimal('123.11')==True"}
{"task_id": "Mbpp/760", "completion": "\n    def unique_Element(nums):\n        return len(set(nums)) == 1\n    ```\n    The `unique_Element` function takes a list of numbers `nums` as input and returns `True` if the list contains only one distinct element, and `False` otherwise. It does this by creating a set of the input list and checking if the length of the set is equal to 1. If the length is 1, it means that all elements in the list are the same, and the function returns `True`. Otherwise, it returns `False`."}
{"task_id": "Mbpp/762", "completion": "\n    def check_monthnumber_number(month_number):\n        if month_number in [4, 6, 9, 11]:\n            return True\n        elif month_number == 2:\n            return False  # February has 28 or 29 days\n        else:\n            return False\n    ```\n    The `check_monthnumber_number` function takes a month number as input and returns True if the month contains 30 days, False otherwise. It checks for months with 30 days and February separately."}
{"task_id": "Mbpp/763", "completion": "\n    def find_min_diff(arr, n):\n        arr.sort()\n        min_diff = float('inf')\n        for i in range(1, n):\n            diff = arr[i] - arr[i-1]\n            if diff < min_diff:\n                min_diff = diff\n        return min_diff\n    ```\n    The `find_min_diff` function first sorts the input array `arr`. Then, it iterates through the sorted array to find the minimum difference between any two consecutive elements. Finally, it returns the minimum difference found."}
{"task_id": "Mbpp/82", "completion": "\n    import math\n\n    def volume_sphere(radius):\n        return (4/3) * math.pi * (radius ** 3)\n\n    # Test the function\n    assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)\n    ```\n\n    The `volume_sphere` function takes the radius of a sphere as input and returns its volume using the formula for the volume of a sphere. The assertion at the end of the script tests the function with the given radius and expected volume."}
{"task_id": "Mbpp/764", "completion": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count"}
{"task_id": "Mbpp/765", "completion": "\n    def is_polite(n):\n        polite_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        if n <= len(polite_numbers):\n            return polite_numbers[n-1]\n        else:\n            for i in range(len(polite_numbers), n+1):\n                polite_numbers.append(i)\n            return polite_numbers[n-1]\n    ```\n    The `is_polite` function first checks if the input `n` is less than or equal to the length of the list of polite numbers. If so, it returns the nth polite number from the list. If not, it iterates through the list to find the nth polite number and appends it to the list. Finally, it returns the nth polite number."}
{"task_id": "Mbpp/766", "completion": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]"}
{"task_id": "Mbpp/767", "completion": "\n    def get_pairs_count(nums, target):\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    count += 1\n        return count\n    ```\n    The `get_pairs_count` function iterates through the list of numbers and for each pair of numbers, it checks if their sum is equal to the target. If a pair is found, the count is incremented. Finally, the function returns the total count of pairs whose sum is equal to the target."}
{"task_id": "Mbpp/769", "completion": "\n    def Diff(list1, list2):\n        return list(set(list1) - set(list2))\n    ```\n    The `Diff` function takes two lists as input and returns the difference between the two lists. It uses the `set` data type to efficiently find the difference between the two lists. The `assert` statement checks the correctness of the `Diff` function by comparing its output with the expected result."}
{"task_id": "Mbpp/770", "completion": "\n    def odd_num_sum(n):\n        return sum(i ** 4 for i in range(1, 2 * n, 2))\n    ```\n    The `odd_num_sum` function takes an integer `n` as input and returns the sum of the fourth power of the first `n` odd natural numbers. It uses a generator expression to calculate the sum of the fourth power of the odd numbers up to the specified limit."}
{"task_id": "Mbpp/771", "completion": "\n    def check_expression(expression):\n        stack = []\n        brackets = {')': '(', ']': '[', '}': '{'}\n        for char in expression:\n            if char in brackets.values():\n                stack.append(char)\n            elif char in brackets.keys():\n                if not stack or brackets[char] != stack.pop():\n                    return False\n        return not stack\n    ```\n    The `check_expression` function uses a stack to keep track of opening brackets and checks if the closing brackets match the corresponding opening brackets. If the expression is balanced, the function returns True; otherwise, it returns False."}
{"task_id": "Mbpp/772", "completion": "def remove_length(string, k):\n    words = string.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)"}
{"task_id": "Mbpp/773", "completion": "def occurance_substring(string, substring):\n    if substring in string:\n        start = string.find(substring)\n        end = start + len(substring)\n        return substring, start, end\n    else:\n        return None"}
{"task_id": "Mbpp/775", "completion": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))"}
{"task_id": "Mbpp/83", "completion": "\n    def get_Char(string):\n        total = sum(ord(char) for char in string)\n        return chr((total % 26) + ord('a'))\n    ```\n    The `get_Char` function takes a string as input and calculates the sum of the ASCII values of its characters. It then returns the character corresponding to the sum modulo 26, which is added to the ASCII value of 'a' to obtain the final character. This solution satisfies the given assertion."}
{"task_id": "Mbpp/777", "completion": "def find_sum(lst):\n    unique_elements = set()\n    total_sum = 0\n    for num in lst:\n        if num not in unique_elements:\n            unique_elements.add(num)\n            total_sum += num\n    return total_sum"}
{"task_id": "Mbpp/778", "completion": "def pack_consecutive_duplicates(lst):\n    result = []\n    current_sublist = []\n    for i in range(len(lst)):\n        if not current_sublist or lst[i] != lst[i-1]:\n            if current_sublist:\n                result.append(current_sublist)\n            current_sublist = [lst[i]]\n        else:\n            current_sublist.append(lst[i])\n    if current_sublist:\n        result.append(current_sublist)\n    return result"}
{"task_id": "Mbpp/780", "completion": "from itertools import combinations\n\ndef find_combinations(tuple_list):\n    result = []\n    for i in range(1, len(tuple_list) + 1):\n        for combination in combinations(tuple_list, i):\n            result.append(tuple(sum(x) for x in zip(*combination)))\n    return result"}
{"task_id": "Mbpp/781", "completion": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0"}
{"task_id": "Mbpp/782", "completion": "def odd_length_sum(arr):\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        for j in range(i, n, 2):\n            total_sum += sum(arr[i:j+1])\n    return total_sum"}
{"task_id": "Mbpp/783", "completion": "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    cmax = max(r, g, b)\n    cmin = min(r, g, b)\n    delta = cmax - cmin\n    if delta == 0:\n        h = 0\n    elif cmax == r:\n        h = 60 * (((g - b) / delta) % 6)\n    elif cmax == g:\n        h = 60 * (((b - r) / delta) + 2)\n    else:\n        h = 60 * (((r - g) / delta) + 4)\n    if cmax == 0:\n        s = 0\n    else:\n        s = delta / cmax\n    v = cmax * 100\n    return h, s, v"}
{"task_id": "Mbpp/784", "completion": "\n    def mul_even_odd(lst):\n        even_num = None\n        odd_num = None\n        for num in lst:\n            if num % 2 == 0:\n                if even_num is None or num < even_num:\n                    even_num = num\n            else:\n                if odd_num is None or num < odd_num:\n                    odd_num = num\n        if even_num is not None and odd_num is not None:\n            return even_num * odd_num\n        else:\n            return None\n    ```\n    The `mul_even_odd` function iterates through the list and finds the first even and odd numbers. It then returns the product of these numbers, or `None` if either of them is not found."}
{"task_id": "Mbpp/785", "completion": "def tuple_str_int(tuple_str):\n    # Remove the leading and trailing parentheses and split the string by commas\n    tuple_elements = tuple_str[1:-1].split(\", \")\n    # Convert each element to an integer and create a tuple\n    int_tuple = tuple(int(element) for element in tuple_elements)\n    return int_tuple"}
{"task_id": "Mbpp/786", "completion": "def right_insertion(arr, value):\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] < value:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left"}
{"task_id": "Mbpp/787", "completion": "import re\n\ndef text_match_three(text):\n    pattern = r'ab{3}'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n# Test cases\nassert text_match_three(\"abbb\")\nassert not text_match_three(\"ac\")"}
{"task_id": "Mbpp/84", "completion": "\n    def newman_conway(n):\n        if n <= 0:\n            return \"Invalid input: n must be a positive integer\"\n        elif n == 1:\n            return \"1\"\n        else:\n            sequence = [1, 1]\n            for i in range(2, n):\n                sequence.append(sequence[sequence[i-1]-1] + sequence[i-sequence[i-1]-1])\n            return \" \".join(map(str, sequence))\n    ```\n    The `newman_conway` function takes an integer `n` as input and returns the nth number in the newman conway sequence. It first checks if the input is valid (positive integer), and then constructs the sequence using a list and appends the next number based on the previous two numbers. Finally, it returns the sequence as a string with spaces between the numbers."}
{"task_id": "Mbpp/788", "completion": "def new_tuple(lst, str):\n    return tuple(lst + [str])"}
{"task_id": "Mbpp/790", "completion": "\n    def even_position(lst):\n        return all(lst[i] % 2 == 0 for i in range(0, len(lst), 2))\n    ```\n    The `even_position` function takes a list `lst` as input and uses a generator expression to check if every even index contains an even number. It then returns `True` if all conditions are met, and `False` otherwise."}
{"task_id": "Mbpp/791", "completion": "def remove_nested(tup):\n    result = []\n    for item in tup:\n        if isinstance(item, tuple):\n            result.extend(remove_nested(item))\n        else:\n            result.append(item)\n    return tuple(result)"}
{"task_id": "Mbpp/792", "completion": "\n    def count_list(lists):\n        count = 0\n        for lst in lists:\n            if isinstance(lst, list):\n                count += 1\n        return count\n    ```\n    The `count_list` function iterates through the input list and increments the count for each list it encounters. It then returns the total count of lists."}
{"task_id": "Mbpp/793", "completion": "def last(arr, x):\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right"}
{"task_id": "Mbpp/794", "completion": "import re\n\ndef text_starta_endb(text):\n    pattern = r'a.*b$'\n    return bool(re.match(pattern, text))\n\n# Test the function\nassert text_starta_endb(\"aabbbb\")"}
{"task_id": "Mbpp/796", "completion": "\n    def return_sum(dictionary):\n        return sum(dictionary.values())\n    ```\n\n    The `return_sum` function takes a dictionary as input and returns the sum of all its values. The `sum` function is used to calculate the sum of the values in the dictionary."}
{"task_id": "Mbpp/797", "completion": "\n    def sum_in_range(l, r):\n        return sum(range(l, r+1, 2))\n    ```\n    The `sum_in_range` function takes two arguments `l` and `r`, representing the lower and upper bounds of the range. It then uses the `sum` function to calculate the sum of all odd natural numbers within the range. The `range` function is used to generate a sequence of odd numbers within the specified range, and the `sum` function is used to calculate the sum of these numbers. The assertion provided in the problem description is then checked using the `assert` statement."}
{"task_id": "Mbpp/798", "completion": "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total"}
{"task_id": "Mbpp/799", "completion": "\n    def left_rotate(num, d):\n        # Convert the number to binary representation\n        binary_num = bin(num)[2:].zfill(32)\n        # Rotate the bits to the left\n        rotated_bits = binary_num[d:] + binary_num[:d]\n        # Convert the rotated bits back to decimal\n        rotated_num = int(rotated_bits, 2)\n        return rotated_num\n    ```\n    The `left_rotate` function takes a number `num` and a rotation amount `d` as input. It converts the number to binary representation, rotates the bits to the left by `d` positions, and then converts the rotated bits back to decimal. The rotated number is then returned as the output."}
{"task_id": "Mbpp/85", "completion": "\n    import math\n\n    def surfacearea_sphere(radius):\n        return 4 * math.pi * radius ** 2\n\n    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)\n    ```\n\n    The `surfacearea_sphere` function calculates the surface area of a sphere using the formula `4 * math.pi * radius ** 2`. The assertion verifies that the function returns the correct surface area for a sphere with radius 10."}
{"task_id": "Mbpp/800", "completion": "def remove_all_spaces(string):\n    return string.replace(' ', '')"}
{"task_id": "Mbpp/801", "completion": "\n    def test_three_equal(a, b, c):\n        if a == b == c:\n            return 3\n        elif a == b or b == c or a == c:\n            return 2\n        else:\n            return 0\n    ```\n    The `test_three_equal` function takes three integers as input and returns the count of equal numbers. If all three numbers are equal, it returns 3. If two numbers are equal, it returns 2. Otherwise, it returns 0."}
{"task_id": "Mbpp/803", "completion": "\n    import math\n\n    def is_perfect_square(num):\n        if num < 0:\n            return False\n        sqrt_num = int(math.sqrt(num))\n        return sqrt_num * sqrt_num == num\n    ```\n\n    The `is_perfect_square` function takes a number `num` as input and returns `True` if the number is a perfect square, and `False` otherwise. It first checks if the number is negative, and then calculates the square root of the number using the `math.sqrt` function. If the square of the square root is equal to the original number, it returns `True`, indicating that the number is a perfect square. Otherwise, it returns `False`."}
{"task_id": "Mbpp/804", "completion": "def is_product_even(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "completion": "def max_sum_list(lst):\n    max_sum = 0\n    max_list = []\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_list = sublist\n    return max_list"}
{"task_id": "Mbpp/806", "completion": "def max_run_uppercase(string):\n    max_run = 0\n    current_run = 0\n    for char in string:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    return max_run"}
{"task_id": "Mbpp/807", "completion": "def first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None  # If no odd number is found"}
{"task_id": "Mbpp/808", "completion": "\n    def check_K(tuple_input, k):\n        return k in tuple_input\n    ```\n\n    The `check_K` function takes two arguments: `tuple_input` and `k`. It checks if the `k` is present in the `tuple_input` using the `in` operator and returns `True` if it is present, and `False` otherwise."}
{"task_id": "Mbpp/809", "completion": "\n    def check_smaller(tuple1, tuple2):\n        for i in range(len(tuple1)):\n            if tuple1[i] >= tuple2[i]:\n                return False\n        return True\n    ```\n    The `check_smaller` function takes two tuples as input and iterates through each element of the second tuple. If an element is found to be greater than or equal to the corresponding element in the first tuple, the function returns False. If all elements in the second tuple are smaller than their corresponding elements in the first tuple, the function returns True."}
{"task_id": "Mbpp/7", "completion": "\n    def find_char_long(string):\n        words = string.split()\n        result = [word for word in words if len(word) >= 4]\n        return result\n    ```\n    The `find_char_long` function takes a string as input and splits it into words. It then filters the words based on their length and returns the list of words that are at least 4 characters long. The assert statement checks if the function's output matches the expected result."}
{"task_id": "Mbpp/86", "completion": "def centered_hexagonal_number(n):\n    return (6 * n * (n - 1) + 1)"}
{"task_id": "Mbpp/87", "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    for d in (dict1, dict2, dict3):\n        merged_dict.update(d)\n    return merged_dict"}
{"task_id": "Mbpp/88", "completion": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"task_id": "Mbpp/89", "completion": "\n    def closest_num(n):\n        if n < 10:\n            return 0\n        else:\n            return int(str(n)[:-1])\n    ```\n    The `closest_num` function takes an integer `n` as input and returns the closest smaller number than `n`. If `n` is less than 10, it returns 0. Otherwise, it returns the integer obtained by removing the last digit from the string representation of `n`."}
{"task_id": "Mbpp/90", "completion": "\n    def len_log(words):\n        return max(len(word) for word in words)\n    ```\n    The `len_log` function takes a list of words as input and uses a generator expression to find the length of the longest word. It then returns the maximum length found."}
{"task_id": "Mbpp/91", "completion": "def find_substring(lst, substring):\n    for item in lst:\n        if substring in item:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "completion": "\n    def is_undulating(num):\n        num_str = str(num)\n        for i in range(1, len(num_str) - 1):\n            if num_str[i] != num_str[i-1] and num_str[i] != num_str[i+1]:\n                return False\n        return True\n    ```\n    The `is_undulating` function takes a number as input and checks if it is undulating by iterating through the digits and ensuring that each digit is different from its adjacent digits. If the condition is met for all digits, the function returns True, indicating that the number is undulating. Otherwise, it returns False."}
{"task_id": "Mbpp/93", "completion": "\n    def power(a, b):\n        return a ** b\n    ```\n    The `power` function takes two parameters `a` and `b` and returns the value of `a` raised to the power `b`. This solution satisfies the given assertion."}
{"task_id": "Mbpp/94", "completion": "def index_minimum(tuples):\n    min_value = float('inf')\n    min_index = None\n    for i, (_, value) in enumerate(tuples):\n        if value < min_value:\n            min_value = value\n            min_index = i\n    return tuples[min_index][0]"}
{"task_id": "Mbpp/95", "completion": "\n    def Find_Min_Length(list_of_lists):\n        min_length = float('inf')\n        for sublist in list_of_lists:\n            min_length = min(min_length, len(sublist))\n        return min_length\n    ```\n\n    The `Find_Min_Length` function iterates through the list of lists and finds the length of the smallest list. It initializes `min_length` to infinity and then updates it with the length of each sublist as it iterates through the list. Finally, it returns the minimum length found."}
{"task_id": "Mbpp/8", "completion": "\n    def square_nums(nums):\n        return [num ** 2 for num in nums]\n    ```\n    The `square_nums` function takes a list of numbers as input and returns a new list containing the squares of each number in the input list. The `assert` statement checks if the function correctly squares the numbers in the input list."}
{"task_id": "Mbpp/96", "completion": "\n    def divisor(n):\n        count = 0\n        for i in range(1, n+1):\n            if n % i == 0:\n                count += 1\n        return count\n    ```\n    The `divisor` function takes an integer `n` as input and returns the number of divisors of `n`. It iterates through all the numbers from 1 to `n` and checks if each number is a divisor of `n`. If it is, the count is incremented. Finally, the function returns the count of divisors."}
{"task_id": "Mbpp/97", "completion": "\n    def frequency_lists(flattened_list):\n        frequency_dict = {}\n        for sublist in flattened_list:\n            for element in sublist:\n                if element in frequency_dict:\n                    frequency_dict[element] += 1\n                else:\n                    frequency_dict[element] = 1\n        return frequency_dict\n    ```\n\n    The `frequency_lists` function takes a flattened list of lists as input and returns a dictionary containing the frequency of each element in the flattened list. It iterates through the sublists and elements, updating the frequency count in the frequency dictionary. Finally, it returns the frequency dictionary."}
{"task_id": "Mbpp/98", "completion": "import math\n\ndef multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n\n# Test the function\nassert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)"}
{"task_id": "Mbpp/99", "completion": "def decimal_to_binary(decimal_num):\n    binary_num = ''\n    while decimal_num > 0:\n        binary_num = str(decimal_num % 2) + binary_num\n        decimal_num //= 2\n    return binary_num"}
{"task_id": "Mbpp/100", "completion": "def next_smallest_palindrome(n):\n    while True:\n        n += 1\n        if str(n) == str(n)[::-1]:\n            return n"}
{"task_id": "Mbpp/101", "completion": "def kth_element(arr, k):\n    arr.sort()  # Sort the array in ascending order\n    return arr[k-1]  # Return the kth element (1-based indexing)"}
{"task_id": "Mbpp/102", "completion": "def snake_to_camel(snake_str):\n    words = snake_str.split('_')\n    camel_str = ''.join(word.capitalize() for word in words)\n    return camel_str"}
{"task_id": "Mbpp/103", "completion": "\n    def eulerian_num(n, m):\n        if n == 0:\n            return 1\n        elif m == 0:\n            return 0\n        else:\n            return (n - m) * eulerian_num(n - 1, m) + eulerian_num(n, m - 1)\n    ```\n    The `eulerian_num` function uses a recursive approach to calculate the Eulerian number a(n, m). It satisfies the assertion by returning the correct value for the given input."}
{"task_id": "Mbpp/104", "completion": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/105", "completion": "\n    def count(lst):\n        return sum(1 for x in lst if x)\n    ```\n    The `count` function takes a list `lst` as input and uses a generator expression to count the number of true booleans in the list. It then returns the sum of the generator expression, which effectively counts the number of true booleans in the list."}
{"task_id": "Mbpp/9", "completion": "\n    def find_Rotations(s):\n        n = len(s)\n        for i in range(1, n):\n            if s[i:] + s[:i] == s:\n                return i\n        return 0\n    ```\n    The `find_Rotations` function takes a string `s` as input and returns the minimum number of rotations required to get the same string. It iterates through all possible rotations of the string and checks if the rotation is the same as the original string. If a rotation is found, the function returns the number of rotations required. If no rotation is found, the function returns 0."}
{"task_id": "Mbpp/106", "completion": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)"}
{"task_id": "Mbpp/108", "completion": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list"}
{"task_id": "Mbpp/109", "completion": "\n    def odd_Equivalent(binary_string, rotations):\n        binary_string = binary_string * rotations\n        count = 0\n        for i in range(len(binary_string)):\n            if int(binary_string[i]) % 2 == 1:\n                count += 1\n        return count\n    ```\n    The `odd_Equivalent` function takes a binary string and the number of rotations as input. It then calculates the number of numbers with an odd value when rotating the binary string the given number of times. The function iterates through the rotated binary string and counts the numbers with an odd value. Finally, it returns the count of odd numbers."}
{"task_id": "Mbpp/111", "completion": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements = common_elements.intersection(set(lst))\n    return list(common_elements)"}
{"task_id": "Mbpp/113", "completion": "def check_integer(string):\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/115", "completion": "def empty_dit(lst):\n    return all(not d for d in lst)"}
{"task_id": "Mbpp/116", "completion": "\n    def tuple_to_int(t):\n        return int(''.join(map(str, t)))\n    ```\n    The `tuple_to_int` function takes a tuple `t` as input and uses the `int` function to convert the tuple elements into a single integer. The `map` function is used to convert each element of the tuple into a string, and then the `join` method is used to concatenate the strings into a single string. Finally, the `int` function is used to convert the concatenated string into an integer and return it."}
{"task_id": "Mbpp/117", "completion": "def list_to_float(lst):\n    return [tuple(map(float, sublist)) for sublist in lst]"}
{"task_id": "Mbpp/118", "completion": "def string_to_list(input_string):\n    return input_string.split()"}
{"task_id": "Mbpp/119", "completion": "\n    def search(arr):\n        left = 0\n        right = len(arr) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] == arr[mid - 1]:\n                if mid % 2 == 0:\n                    right = mid - 2\n                else:\n                    left = mid + 1\n            elif arr[mid] == arr[mid + 1]:\n                if mid % 2 == 0:\n                    left = mid + 2\n                else:\n                    right = mid - 1\n            else:\n                return arr[mid]\n        return arr[left]\n    ```\n\n    The `search` function uses binary search to find the element that appears only once in the sorted array. It iterates through the array, comparing the middle element with its neighbors. If the middle element is the same as its neighbor, it adjusts the search range based on the parity of the middle index. If the middle element is different from its neighbors, it returns the middle element as the element that appears only once."}
{"task_id": "Mbpp/11", "completion": "def remove_Occ(string, char):\n    if char in string:\n        first_index = string.index(char)\n        last_index = string.rindex(char)\n        return string[:first_index] + string[last_index+1:]\n    else:\n        return string"}
{"task_id": "Mbpp/120", "completion": "def max_product_tuple(lst):\n    max_product = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            product = abs(lst[i][0] * lst[j][0]) * abs(lst[i][1] * lst[j][1])\n            if product > max_product:\n                max_product = product\n    return max_product"}
{"task_id": "Mbpp/123", "completion": "\n    def is_amicable(n):\n        def sum_of_divisors(num):\n            divisors_sum = 0\n            for i in range(1, int(num**0.5) + 1):\n                if num % i == 0:\n                    divisors_sum += i\n                    if i != num // i:\n                        divisors_sum += num // i\n            return divisors_sum - num\n\n        def is_amicable_pair(a, b):\n            return sum_of_divisors(a) == b and sum_of_divisors(b) == a and a != b\n\n        amicable_sum = 0\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if is_amicable_pair(i, j):\n                    amicable_sum += i + j\n        return amicable_sum\n\n    assert amicable_numbers_sum(999)==504\n    ```"}
{"task_id": "Mbpp/124", "completion": "\n    import cmath\n    import math\n\n    def angle_complex(z):\n        return cmath.phase(z)\n\n    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n    ```\n\n    The `angle_complex` function takes a complex number `z` as input and uses the `cmath.phase` function to calculate the angle of the complex number. The assertion at the end verifies that the function returns the correct angle for the given complex number."}
{"task_id": "Mbpp/125", "completion": "def find_length(binary_string):\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n    for char in binary_string:\n        if char == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        diff = abs(count_0 - count_1)\n        max_diff = max(max_diff, diff)\n    return max_diff"}
{"task_id": "Mbpp/126", "completion": "def sum_common_divisors(num1, num2):\n    common_divisors = set()\n    for i in range(1, min(num1, num2) + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            common_divisors.add(i)\n    return sum(common_divisors)\n\n# Test the function\nassert sum_common_divisors(10, 15) == 6"}
{"task_id": "Mbpp/127", "completion": "def multiply_int(a, b):\n    return a * b\n\nassert multiply_int(10, 20) == 200"}
{"task_id": "Mbpp/128", "completion": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]"}
{"task_id": "Mbpp/129", "completion": "\n    def magic_square_test(matrix):\n        n = len(matrix)\n        # Check if the matrix is a square\n        if len(matrix) != len(matrix[0]):\n            return False\n        \n        # Calculate the sum of the first row\n        row_sum = sum(matrix[0])\n        \n        # Check if the sum of each row is equal to the row_sum\n        for row in matrix:\n            if sum(row) != row_sum:\n                return False\n        \n        # Check if the sum of each column is equal to the row_sum\n        for i in range(n):\n            col_sum = 0\n            for j in range(n):\n                col_sum += matrix[j][i]\n            if col_sum != row_sum:\n                return False\n        \n        # Check if the sum of the diagonals is equal to the row_sum\n        diag_sum1 = 0\n        diag_sum2 = 0\n        for i in range(n):\n            diag_sum1 += matrix[i][i]\n            diag_sum2 += matrix[i][n-i-1]\n        if diag_sum1 != row_sum or diag_sum2 != row_sum:\n            return False\n        \n        return True\n    ```\n    This solution defines a function `magic_square_test` that takes a matrix as input and checks if it is a magic square. It first checks if the matrix is a square and then calculates the sum of the first row. It then iterates through each row, column, and diagonal to ensure that the sums are equal to the row_sum. If all checks pass, the function returns True, indicating that the matrix is a magic square."}
{"task_id": "Mbpp/130", "completion": "def max_occurrences(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    max_freq = max(freq.values())\n    for item, count in freq.items():\n        if count == max_freq:\n            return item"}
{"task_id": "Mbpp/131", "completion": "\n    def reverse_vowels(s):\n        vowels = set('aeiouAEIOU')\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return ''.join(s)\n    ```\n    The `reverse_vowels` function takes a string `s` as input and reverses only the vowels of the string. It uses two pointers `i` and `j` to traverse the string from both ends, swapping vowels encountered at both ends until the pointers meet in the middle. The function then returns the modified string."}
{"task_id": "Mbpp/12", "completion": "\n    def sort_matrix(matrix):\n        # Calculate the sum of each row\n        row_sums = [sum(row) for row in matrix]\n        \n        # Sort the matrix based on the row sums\n        sorted_matrix = [x for _, x in sorted(zip(row_sums, matrix))]\n        \n        return sorted_matrix\n    ```\n    The `sort_matrix` function first calculates the sum of each row in the input matrix. It then uses the `sorted` function to sort the matrix based on the row sums. Finally, it returns the sorted matrix."}
{"task_id": "Mbpp/132", "completion": "def tup_string(tup):\n    return ''.join(tup)\n\nassert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")"}
{"task_id": "Mbpp/133", "completion": "def sum_negativenum(numbers):\n    return sum(num for num in numbers if num < 0)"}
{"task_id": "Mbpp/135", "completion": "\n    def hexagonal_num(n):\n        return n * (2 * n - 1)\n    ```\n    The `hexagonal_num` function takes an integer `n` as input and returns the nth hexagonal number. The hexagonal number is defined as the sum of the first n natural numbers, which is equal to n(2n-1)."}
{"task_id": "Mbpp/137", "completion": "import math\n\ndef zero_count(arr):\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count\n\nassert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)"}
{"task_id": "Mbpp/138", "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0:\n        return True\n    while n > 0:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            return False\n    return True"}
{"task_id": "Mbpp/139", "completion": "\n    import math\n\n    def circle_circumference(radius):\n        return 2 * math.pi * radius\n\n    assert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)\n    ```\n\n    The `circle_circumference` function takes the radius of a circle as input and returns its circumference. The `assert` statement checks if the calculated circumference is within a relative tolerance of 0.001 from the expected value."}
{"task_id": "Mbpp/140", "completion": "def extract_singly(list_of_lists):\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n    return flattened_list"}
{"task_id": "Mbpp/141", "completion": "\n    def pancake_sort(arr):\n        def flip(arr, k):\n            i = 0\n            while i < k:\n                arr[i], arr[k] = arr[k], arr[i]\n                i += 1\n                k -= 1\n\n        def find_max(arr, n):\n            mi = 0\n            for i in range(n):\n                if arr[i] > arr[mi]:\n                    mi = i\n            return mi\n\n        n = len(arr)\n        current_size = n\n        while current_size > 1:\n            mi = find_max(arr, current_size)\n            if mi != current_size - 1:\n                flip(arr, mi)\n                flip(arr, current_size - 1)\n            current_size -= 1\n        return arr\n    ```\n\n    The `pancake_sort` function first defines a `flip` function to reverse the order of the first `k` elements in the array. It then defines a `find_max` function to find the index of the maximum element in the array. The main `pancake_sort` function then iterates through the array, finding the maximum element and flipping it to the end of the array. This process is repeated until the array is sorted."}
{"task_id": "Mbpp/142", "completion": "\n    def count_samepair(list1, list2, list3):\n        count = 0\n        for i in range(len(list1)):\n            if list1[i] == list2[i] == list3[i]:\n                count += 1\n        return count\n    ```\n    The `count_samepair` function takes three lists as input and iterates through each list simultaneously, comparing the elements at the same index. If the elements are identical, it increments the count. Finally, it returns the count of identical elements in the same position of the three lists."}
{"task_id": "Mbpp/143", "completion": "def find_lists(tuple_input):\n    count = 0\n    for item in tuple_input:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"task_id": "Mbpp/14", "completion": "\n    def find_Volume(base, height, length):\n        volume = (base * height * length) / 2\n        return volume\n    ```\n\n    The `find_Volume` function takes three parameters: `base`, `height`, and `length`. It calculates the volume of a triangular prism using the formula `(base * height * length) / 2` and returns the result. The assertion in the problem description ensures that the function correctly calculates the volume of a triangular prism with the given dimensions."}
{"task_id": "Mbpp/145", "completion": "def max_Abs_Diff(arr):\n    arr = sorted(arr)\n    max_diff = 0\n    for i in range(len(arr)-1):\n        diff = abs(arr[i] - arr[i+1])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"}
{"task_id": "Mbpp/160", "completion": "def find_solution(a, b, n):\n    if b == 0:\n        if n % a == 0:\n            return (n // a, 0)\n        else:\n            return None\n    else:\n        x, y = find_solution(b, n % b, a)\n        return (y, x - (n // b) * y)"}
{"task_id": "Mbpp/161", "completion": "def remove_elements(lst1, lst2):\n    return [x for x in lst1 if x not in lst2]"}
{"task_id": "Mbpp/162", "completion": "\n    def sum_series(n):\n        total = 0\n        for i in range(0, n // 2 + 1):\n            total += n - 2 * i\n        return total\n    ```\n    The `sum_series` function iterates through the range of numbers from 0 to n // 2 and calculates the sum of the series (n - 2*i) for each value of i. It then returns the total sum."}
{"task_id": "Mbpp/164", "completion": "def are_equivalent(num1, num2):\n    def sum_divisors(n):\n        divisors_sum = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n\n    return sum_divisors(num1) == sum_divisors(num2)"}
{"task_id": "Mbpp/165", "completion": "def count_char_position(string):\n    count = 0\n    for i in range(len(string)):\n        if string[i].lower() == chr(97 + i):\n            count += 1\n    return count"}
{"task_id": "Mbpp/166", "completion": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/167", "completion": "def next_power_of_2(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 ** (n - 1).bit_length()"}
{"task_id": "Mbpp/168", "completion": "def frequency(lst, num):\n    return lst.count(num)"}
{"task_id": "Mbpp/170", "completion": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])"}
