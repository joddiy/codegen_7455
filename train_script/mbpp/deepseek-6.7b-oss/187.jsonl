{"task_id": "Mbpp/407", "completion": "\n```python\ndef rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    \n    # Find the rightmost digit that is smaller than the digit next to it\n    i = len(digits) - 1\n    while i > 0 and digits[i-1] >= digits[i]:\n        i -= 1\n    \n    # If no such digit is found, the number is already the biggest possible\n    if i <= 0:\n        return None\n    \n    # Find the smallest digit on the right of the found digit that is greater than it\n    j = i + 1\n    while j < len(digits) and digits[j] > digits[i-1]:\n        j += 1\n    \n    # Swap the found digits\n    digits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n    \n    # Reverse the digits after the found digit\n    digits[i:] = digits[len(digits)-1:i-1:-1]\n    \n    # Convert the list of digits back to a number\n    return int(\"\".join(digits))\n```\n\nThe `rearrange_bigger` function takes a number `n` as input and returns the next bigger number by rearranging its digits. It first converts the number to a list of digits, then finds the rightmost digit that is smaller than the digit next to it. If such a digit is found, it then finds the smallest digit on the right of the found digit that is greater than it. Finally, it swaps the found digits and reverses the digits after the found digit to create the next bigger number. If no such number can be formed, it returns `None`.", "all_code": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n\n    ### Instruction:\n    Create a Python script for this problem:\n    Write a function to create the next bigger number by rearranging the digits of a given number. Your code should satisfy the following assertion:\n```python\nassert rearrange_bigger(12)==21\n```\n\n    ### Response:\n```python\ndef rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    \n    # Find the rightmost digit that is smaller than the digit next to it\n    i = len(digits) - 1\n    while i > 0 and digits[i-1] >= digits[i]:\n        i -= 1\n    \n    # If no such digit is found, the number is already the biggest possible\n    if i <= 0:\n        return None\n    \n    # Find the smallest digit on the right of the found digit that is greater than it\n    j = i + 1\n    while j < len(digits) and digits[j] > digits[i-1]:\n        j += 1\n    \n    # Swap the found digits\n    digits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n    \n    # Reverse the digits after the found digit\n    digits[i:] = digits[len(digits)-1:i-1:-1]\n    \n    # Convert the list of digits back to a number\n    return int(\"\".join(digits))\n```\n\nThe `rearrange_bigger` function takes a number `n` as input and returns the next bigger number by rearranging its digits. It first converts the number to a list of digits, then finds the rightmost digit that is smaller than the digit next to it. If such a digit is found, it then finds the smallest digit on the right of the found digit that is greater than it. Finally, it swaps the found digits and reverses the digits after the found digit to create the next bigger number. If no such number can be formed, it returns `None`."}
