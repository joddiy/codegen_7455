{"task_id": "Mbpp/767", "completion": "\n```python\ndef get_pairs_count(nums, target_sum):\n    pairs_count = 0\n    num_counts = {}\n    \n    for num in nums:\n        complement = target_sum - num\n        if complement in num_counts:\n            pairs_count += num_counts[complement]\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    return pairs_count\n```\n\nThe `get_pairs_count` function initializes a variable `pairs_count` to 0 and a dictionary `num_counts` to store the count of each number encountered. It then iterates through the input list `nums`, calculating the complement of each number with respect to the target sum. If the complement is found in `num_counts`, it adds the count to `pairs_count`. After that, it updates the count of the current number in `num_counts`. Finally, it returns the `pairs_count`. This solution has a time complexity of O(n) and a space complexity of O(n), where n is the length of the input list.", "all_code": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n\n    ### Instruction:\n    Create a Python script for this problem:\n    Write a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,. Your code should satisfy the following assertion:\n```python\nassert get_pairs_count([1,1,1,1],2) == 6\n```\n\n    ### Response:\n```python\ndef get_pairs_count(nums, target_sum):\n    pairs_count = 0\n    num_counts = {}\n    \n    for num in nums:\n        complement = target_sum - num\n        if complement in num_counts:\n            pairs_count += num_counts[complement]\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    return pairs_count\n```\n\nThe `get_pairs_count` function initializes a variable `pairs_count` to 0 and a dictionary `num_counts` to store the count of each number encountered. It then iterates through the input list `nums`, calculating the complement of each number with respect to the target sum. If the complement is found in `num_counts`, it adds the count to `pairs_count`. After that, it updates the count of the current number in `num_counts`. Finally, it returns the `pairs_count`. This solution has a time complexity of O(n) and a space complexity of O(n), where n is the length of the input list."}
