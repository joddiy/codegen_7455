{"task_id": "Mbpp/2", "completion": "def similar_elements(list1, list2):\n    return set(list1) & set(list2)"}
{"task_id": "Mbpp/3", "completion": "\n    def is_not_prime(num):\n        if num <= 1:\n            return True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return True\n        return False\n    ```\n    The `is_not_prime` function takes a number as input and returns `True` if the number is not prime, and `False` otherwise. It checks if the number is less than or equal to 1, and if so, returns `True`. If not, it iterates through all numbers from 2 to the square root of the input number and checks if the input number is divisible by any of them. If it is, it returns `True`, indicating that the number is not prime. If the loop completes without finding a divisor, it returns `False`, indicating that the number is prime."}
{"task_id": "Mbpp/16", "completion": "\n    def text_lowercase_underscore(text):\n        return all(c.islower() or c == '_' for c in text)\n    ```\n    The `text_lowercase_underscore` function takes a string `text` as input and uses the `all` function to check if all characters in the string are either lowercase letters or underscores. If all characters satisfy this condition, the function returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/171", "completion": "\n    def perimeter_pentagon(side_length):\n        return 5 * side_length\n    ```\n\n    The perimeter of a regular pentagon is calculated by multiplying the side length by 5. This function takes the side length as input and returns the perimeter of the pentagon."}
{"task_id": "Mbpp/172", "completion": "def count_occurance(string):\n    count = 0\n    for i in range(len(string)):\n        if string[i:i+3] == 'std':\n            count += 1\n    return count"}
{"task_id": "Mbpp/222", "completion": "\n    def check_type(tuple):\n        return all(isinstance(x, type(tuple[0])) for x in tuple)\n    ```\n\n    ### Explanation:\n    The `check_type` function takes a tuple as input and uses a generator expression to check if all elements in the tuple have the same data type. It returns `True` if all elements have the same data type, and `False` otherwise."}
{"task_id": "Mbpp/223", "completion": "def is_majority(arr, n, x):\n    # Find the index of the first occurrence of x in arr\n    i = binary_search(arr, 0, n-1, x)\n    # If element is not present, return false\n    if i == -1:\n        return False\n    # Check if the element is present more than n/2 times\n    if (i + n//2 <= n-1) and arr[i + n//2] == x:\n        return True\n    else:\n        return False\n\ndef binary_search(arr, low, high, x):\n    if high >= low:\n        mid = (high + low) // 2\n        if (mid == 0 or x > arr[mid-1]) and arr[mid] == x:\n            return mid\n        elif x > arr[mid]:\n            return binary_search(arr, (mid + 1), high, x)\n        else:\n            return binary_search(arr, low, (mid -1), x)\n    return -1"}
{"task_id": "Mbpp/224", "completion": "def count_Set_Bits(num):\n    count = 0\n    while num:\n        num &= num - 1\n        count += 1\n    return count"}
{"task_id": "Mbpp/226", "completion": "def odd_values_string(str):  \n    result = \"\" \n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result"}
{"task_id": "Mbpp/227", "completion": "\n    def min_of_three(a, b, c):\n        return min(a, b, c)\n    ```\n\n    ### Test:\n    \n    assert min_of_three(10,20,0)==0\n    ```"}
{"task_id": "Mbpp/229", "completion": "\n    def re_arrange_array(arr, n):\n        j = 0\n        for i in range(n):\n            if arr[i] < 0:\n                arr[i], arr[j] = arr[j], arr[i]\n                j += 1\n        return arr\n    ```\n    The `re_arrange_array` function takes an array `arr` and an integer `n` as input. It iterates through the first `n` elements of the array and moves all negative elements to the beginning of the array. The function then returns the re-arranged array."}
{"task_id": "Mbpp/230", "completion": "def replace_blank(string, character):\n    return string.replace(' ', character)"}
{"task_id": "Mbpp/232", "completion": "def larg_nnum(lst, n):\n    return sorted(lst, reverse=True)[:n]"}
{"task_id": "Mbpp/17", "completion": "def square_perimeter(side_length):\n    return 4 * side_length"}
{"task_id": "Mbpp/233", "completion": "import math\n\ndef lateral_surface_cylinder(radius, height):\n    return 2 * math.pi * radius * height\n\nassert math.isclose(lateral_surface_cylinder(10, 5), 314.15000000000003, rel_tol=0.001)"}
{"task_id": "Mbpp/234", "completion": "def volume_cube(side_length):\n    return side_length ** 3\n\nassert volume_cube(3)==27"}
{"task_id": "Mbpp/235", "completion": "def even_bit_set_number(num):\n    return num | 0b10101010101010101010101010101010"}
{"task_id": "Mbpp/237", "completion": "def check_occurences(lst):\n    dct = {}\n    for tup in lst:\n        if tup in dct:\n            dct[tup] += 1\n        else:\n            dct[tup] = 1\n    return dct"}
{"task_id": "Mbpp/238", "completion": "def number_of_substrings(string):\n    count = 0\n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            if string[i:j]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/239", "completion": "def get_total_number_of_sequences(m, n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        total = 0\n        for i in range(1, m+1):\n            if i >= 2*n:\n                total += get_total_number_of_sequences(i-1, n-1)\n        return total"}
{"task_id": "Mbpp/240", "completion": "def replace_list(list1, list2):\n    list1[-1] = list2\n    return list1"}
{"task_id": "Mbpp/242", "completion": "def count_charac(string):\n    return len(string)\n\nassert count_charac(\"python programming\")==18"}
{"task_id": "Mbpp/244", "completion": "def next_Perfect_Square(n):\n    # Find the next perfect square greater than n\n    n = int(n)\n    if n < 0:\n        return \"Invalid input\"\n    else:\n        sqrt = int(n ** 0.5)\n        if sqrt ** 2 == n:\n            return (sqrt + 1) ** 2\n        else:\n            return (sqrt + 1) ** 2"}
{"task_id": "Mbpp/245", "completion": "\n    def max_sum(arr):\n        n = len(arr)\n        inc = [0] * n\n        dec = [0] * n\n\n        inc[0] = arr[0]\n        dec[n - 1] = arr[n - 1]\n\n        for i in range(1, n):\n            inc[i] = max(inc[i - 1], arr[i])\n\n        for i in range(n - 2, -1, -1):\n            dec[i] = max(dec[i + 1], arr[i])\n\n        max_sum = 0\n        for i in range(n):\n            max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n\n        return max_sum\n\n    assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n"}
{"task_id": "Mbpp/18", "completion": "def remove_dirty_chars(str1, str2):\n    return ''.join(c for c in str1 if c not in str2)"}
{"task_id": "Mbpp/247", "completion": "\n    def lps(s):\n        n = len(s)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-1, -1, -1):\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i+1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        return dp[0][n-1]\n    ```\n\n    The `lps` function takes a string `s` as input and returns the length of the longest palindromic subsequence in the string. It uses dynamic programming to solve the problem in O(n^2) time and O(n^2) space."}
{"task_id": "Mbpp/249", "completion": "def intersection_array(arr1, arr2):\n    return list(set(arr1) & set(arr2))"}
{"task_id": "Mbpp/250", "completion": "\n    def count_X(tuple, element):\n        return tuple.count(element)\n    ```\n    The `count_X` function takes in a tuple and an element and uses the `count` method to count the number of occurrences of the element in the tuple. The function then returns the count."}
{"task_id": "Mbpp/251", "completion": "def insert_element(lst, element):\n    return [element] + lst"}
{"task_id": "Mbpp/252", "completion": "\n    import cmath\n\n    def convert(complex_number):\n        return cmath.polar(complex_number)\n    ```"}
{"task_id": "Mbpp/253", "completion": "\n    def count_integer(lst):\n        count = 0\n        for i in lst:\n            if isinstance(i, int):\n                count += 1\n        return count\n    ```\n\n    The `count_integer` function takes a list `lst` as input and initializes a variable `count` to 0. It then iterates through each element in the list and checks if it is an integer using the `isinstance` function. If it is an integer, the `count` is incremented. Finally, the function returns the value of `count`."}
{"task_id": "Mbpp/255", "completion": "\n    def combinations_colors(colors, n):\n        if n == 0:\n            return [()]\n        else:\n            result = []\n            for i in range(len(colors)):\n                sub_combinations = combinations_colors(colors, n-1)\n                for combination in sub_combinations:\n                    result.append(combination + (colors[i],))\n            return result\n    ```\n    The `combinations_colors` function takes in a list of colors and a length n, and returns a list with a tuple for each combination of length n. If n is 0, it returns a list containing a single empty tuple. Otherwise, it recursively calls itself with the same list of colors and n-1, and then appends each combination with the current color to the result list."}
{"task_id": "Mbpp/256", "completion": "def count_Primes_nums(num):\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/257", "completion": "def swap_numbers(num1, num2):\n    return num2, num1"}
{"task_id": "Mbpp/259", "completion": "def maximize_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        max_value = max(tuple1[i][0], tuple2[i][0])\n        result.append((max_value, max(tuple1[i][1], tuple2[i][1])))\n    return tuple(result)"}
{"task_id": "Mbpp/19", "completion": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))"}
{"task_id": "Mbpp/260", "completion": "\n    def newman_prime(n):\n        primes = [2, 3]\n        if n <= 0:\n            return None\n        if n == 1:\n            return 2\n        if n == 2:\n            return 3\n        for i in range(3, n+1):\n            next_prime = primes[-1] + 2\n            while True:\n                is_prime = True\n                for prime in primes:\n                    if next_prime % prime == 0:\n                        is_prime = False\n                        break\n                if is_prime:\n                    primes.append(next_prime)\n                    break\n                next_prime += 2\n        return primes[n-1]\n    ```"}
{"task_id": "Mbpp/261", "completion": "\n    def division_elements(tuple1, tuple2):\n        result = tuple(a / b for a, b in zip(tuple1, tuple2))\n        return result\n    ```\n\n    ### Test:\n    \n    assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)\n    ```"}
{"task_id": "Mbpp/262", "completion": "def split_two_parts(lst, L):\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/264", "completion": "def dog_age(age):\n    return age * 7"}
{"task_id": "Mbpp/265", "completion": "def list_split(lst, n):\n    result = []\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n    return result"}
{"task_id": "Mbpp/266", "completion": "def lateralsurface_cube(side):\n    return 6 * (side ** 2)"}
{"task_id": "Mbpp/267", "completion": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n*2, 2):\n        sum += i**2\n    return sum"}
{"task_id": "Mbpp/268", "completion": "\n    def find_star_num(n):\n        if n == 1:\n            return 1\n        else:\n            return find_star_num(n-1) + n\n    ```\n\n    The function `find_star_num` takes an integer `n` as input and returns the n'th star number. If `n` is 1, the function returns 1. Otherwise, it recursively calls itself with `n-1` and adds `n` to the result."}
{"task_id": "Mbpp/269", "completion": "def ascii_value(char):\n    return ord(char)"}
{"task_id": "Mbpp/270", "completion": "\n    def sum_even_and_even_index(lst):\n        return sum(lst[::2])\n    ```\n    The `sum_even_and_even_index` function takes a list `lst` as input and returns the sum of all even numbers at even positions in the list. The `[::2]` slice notation is used to select only the even positions in the list, and the `sum` function is used to calculate the sum of the selected elements."}
{"task_id": "Mbpp/20", "completion": "\n    def is_woodall(n):\n        # Convert the number to a string and split it into digits\n        digits = [int(d) for d in str(n)]\n        \n        # Check if the number is divisible by the sum of its digits\n        return n % sum(digits) == 0\n    ```\n    The `is_woodall` function takes a number `n` as input and returns `True` if the number is woodball, and `False` otherwise. It does this by converting the number to a string and splitting it into digits, then checking if the number is divisible by the sum of its digits."}
{"task_id": "Mbpp/271", "completion": "\n    def even_Power_Sum(n):\n        sum = 0\n        for i in range(1, n+1):\n            sum += (2*i)**5\n        return sum\n    ```\n\n    The `even_Power_Sum` function takes an integer `n` as input and calculates the sum of the first `n` even natural numbers raised to the fifth power. It iterates through the range of numbers from 1 to `n`, adding the fifth power of each even number to the `sum` variable. Finally, it returns the calculated sum."}
{"task_id": "Mbpp/272", "completion": "def rear_extract(tuples):\n    return [t[2] for t in tuples]"}
{"task_id": "Mbpp/273", "completion": "def substract_elements(tuple1, tuple2):\n    result = tuple(a - b for a, b in zip(tuple1, tuple2))\n    return result"}
{"task_id": "Mbpp/274", "completion": "\n    def even_binomial_Coeff_Sum(n):\n        # Initialize the sum of even index binomial coefficients\n        sum_even = 0\n        # Iterate through the first n rows of Pascal's triangle\n        for i in range(n):\n            # Initialize the current row of Pascal's triangle\n            row = [1]\n            # Iterate through the columns of the current row\n            for j in range(1, i+1):\n                # Calculate the next binomial coefficient in the row\n                row.append(row[j-1] * (i-j+1) // j)\n            # Add the sum of even index binomial coefficients to the total sum\n            sum_even += sum(row[::2])\n        return sum_even\n    ```\n\n    This function uses dynamic programming to calculate the sum of even index binomial coefficients in O(n^2) time and O(n) space. It iterates through the first n rows of Pascal's triangle, calculating the binomial coefficients and adding the sum of even index binomial coefficients to the total sum."}
{"task_id": "Mbpp/276", "completion": "\n    import math\n\n    def volume_cylinder(radius, height):\n        return math.pi * radius**2 * height\n\n    assert math.isclose(volume_cylinder(10,5), 1570.7500000000002, rel_tol=0.001)\n    ```\n\n    The `volume_cylinder` function takes in the radius and height of a cylinder and returns the volume of the cylinder. The `assert` statement checks if the calculated volume is close to the expected value within a relative tolerance of 0.001."}
{"task_id": "Mbpp/277", "completion": "def dict_filter(dictionary, n):\n    filtered_dict = {key: value for key, value in dictionary.items() if value >= n}\n    return filtered_dict"}
{"task_id": "Mbpp/278", "completion": "def count_first_elements(tup):\n    count = 0\n    for i in tup:\n        if isinstance(i, tuple):\n            break\n        count += 1\n    return count"}
{"task_id": "Mbpp/279", "completion": "\n    def is_num_decagonal(n):\n        return n * (3 * n - 2)\n    ```\n    The function `is_num_decagonal` takes an integer `n` as input and returns the nth decagonal number, which is calculated as `n * (3 * n - 2)`. The assertion verifies that the function correctly calculates the nth decagonal number for the given input."}
{"task_id": "Mbpp/280", "completion": "\n    def sequential_search(array, element):\n        for i in range(len(array)):\n            if array[i] == element:\n                return True, i\n        return False, -1\n    ```\n\n    ### Test:\n    \n    assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)\n    ```"}
{"task_id": "Mbpp/281", "completion": "\n    def all_unique(lst):\n        return len(lst) == len(set(lst))\n    ```\n    The `all_unique` function takes a list `lst` as input and returns `True` if all elements in the list are unique, and `False` otherwise. It does this by checking if the length of the list is equal to the length of the set of the list. If the lengths are equal, all elements are unique, and the function returns `True`. Otherwise, it returns `False`."}
{"task_id": "Mbpp/56", "completion": "\n    def check(num):\n        return num == int(str(num)[::-1]) * 2 - 1\n    ```\n\n    ### Explanation:\n    The function `check` takes a number `num` as input and returns `True` if the number is one less than twice its reverse, and `False` otherwise. The assertion `assert check(70) == False` checks if the function returns `False` for the input `70`."}
{"task_id": "Mbpp/282", "completion": "def sub_list(list1, list2):\n    return [list1[i] - list2[i] for i in range(len(list1))]"}
{"task_id": "Mbpp/283", "completion": "\n    def validate(num):\n        num_str = str(num)\n        for digit in num_str:\n            if num_str.count(digit) > int(digit):\n                return False\n        return True\n    ```"}
{"task_id": "Mbpp/284", "completion": "def check_element(lst, element):\n    return all(item == element for item in lst)"}
{"task_id": "Mbpp/285", "completion": "def text_match_two_three(text):\n    import re\n    pattern = r'a(b{2,3})'\n    if re.search(pattern,  text):\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/286", "completion": "\n    def max_sub_array_sum_repeated(arr, k, n):\n        # Calculate the maximum sum of a contiguous subarray in the modified array\n        max_sum = float('-inf')\n        current_sum = 0\n        for i in range(n * k):\n            current_sum = max(current_sum + arr[i % n], arr[i % n])\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    ```\n    The `max_sub_array_sum_repeated` function takes three arguments: `arr`, `k`, and `n`. It calculates the maximum sum of a contiguous subarray in the modified array by repeating the given array `k` times. The function iterates through the modified array and updates the maximum sum and current sum as it goes. Finally, it returns the maximum sum."}
{"task_id": "Mbpp/287", "completion": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i*i\n    return sum"}
{"task_id": "Mbpp/290", "completion": "def max_length(list_of_lists):\n    max_len = 0\n    max_list = []\n    for l in list_of_lists:\n        if len(l) > max_len:\n            max_len = len(l)\n            max_list = l\n    return max_len, max_list"}
{"task_id": "Mbpp/292", "completion": "\n    def find(a, b):\n        return a // b\n    ```\n\n    The `find` function takes two integers `a` and `b` as input and returns the quotient of `a` divided by `b`, rounded down to the nearest integer. This solution satisfies the assertion `assert find(10,3) == 3`."}
{"task_id": "Mbpp/293", "completion": "import math\n\ndef otherside_rightangle(a, b):\n    return math.sqrt(a**2 + b**2)\n\nassert otherside_rightangle(7,8)==10.63014581273465"}
{"task_id": "Mbpp/294", "completion": "def max_val(lst):\n    max_val = lst[0]\n    for i in lst:\n        if i > max_val:\n            max_val = i\n    return max_val"}
{"task_id": "Mbpp/57", "completion": "\n    def find_Max_Num(digits):\n        digits.sort(reverse=True)\n        return int(''.join(map(str, digits)))\n    ```\n\n    The `find_Max_Num` function takes a list of digits as input and sorts them in descending order. It then joins the sorted digits into a string and converts it to an integer. The function returns the maximum number that can be formed with the given list of digits."}
{"task_id": "Mbpp/295", "completion": "def sum_div(n):\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)"}
{"task_id": "Mbpp/296", "completion": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count"}
{"task_id": "Mbpp/297", "completion": "def flatten_list(nested_list):\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list"}
{"task_id": "Mbpp/299", "completion": "\n    def max_aggregate(tuples):\n        max_aggregate_dict = {}\n        for name, score in tuples:\n            if name in max_aggregate_dict:\n                max_aggregate_dict[name] += score\n            else:\n                max_aggregate_dict[name] = score\n        max_name = max(max_aggregate_dict, key=max_aggregate_dict.get)\n        max_score = max_aggregate_dict[max_name]\n        return (max_name, max_score)\n    ```\n\n    The `max_aggregate` function takes a list of tuples as input and returns a tuple containing the name and the maximum aggregate score. It uses a dictionary to store the aggregate scores for each name, and then finds the name with the maximum aggregate score."}
{"task_id": "Mbpp/300", "completion": "\n    import math\n\n    def count_binary_seq(n):\n        if n == 1:\n            return 2.0\n        else:\n            return 2 * count_binary_seq(n - 1)\n\n    assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)\n    ```\n\n    The `count_binary_seq` function takes an integer `n` as input and returns the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits. The base case is when `n` is 1, in which case the function returns 2.0. The recursive case multiplies the count by 2 for each iteration. The assertion checks if the count of binary sequences of length 2 for `n` is approximately equal to 2.0."}
{"task_id": "Mbpp/301", "completion": "def dict_depth(d):\n    if isinstance(d, dict):\n        if not d:\n            return 1\n        return 1 + max(dict_depth(v) for v in d.values())\n    return 0"}
{"task_id": "Mbpp/305", "completion": "def start_withp(words):\n    for word in words:\n        if word.startswith('p'):\n            return word.split()"}
{"task_id": "Mbpp/306", "completion": "\n    def max_sum_increasing_subseq(arr, n, i, k):\n        # Initialize the maximum sum to 0\n        max_sum = 0\n\n        # Iterate through the array from index i to k\n        for j in range(i, k+1):\n            # Check if the current element is greater than the previous element\n            if arr[j] > arr[j-1]:\n                # Update the maximum sum if the current sum is greater\n                max_sum = max(max_sum, arr[j])\n\n        return max_sum\n    ```\n\n    This function takes an array `arr`, its length `n`, an index `i`, and an index `k` as input. It iterates through the array from index `i` to `k` and finds the maximum sum of increasing subsequence. If the current element is greater than the previous element, it updates the maximum sum. Finally, it returns the maximum sum."}
{"task_id": "Mbpp/308", "completion": "def large_product(list1, list2, n):\n    # Sort the lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through the first n elements of both lists\n    for i in range(n):\n        # Multiply the elements and append to the result list\n        result.append(list1[i] * list2[i])\n    \n    return result"}
{"task_id": "Mbpp/309", "completion": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"task_id": "Mbpp/58", "completion": "def opposite_Signs(a, b):\n    return (a ^ b) < 0"}
{"task_id": "Mbpp/310", "completion": "def string_to_tuple(string):\n    return tuple(string)"}
{"task_id": "Mbpp/311", "completion": "def set_left_most_unset_bit(num):\n    if num == 0:\n        return 1\n    if num & (num + 1) == 0:\n        return num\n    return num | (num + 1)"}
{"task_id": "Mbpp/312", "completion": "\n    import math\n\n    def volume_cone(radius, height):\n        return (1/3) * math.pi * radius**2 * height\n    ```"}
{"task_id": "Mbpp/388", "completion": "def highest_Power_of_2(n):\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2"}
{"task_id": "Mbpp/389", "completion": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas(n-1) + find_lucas(n-2)"}
{"task_id": "Mbpp/390", "completion": "def add_string(lst, fmt):\n    return [fmt.format(x) for x in lst]"}
{"task_id": "Mbpp/391", "completion": "def convert_list_dictionary(keys, values1, values2):\n    result = []\n    for i in range(len(keys)):\n        d = {keys[i]: {values1[i]: values2[i]}}\n        result.append(d)\n    return result"}
{"task_id": "Mbpp/392", "completion": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    else:\n        return max(get_max_sum(n/2) + get_max_sum(n/3) + get_max_sum(n/4) + get_max_sum(n/5), n)"}
{"task_id": "Mbpp/394", "completion": "\n    def check_distinct(tup):\n        return len(tup) == len(set(tup))\n    ```\n\n    The `check_distinct` function takes a tuple as input and returns `True` if all elements are distinct, and `False` otherwise. It does this by creating a set from the tuple and checking if the length of the tuple is equal to the length of the set. If they are equal, all elements are distinct, and the function returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/395", "completion": "\n    def first_non_repeating_character(string):\n        char_count = {}\n        for char in string:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        for char in string:\n            if char_count[char] == 1:\n                return char\n        return None\n    ```\n    This function uses a dictionary to keep track of the count of each character in the input string. It then iterates through the string again to find the first character that has a count of 1, which is the first non-repeating character. If no such character is found, it returns None."}
{"task_id": "Mbpp/59", "completion": "def is_octagonal(n):\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/396", "completion": "def check_char(string):\n    if string[0] == string[-1]:\n        return \"Valid\"\n    else:\n        return \"Invalid\""}
{"task_id": "Mbpp/397", "completion": "def median_numbers(num1, num2, num3):\n    if num1 > num2:\n        if num1 < num3:\n            return num1\n        elif num2 > num3:\n            return num2\n        else:\n            return num3\n    else:\n        if num1 > num3:\n            return num1\n        elif num2 < num3:\n            return num2\n        else:\n            return num3\n\nassert median_numbers(25,55,65)==55.0"}
{"task_id": "Mbpp/398", "completion": "def sum_of_digits(numbers):\n    return sum([sum(map(int, str(num))) for num in numbers])"}
{"task_id": "Mbpp/400", "completion": "\n    def extract_freq(lst):\n        unique_tuples = set(lst)\n        return len(unique_tuples)\n    ```\n\n    The `extract_freq` function takes a list of tuples as input and uses the `set` data structure to remove duplicates. It then returns the length of the set, which is the number of unique tuples in the input list."}
{"task_id": "Mbpp/404", "completion": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b"}
{"task_id": "Mbpp/405", "completion": "\n    def check_tuplex(tuplex, element):\n        return element in tuplex\n    ```\n    The `check_tuplex` function takes a tuple and an element as input and returns `True` if the element exists in the tuple, and `False` otherwise."}
{"task_id": "Mbpp/406", "completion": "\n    def find_Parity(num):\n        return num % 2 == 1\n    ```\n\n    The `find_Parity` function takes a number as input and returns `True` if the parity of the number is odd, and `False` otherwise. It does this by checking if the remainder of the number divided by 2 is equal to 1."}
{"task_id": "Mbpp/407", "completion": "def rearrange_bigger(num):\n    num_str = str(num)\n    num_list = list(num_str)\n    for i in range(len(num_list)-1, 0, -1):\n        if num_list[i] > num_list[i-1]:\n            num_list[i], num_list[i-1] = num_list[i-1], num_list[i]\n            return int(\"\".join(num_list))\n    return num"}
{"task_id": "Mbpp/409", "completion": "def min_product_tuple(lst):\n    min_product = float('inf')\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            product = lst[i][0] * lst[j][1]\n            if product < min_product:\n                min_product = product\n    return min_product"}
{"task_id": "Mbpp/410", "completion": "def min_val(lst):\n    min_val = lst[0]\n    for i in lst:\n        if i < min_val:\n            min_val = i\n    return min_val\n\nassert min_val(['Python', 3, 2, 4, 5, 'version'])==2"}
{"task_id": "Mbpp/61", "completion": "\n    def count_Substrings(s):\n        count = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring = s[i:j]\n                if sum(int(digit) for digit in substring) == len(substring):\n                    count += 1\n        return count\n    ```\n    The `count_Substrings` function iterates through all possible substrings of the input string `s` and checks if the sum of the digits in the substring is equal to the length of the substring. If it is, the count is incremented. Finally, the function returns the total count of substrings with the sum of digits equal to their length."}
{"task_id": "Mbpp/412", "completion": "\n    def remove_odd(lst):\n        return [x for x in lst if x % 2 == 0]\n    ```"}
{"task_id": "Mbpp/413", "completion": "def extract_nth_element(lst, n):\n    return [item[n] for item in lst]"}
{"task_id": "Mbpp/414", "completion": "\n    def overlapping(seq1, seq2):\n        for item in seq1:\n            if item in seq2:\n                return True\n        return False\n    ```\n    The `overlapping` function iterates through the elements of `seq1` and checks if any of them are in `seq2`. If it finds an element that is in `seq2`, it returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/415", "completion": "\n    def max_Product(arr):\n        arr.sort()\n        if arr[-1] * arr[-2] > arr[0] * arr[1]:\n            return (arr[-1], arr[-2])\n        else:\n            return (arr[0], arr[1])\n    ```\n\n    ### Explanation:\n    The function `max_Product` takes an array `arr` as input and sorts it in ascending order. It then checks if the product of the last two elements is greater than the product of the first two elements. If it is, it returns the two elements with the highest product; otherwise, it returns the two elements with the lowest product."}
{"task_id": "Mbpp/418", "completion": "def Find_Max(list_of_lists):\n    max_list = []\n    for l in list_of_lists:\n        if len(l) > len(max_list):\n            max_list = l\n    return max_list"}
{"task_id": "Mbpp/419", "completion": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(rounded_numbers)\n    return result\n\n# Test the function\nassert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243"}
{"task_id": "Mbpp/420", "completion": "def cube_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**3\n    return sum\n\nassert cube_Sum(2) == 72"}
{"task_id": "Mbpp/421", "completion": "def concatenate_tuple(tuple_input, delimiter='-'):\n    return delimiter.join(str(x) for x in tuple_input)"}
{"task_id": "Mbpp/422", "completion": "\n    def find_Average_Of_Cube(n):\n        sum = 0\n        for i in range(1, n+1):\n            sum += i**3\n        return sum / n\n    ```\n\n    ### Test:\n    \n    assert find_Average_Of_Cube(2) == 4.5\n    ```\n\n    ### Output:\n    ```\n    Test passed\n    ```"}
{"task_id": "Mbpp/424", "completion": "def extract_rear(tup):\n    return [word[-1] for word in tup]"}
{"task_id": "Mbpp/4", "completion": "def heap_queue_largest(numbers, n):\n    import heapq\n    return heapq.nlargest(n, numbers)"}
{"task_id": "Mbpp/62", "completion": "def smallest_num(numbers):\n    return min(numbers)"}
{"task_id": "Mbpp/425", "completion": "\n    def count_element_in_list(lst, element):\n        count = 0\n        for sublist in lst:\n            if element in sublist:\n                count += 1\n        return count\n    ```\n    The `count_element_in_list` function takes a list of lists and an element as input and returns the number of sublists containing the given element. It iterates through each sublist in the input list and checks if the element is present in the sublist. If the element is found, the count is incremented. Finally, the function returns the total count of sublists containing the element."}
{"task_id": "Mbpp/426", "completion": "def filter_oddnumbers(numbers):\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/427", "completion": "\n    def change_date_format(date):\n        year, month, day = date.split('-')\n        return f'{day}-{month}-{year}'\n    ```\n\n    The `change_date_format` function takes a date in the format \"yyyy-mm-dd\" and returns the same date in the format \"dd-mm-yyyy\". It uses the `split` method to separate the year, month, and day from the input string, and then returns the formatted date using f-strings."}
{"task_id": "Mbpp/428", "completion": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr"}
{"task_id": "Mbpp/429", "completion": "def and_tuples(tuple1, tuple2):\n    return tuple(a & b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/430", "completion": "def parabola_directrix(a,b,c):\n    return -4*a*c"}
{"task_id": "Mbpp/431", "completion": "\n    def common_element(list1, list2):\n        for i in list1:\n            if i in list2:\n                return True\n        return False\n    ```\n\n    ### Test:\n    \n    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True\n    ```"}
{"task_id": "Mbpp/432", "completion": "def median_trapezium(a, b, c):\n    return (a + b - c) / 2"}
{"task_id": "Mbpp/433", "completion": "\n    def check_greater(array, number):\n        for element in array:\n            if number > element:\n                return True\n        return False\n    ```\n    This function iterates through the elements of the array and checks if the given number is greater than each element. If it is, the function returns True; otherwise, it returns False."}
{"task_id": "Mbpp/435", "completion": "def last_Digit(num):\n    return num % 10"}
{"task_id": "Mbpp/63", "completion": "\n    def max_difference(tuple_list):\n        max_diff = 0\n        for i in range(len(tuple_list)):\n            for j in range(i+1, len(tuple_list)):\n                diff = abs(tuple_list[i][0] - tuple_list[j][0]) + abs(tuple_list[i][1] - tuple_list[j][1])\n                if diff > max_diff:\n                    max_diff = diff\n        return max_diff\n    ```\n    This function iterates through the tuple list and calculates the difference between each pair of tuples. It then updates the maximum difference found so far. Finally, it returns the maximum difference found."}
{"task_id": "Mbpp/436", "completion": "def neg_nos(lst):\n    return [x for x in lst if x < 0]"}
{"task_id": "Mbpp/437", "completion": "def remove_odd(string):\n    new_string = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            new_string += string[i]\n    return new_string"}
{"task_id": "Mbpp/438", "completion": "def count_bidirectional(tuples):\n    count = 0\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            if tuples[i] == tuples[j] or tuples[i][::-1] == tuples[j]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/439", "completion": "def multiple_to_single(numbers):\n    return int(''.join(map(str, numbers)))"}
{"task_id": "Mbpp/440", "completion": "def find_adverb_position(sentence):\n    words = sentence.split()\n    for i, word in enumerate(words):\n        if word.endswith(\"ly\"):\n            return i, i+1, word\n    return None"}
{"task_id": "Mbpp/441", "completion": "def surfacearea_cube(size):\n    return 6 * size * size\n\nassert surfacearea_cube(5)==150"}
{"task_id": "Mbpp/442", "completion": "def positive_count(arr):\n    positive_count = 0\n    for num in arr:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(arr)"}
{"task_id": "Mbpp/445", "completion": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple(map(lambda x, y: x * y, tuple1[i], tuple2[i])))\n    return tuple(result)"}
{"task_id": "Mbpp/446", "completion": "def count_Occurrence(tuple, list):\n    count = 0\n    for i in list:\n        count += tuple.count(i)\n    return count\n\nassert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3"}
{"task_id": "Mbpp/447", "completion": "def cube_nums(nums):\n    return [num ** 3 for num in nums]"}
{"task_id": "Mbpp/64", "completion": "\n    def subject_marks(marks):\n        return sorted(marks, key=lambda x: x[1])\n    ```\n\n    The `subject_marks` function takes a list of tuples as input and uses the `sorted` function to sort the list based on the second value of each tuple. The `key` parameter of `sorted` is set to a lambda function that extracts the second value of each tuple. The sorted list is then returned."}
{"task_id": "Mbpp/448", "completion": "\n    def cal_sum(n):\n        if n == 0:\n            return 3\n        elif n == 1:\n            return 0\n        elif n == 2:\n            return 2\n        else:\n            return cal_sum(n-2) + cal_sum(n-3)\n    ```\n\n    ### Test:\n    \n    assert cal_sum(9) == 49\n    ```"}
{"task_id": "Mbpp/450", "completion": "def extract_string(lst, size):\n    return [s for s in lst if len(s) > size]"}
{"task_id": "Mbpp/451", "completion": "def remove_whitespaces(string):\n    return string.replace(' ', '')"}
{"task_id": "Mbpp/453", "completion": "\n    def sumofFactors(n):\n        sum = 0\n        for i in range(1, n+1):\n            if n % i == 0 and i % 2 == 0:\n                sum += i\n        return sum\n    ```\n\n    The `sumofFactors` function takes a number `n` as input and initializes a variable `sum` to 0. It then iterates through all numbers from 1 to `n`, checking if each number is a factor of `n` and if it is even. If both conditions are met, the factor is added to the `sum`. Finally, the function returns the sum of all even factors of `n`."}
{"task_id": "Mbpp/454", "completion": "def text_match_wordz(text):\n    if text.find(\"z\") != -1:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/455", "completion": "def check_monthnumb_number(month_number):\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/456", "completion": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\n\nassert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"}
{"task_id": "Mbpp/457", "completion": "def Find_Min(list):\n    min_len = len(list[0])\n    min_list = list[0]\n    for sublist in list:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_list = sublist\n    return min_list"}
{"task_id": "Mbpp/458", "completion": "def rectangle_area(length, width):\n    return length * width"}
{"task_id": "Mbpp/459", "completion": "def remove_uppercase(string):\n    result = ''\n    for char in string:\n        if char.islower():\n            result += char\n    return result"}
{"task_id": "Mbpp/65", "completion": "def recursive_list_sum(lst):\n    total = 0\n    for item in lst:\n        if type(item) == list:\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n\nassert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21"}
{"task_id": "Mbpp/460", "completion": "\n    def Extract(lst):\n        return [sublist[0] for sublist in lst]\n    ```\n\n    The `Extract` function takes a list of lists as input and returns a list containing the first element of each sublist. It uses a list comprehension to iterate through the input list and extract the first element of each sublist."}
{"task_id": "Mbpp/461", "completion": "\n    def upper_ctr(string):\n        count = 0\n        for char in string:\n            if char.isupper():\n                count += 1\n        return count\n    ```\n\n    This function takes a string as input and returns the number of uppercase characters in the string. It iterates through each character in the string and checks if it is uppercase using the `isupper()` method. If it is, the count is incremented. Finally, the function returns the count."}
{"task_id": "Mbpp/462", "completion": "def combinations_list(lst):\n    if len(lst) == 0:\n        return [[]]\n    else:\n        result = []\n        for i in range(len(lst)):\n            for j in combinations_list(lst[i+1:]):\n                result.append([lst[i]] + j)\n        return result"}
{"task_id": "Mbpp/463", "completion": "\n    def max_subarray_product(arr):\n        max_product = arr[0]\n        current_product = arr[0]\n        for i in range(1, len(arr)):\n            current_product = max(arr[i], current_product * arr[i])\n            max_product = max(max_product, current_product)\n        return max_product\n    ```\n    The `max_subarray_product` function iterates through the array, keeping track of the maximum product seen so far and the current product. It updates the maximum product if the current product is greater than the maximum product seen so far. Finally, it returns the maximum product found."}
{"task_id": "Mbpp/465", "completion": "def drop_empty(dictionary):\n    return {key: value for key, value in dictionary.items() if value is not None}"}
{"task_id": "Mbpp/468", "completion": "\n    def max_product(arr):\n        max_prod = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if arr[j] > arr[i]:\n                    prod = arr[i] * arr[j]\n                    if prod > max_prod:\n                        max_prod = prod\n        return max_prod\n    ```\n    This function iterates through the array and finds the maximum product formed by multiplying numbers of an increasing subsequence. It returns the maximum product found."}
{"task_id": "Mbpp/470", "completion": "def add_pairwise(tup):\n    return tuple(tup[i] + tup[i+1] for i in range(len(tup)-1))"}
{"task_id": "Mbpp/471", "completion": "def find_remainder(arr, n):\n    product = 1\n    for i in arr:\n        product = (product * i) % n\n    return product"}
{"task_id": "Mbpp/472", "completion": "def check_Consecutive(lst):\n    return sorted(lst) == list(range(min(lst), max(lst)+1))"}
{"task_id": "Mbpp/473", "completion": "\n    def tuple_intersection(tuple_list1, tuple_list2):\n        intersection = set()\n        for tup1 in tuple_list1:\n            for tup2 in tuple_list2:\n                if tup1 == tup2 or tup1 == tup2[::-1]:\n                    intersection.add(tup1)\n        return intersection\n    ```"}
{"task_id": "Mbpp/66", "completion": "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/474", "completion": "def replace_char(string, old, new):\n    return string.replace(old, new)"}
{"task_id": "Mbpp/475", "completion": "def sort_counter(d):\n    return sorted(d.items(), key=lambda x: x[1], reverse=True)"}
{"task_id": "Mbpp/476", "completion": "def big_sum(arr):\n    arr.sort()\n    return arr[0] + arr[-1]"}
{"task_id": "Mbpp/477", "completion": "def is_lower(string):\n    return string.lower()"}
{"task_id": "Mbpp/478", "completion": "def remove_lowercase(string):\n    \"\"\"\n    Remove lowercase substrings from a given string.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    str: The string with lowercase substrings removed.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char\n    return result"}
{"task_id": "Mbpp/479", "completion": "def first_Digit(num):\n    return int(str(num)[0])"}
{"task_id": "Mbpp/554", "completion": "def Split(list):\n    return [x for x in list if x % 2 != 0]"}
{"task_id": "Mbpp/555", "completion": "\n    def difference(n):\n        return sum(range(1, n+1))**3 - sum(i**3 for i in range(1, n+1))\n    ```\n\n    The `difference` function takes an integer `n` as input and returns the difference between the sum of cubes of the first `n` natural numbers and the sum of the first `n` natural numbers. The assertion `assert difference(3) == 30` checks that the function returns the correct result for the input `3`."}
{"task_id": "Mbpp/556", "completion": "def find_Odd_Pair(arr,n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            if (arr[i]^arr[j])%2 != 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/557", "completion": "def toggle_string(string):\n    new_string = \"\"\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"}
{"task_id": "Mbpp/67", "completion": "\n    def bell_number(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return bell_number(n-1) + bell_number(n-2)\n\n    assert bell_number(2)==2"}
{"task_id": "Mbpp/558", "completion": "def digit_distance_nums(num1, num2):\n    num1_str = str(num1)\n    num2_str = str(num2)\n    distance = 0\n    for i in range(len(num1_str)):\n        distance += abs(int(num1_str[i]) - int(num2_str[i]))\n    return distance"}
{"task_id": "Mbpp/559", "completion": "\n    def max_sub_array_sum(arr, n):\n        max_so_far = arr[0]\n        curr_max = arr[0]\n\n        for i in range(1, n):\n            curr_max = max(arr[i], curr_max + arr[i])\n            max_so_far = max(max_so_far, curr_max)\n\n        return max_so_far\n    ```\n    The `max_sub_array_sum` function takes a list `arr` and its length `n` as input. It initializes `max_so_far` and `curr_max` to the first element of the list. Then, it iterates through the list, updating `curr_max` to be the maximum of the current element and the sum of the current element and the previous maximum. Finally, it updates `max_so_far` to be the maximum of `max_so_far` and `curr_max`. The function returns the maximum sum of the contiguous sublist."}
{"task_id": "Mbpp/560", "completion": "def union_elements(tuple1, tuple2):\n    union = tuple1 + tuple2\n    return tuple(sorted(set(union)))"}
{"task_id": "Mbpp/562", "completion": "def Find_Max_Length(list_of_lists):\n    max_length = 0\n    for sublist in list_of_lists:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    return max_length"}
{"task_id": "Mbpp/563", "completion": "def extract_values(string):\n    values = []\n    start_index = string.find('\"')\n    while start_index != -1:\n        end_index = string.find('\"', start_index + 1)\n        if end_index != -1:\n            value = string[start_index + 1:end_index]\n            values.append(value)\n            start_index = string.find('\"', end_index + 1)\n        else:\n            break\n    return values"}
{"task_id": "Mbpp/564", "completion": "def count_Pairs(arr, n):\n    count = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/565", "completion": "def split(string):\n    return list(string)"}
{"task_id": "Mbpp/566", "completion": "def sum_digits(n):\n    return sum(int(i) for i in str(n))"}
{"task_id": "Mbpp/567", "completion": "def issort_list(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))"}
{"task_id": "Mbpp/568", "completion": "def empty_list(n):\n    return [{} for i in range(n)]"}
{"task_id": "Mbpp/68", "completion": "def is_Monotonic(arr):\n    return (all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) or\n            all(arr[i] >= arr[i+1] for i in range(len(arr)-1)))"}
{"task_id": "Mbpp/569", "completion": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/572", "completion": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums"}
{"task_id": "Mbpp/573", "completion": "def unique_product(lst):\n    unique_numbers = set(lst)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product"}
{"task_id": "Mbpp/574", "completion": "def surfacearea_cylinder(r,h):\n    pi = 3.14\n    return 2*pi*r*(r+h)"}
{"task_id": "Mbpp/576", "completion": "\n    def is_Sub_Array(arr1, arr2):\n        if len(arr2) > len(arr1):\n            return False\n        for i in range(len(arr1) - len(arr2) + 1):\n            if arr1[i:i+len(arr2)] == arr2:\n                return True\n        return False\n    ```\n\n    The `is_Sub_Array` function takes two lists, `arr1` and `arr2`, as input. It first checks if `arr2` is longer than `arr1`, and if so, returns `False`. Then, it iterates through `arr1`, checking if any sublist of length `len(arr2)` matches `arr2`. If a match is found, the function returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/577", "completion": "\n    def last_Digit_Factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return (n * last_Digit_Factorial(n-1)) % 10\n    ```\n    The `last_Digit_Factorial` function takes an integer `n` as input and returns the last digit in the factorial of `n`. If `n` is 0, the function returns 1. Otherwise, it returns the product of `n` and the last digit in the factorial of `n-1`, modulo 10. This ensures that the function returns the last digit in the factorial of `n`."}
{"task_id": "Mbpp/578", "completion": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list\n\nassert interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])==[1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"}
{"task_id": "Mbpp/579", "completion": "\n    def find_dissimilar(tuple1, tuple2):\n        dissimilar = []\n        for i in tuple1:\n            if i not in tuple2:\n                dissimilar.append(i)\n        for i in tuple2:\n            if i not in tuple1:\n                dissimilar.append(i)\n        return tuple(dissimilar)\n    ```\n\n    The `find_dissimilar` function takes two tuples as input and returns a tuple containing the dissimilar elements between the two tuples. It iterates through each tuple and appends the elements that are not present in the other tuple to a list. Finally, it returns the list as a tuple."}
{"task_id": "Mbpp/580", "completion": "def extract_even(tup):\n    even_tup = ()\n    for i in tup:\n        if isinstance(i, tuple):\n            even_tup += (extract_even(i),)\n        elif i % 2 == 0:\n            even_tup += (i,)\n    return even_tup"}
{"task_id": "Mbpp/581", "completion": "def surface_Area(base_edge, height):\n    # Calculate the surface area of a square pyramid\n    surface_area = base_edge**2 + (base_edge * height)\n    return surface_area\n\n# Test the function\nassert surface_Area(3,4) == 33"}
{"task_id": "Mbpp/69", "completion": "def is_sublist(lst, sub):\n    if len(sub) > len(lst):\n        return False\n    for i in range(len(lst) - len(sub) + 1):\n        if lst[i:i+len(sub)] == sub:\n            return True\n    return False"}
{"task_id": "Mbpp/582", "completion": "def my_dict(d):\n    if len(d) == 0:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/583", "completion": "def catalan_number(n):\n    if n == 0:\n        return 1\n    else:\n        result = 0\n        for i in range(n):\n            result += catalan_number(i) * catalan_number(n-i-1)\n        return result"}
{"task_id": "Mbpp/585", "completion": "def expensive_items(dataset, n):\n    sorted_dataset = sorted(dataset, key=lambda x: x['price'], reverse=True)\n    return sorted_dataset[:n]"}
{"task_id": "Mbpp/586", "completion": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "completion": "def list_tuple(lst):\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "completion": "def big_diff(nums):\n    return max(nums) - min(nums)"}
{"task_id": "Mbpp/589", "completion": "def perfect_squares(start, end):\n    return [x for x in range(start, end+1) if (x**0.5).is_integer()]"}
{"task_id": "Mbpp/590", "completion": "\n    import cmath\n\n    def polar_rect(r, theta):\n        x = r * cmath.cos(theta)\n        y = r * cmath.sin(theta)\n        return (x, y)\n    ```\n\n    The `polar_rect` function takes two arguments, `r` and `theta`, which represent the radius and angle of a polar coordinate. It uses the `cmath` module to calculate the rectangular coordinates (x and y) based on the given radius and angle. The function then returns a tuple containing the rectangular coordinates."}
{"task_id": "Mbpp/591", "completion": "\n    def swap_List(lst):\n        lst[0], lst[-1] = lst[-1], lst[0]\n        return lst\n    ```\n\n    ### Explanation:\n    The `swap_List` function takes a list `lst` as input and swaps the first and last elements of the list using tuple assignment. It then returns the modified list."}
{"task_id": "Mbpp/592", "completion": "\n    def sum_Of_product(n):\n        sum = 0\n        for i in range(1, n+1):\n            sum += i * (i+1)\n        return sum\n    ```\n\n    The `sum_Of_product` function takes an integer `n` as input and returns the sum of the product of consecutive binomial co-efficients up to `n`. It uses a for loop to iterate from 1 to `n`, and for each iteration, it multiplies the current number by the next number and adds the result to the `sum`. Finally, it returns the `sum`."}
{"task_id": "Mbpp/70", "completion": "def get_equal(tuples):\n    length = len(tuples[0])\n    for t in tuples:\n        if len(t) != length:\n            return False\n    return True"}
{"task_id": "Mbpp/593", "completion": "def removezero_ip(ip):\n    ip_list = ip.split('.')\n    for i in range(len(ip_list)):\n        if ip_list[i].startswith('0'):\n            ip_list[i] = ip_list[i][1:]\n    return '.'.join(ip_list)"}
{"task_id": "Mbpp/594", "completion": "def diff_even_odd(lst):\n    even = [x for x in lst if x % 2 == 0]\n    odd = [x for x in lst if x % 2 != 0]\n    return even[0] - odd[0]"}
{"task_id": "Mbpp/595", "completion": "\n    def min_Swaps(str1, str2):\n        count = 0\n        for i in range(len(str1)):\n            if str1[i] != str2[i]:\n                count += 1\n        return count\n\n    assert min_Swaps(\"1101\", \"1110\") == 1\n    assert min_Swaps(\"1101\", \"1111\") == 2\n    assert min_Swaps(\"1101\", \"1011\") == 2\n    assert min_Swaps(\"1101\", \"1010\") == 3\n    assert min_Swaps(\"1101\", \"0110\") == 3\n    assert min_Swaps(\"1101\", \"0101\") == 4\n    assert min_Swaps(\"1101\", \"0011\") == 4\n    assert min_Swaps(\"1101\", \"0001\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert min_Swaps(\"1101\", \"0000\") == 5\n    assert"}
{"task_id": "Mbpp/596", "completion": "import sys\n\ndef tuple_size(tuple):\n    return sys.getsizeof(tuple)\n\nassert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3) ) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))"}
{"task_id": "Mbpp/597", "completion": "\n    def find_kth(arr1, arr2, k):\n        merged_arr = sorted(arr1 + arr2)\n        return merged_arr[k - 1]\n    ```\n\n    The `find_kth` function takes two sorted arrays `arr1` and `arr2` and an integer `k` as input. It merges the two arrays into a single sorted array and then returns the element at index `k - 1`. The assertion in the question ensures that the function returns the correct result for the given input."}
{"task_id": "Mbpp/598", "completion": "def armstrong_number(num):\n    num_str = str(num)\n    num_len = len(num_str)\n    sum = 0\n    for i in num_str:\n        sum += int(i)**num_len\n    if sum == num:\n        return True\n    else:\n        return False\n\nassert armstrong_number(153)==True"}
{"task_id": "Mbpp/599", "completion": "def sum_average(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n    average = sum / n\n    return sum, average\n\nassert sum_average(10)==(55, 5.5)"}
{"task_id": "Mbpp/600", "completion": "\n    def is_Even(num):\n        return num % 2 == 0\n    ```\n\n    The `is_Even` function takes a number as input and returns `True` if the number is even, and `False` otherwise. It does this by checking if the remainder of the number divided by 2 is 0, which means the number is even."}
{"task_id": "Mbpp/602", "completion": "def first_repeated_char(string):\n    seen = set()\n    for char in string:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None"}
{"task_id": "Mbpp/603", "completion": "def get_ludic(n):\n    ludic = []\n    for i in range(1, n+1):\n        if is_ludic(i):\n            ludic.append(i)\n    return ludic\n\ndef is_ludic(n):\n    if n == 1:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        return is_ludic(n // 2)"}
{"task_id": "Mbpp/71", "completion": "def comb_sort(lst):\n    gap = len(lst)\n    shrink = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap > 1:\n            sorted = False\n        else:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(lst):\n            if lst[i] > lst[i + gap]:\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                sorted = False\n            i += 1\n\n    return lst"}
{"task_id": "Mbpp/604", "completion": "def reverse_words(string):\n    return \" \".join(string.split()[::-1])"}
{"task_id": "Mbpp/605", "completion": "def prime_num(num):\n    if num > 1:\n        for i in range(2, num):\n            if (num % i) == 0:\n                return False\n        else:\n            return True\n    else:\n        return False"}
{"task_id": "Mbpp/606", "completion": "\n    import math\n\n    def radian_degree(degrees):\n        return degrees * math.pi / 180\n    ```\n\n    ### Test:\n    \n    assert radian_degree(90)==1.5707963267948966\n    ```"}
{"task_id": "Mbpp/607", "completion": "import re\n\ndef find_literals(string, pattern):\n    match = re.search(pattern, string)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None\n\nassert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"}
{"task_id": "Mbpp/608", "completion": "\n    def bell_Number(n):\n        bell = [[0 for i in range(n+1)] for j in range(n+1)]\n        bell[0][0] = 1\n        for i in range(1, n+1):\n            bell[i][0] = bell[i-1][i-1]\n            for j in range(1, i+1):\n                bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n        return bell[n][0]\n    ```\n    The `bell_Number` function takes an integer `n` as input and returns the nth Bell number. It uses dynamic programming to calculate the Bell numbers and returns the result."}
{"task_id": "Mbpp/610", "completion": "def remove_kth_element(lst, k):\n    return lst[:k] + lst[k+1:]"}
{"task_id": "Mbpp/611", "completion": "\n    def max_of_nth(matrix, n):\n        return max(row[n] for row in matrix)\n    ```\n\n    The `max_of_nth` function takes a matrix represented as a list of lists and an integer `n` as input. It then uses a generator expression to extract the nth column from each row of the matrix and returns the maximum value. This solution has a time complexity of O(n) where n is the number of rows in the matrix."}
{"task_id": "Mbpp/612", "completion": "def merge(lst):\n    return [list(x) for x in zip(*lst)]"}
{"task_id": "Mbpp/614", "completion": "def cummulative_sum(tuple_list):\n    total = 0\n    for tup in tuple_list:\n        for num in tup:\n            total += num\n    return total"}
{"task_id": "Mbpp/615", "completion": "def average_tuple(tuples):\n    averages = []\n    for t in tuples:\n        averages.append(sum(t) / len(t))\n    return averages"}
{"task_id": "Mbpp/6", "completion": "def differ_At_One_Bit_Pos(num1, num2):\n    # Convert the numbers to binary strings\n    bin_num1 = bin(num1)[2:]\n    bin_num2 = bin(num2)[2:]\n    \n    # Pad the shorter binary string with leading zeros\n    if len(bin_num1) < len(bin_num2):\n        bin_num1 = '0' * (len(bin_num2) - len(bin_num1)) + bin_num1\n    elif len(bin_num2) < len(bin_num1):\n        bin_num2 = '0' * (len(bin_num1) - len(bin_num2)) + bin_num2\n    \n    # Count the number of different bits\n    count = 0\n    for i in range(len(bin_num1)):\n        if bin_num1[i] != bin_num2[i]:\n            count += 1\n    \n    # Check if the count is exactly 1\n    return count == 1"}
{"task_id": "Mbpp/72", "completion": "\n    def dif_Square(n):\n        for i in range(1, n):\n            for j in range(1, n):\n                if i*i + j*j == n:\n                    return True\n        return False\n    ```\n    The function `dif_Square` takes an integer `n` as input and returns `True` if `n` can be represented as the difference of two squares, and `False` otherwise. It iterates through all possible pairs of integers `i` and `j` from 1 to `n` and checks if `i*i + j*j` is equal to `n`. If it is, the function returns `True`; otherwise, it returns `False`."}
{"task_id": "Mbpp/616", "completion": "def tuple_modulo(t1, t2):\n    return tuple(a % b for a, b in zip(t1, t2))"}
{"task_id": "Mbpp/618", "completion": "def div_list(list1, list2):\n    return [list1[i] / list2[i] for i in range(len(list1))]"}
{"task_id": "Mbpp/619", "completion": "def move_num(string):\n    num = ''\n    letters = ''\n    for i in string:\n        if i.isdigit():\n            num += i\n        else:\n            letters += i\n    return letters + num"}
{"task_id": "Mbpp/620", "completion": "def largest_subset(numbers):\n    # Sort the list of numbers in descending order\n    numbers.sort(reverse=True)\n    \n    # Initialize the subset with the first number\n    subset = [numbers[0]]\n    \n    # Iterate through the remaining numbers\n    for num in numbers[1:]:\n        # Check if the current number is divisible by the last number in the subset\n        if num % subset[-1] == 0:\n            # If it is, add the number to the subset\n            subset.append(num)\n    \n    # Return the size of the largest subset\n    return len(subset)"}
{"task_id": "Mbpp/622", "completion": "def get_median(list1, list2, n):\n    i = 0\n    j = 0\n    m1 = -1\n    m2 = -1\n    count = 0\n\n    while count < n + 1:\n        if i == n:\n            m1 = m2\n            m2 = list2[0]\n            break\n        if j == n:\n            m1 = m2\n            m2 = list1[0]\n            break\n\n        if list1[i] <= list2[j]:\n            m1 = m2\n            m2 = list1[i]\n            i += 1\n        else:\n            m1 = m2\n            m2 = list2[j]\n            j += 1\n        count += 1\n\n    return (m1 + m2) / 2"}
{"task_id": "Mbpp/623", "completion": "def nth_nums(nums, n):\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "completion": "def is_upper(string):\n    return string.upper()"}
{"task_id": "Mbpp/626", "completion": "\n    def triangle_area(radius):\n        if radius < 0:\n            return None\n        else:\n            area = 3.14 * radius * radius / 2\n            return area\n\n    # Test the function\n    assert triangle_area(-1) == None\n    assert triangle_area(0) == 0\n    assert triangle_area(1) == 0.785\n    assert triangle_area(2) == 5.026\n    assert triangle_area(3) == 11.309\n    assert triangle_area(4) == 19.625\n    assert triangle_area(5) == 29.802\n    assert triangle_area(6) == 41.633\n    assert triangle_area(7) == 54.915\n    assert triangle_area(8) == 69.543\n    assert triangle_area(9) == 85.314\n    assert triangle_area(10) == 102.026\n    assert triangle_area(11) == 119.585\n    assert triangle_area(12) == 137.789\n    assert triangle_area(13) == 156.437\n    assert triangle_area(14) == 175.429\n    assert triangle_area(15) == 194.665\n    assert triangle_area(16) == 214.047\n    assert triangle_area(17) == 233.475\n    assert triangle_area(18) == 252.851\n    assert triangle_area(19) == 272.076\n    assert triangle_area(20) == 291.053\n    assert triangle_area(21) == 309.684\n    assert triangle_area(22) == 327.872\n    assert triangle_area(23) == 345.519\n    assert triangle_area(24) == 362.528\n    assert triangle_area(25) == 378.803\n    assert triangle_area(26) == 394.246\n    assert triangle_area(27) == 408.761\n    assert triangle_area(28) == 422.251\n    assert triangle_area(29) == 434.620\n    assert triangle_area(30) == 445.772\n    assert triangle_area(31) == 455.612\n    assert triangle_area(32) == 464.045\n    assert triangle_area(33) == 471.076\n    assert triangle_area(34) == 476.610\n    assert triangle_area(35) == 480.553\n    assert triangle_area(36) == 482.811\n    assert triangle_area(37) == 483.290\n    assert triangle_area(38) == 481.897\n    assert triangle_area(39) == 478.539\n    assert triangle_area(40) == 473.124\n    assert triangle_area(41) == 465.560\n    assert triangle_area(42) == 455.756\n    assert triangle_area(43) == 443.621\n    assert triangle_area(44) == 429.065\n    assert triangle_area(45) == 412.008\n    assert triangle_area(46) == 392.371\n    assert triangle_area(47) == 370.076\n    assert triangle_area(48) == 345.046\n    assert triangle_area(49)"}
{"task_id": "Mbpp/628", "completion": "def replace_spaces(string):\n    return string.replace(\" \", \"%20\")"}
{"task_id": "Mbpp/629", "completion": "def split(numbers):\n    return [num for num in numbers if num % 2 == 0]"}
{"task_id": "Mbpp/74", "completion": "\n    def is_samepatterns(patterns, colors):\n        if len(patterns) != len(colors):\n            return False\n        for i in range(len(patterns)):\n            if patterns[i] != colors[i]:\n                return False\n        return True\n    ```\n\n    The `is_samepatterns` function takes two lists of strings, `patterns` and `colors`, and returns `True` if they have the same length and the same elements in the same order, and `False` otherwise."}
{"task_id": "Mbpp/630", "completion": "\n    def get_coordinates(coordinate):\n        x, y = coordinate\n        adjacent_coordinates = []\n        for i in range(x-1, x+2):\n            for j in range(y-1, y+2):\n                if (i, j) != coordinate:\n                    adjacent_coordinates.append([i, j])\n        return adjacent_coordinates\n    ```"}
{"task_id": "Mbpp/631", "completion": "def replace_spaces(string):\n    return string.replace(' ', '_')"}
{"task_id": "Mbpp/632", "completion": "\n    def move_zero(lst):\n        # Initialize a variable to keep track of the position of the last non-zero element\n        last_non_zero_pos = 0\n        \n        # Iterate through the list\n        for i in range(len(lst)):\n            # If the current element is non-zero, swap it with the element at the last non-zero position\n            if lst[i] != 0:\n                lst[last_non_zero_pos], lst[i] = lst[i], lst[last_non_zero_pos]\n                last_non_zero_pos += 1\n        \n        return lst\n    ```\n    \n    This function iterates through the list, swapping non-zero elements with the element at the last non-zero position, and returns the modified list."}
{"task_id": "Mbpp/633", "completion": "\n    def pair_xor_Sum(nums, n):\n        sum = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                sum += nums[i] ^ nums[j]\n        return sum\n    ```\n    The function `pair_xor_Sum` takes a list of numbers `nums` and the length of the list `n` as input. It iterates through all pairs of numbers in the list and calculates the xor of each pair, and then adds the result to the `sum`. Finally, it returns the sum of xor of all pairs of numbers in the given list."}
{"task_id": "Mbpp/635", "completion": "\n    def heap_sort(arr):\n        n = len(arr)\n        for i in range(n, -1, -1):\n            heapify(arr, n, i)\n        for i in range(n-1, 0, -1):\n            arr[i], arr[0] = arr[0], arr[i]\n            heapify(arr, i, 0)\n        return arr\n\n    def heapify(arr, n, i):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n        if l < n and arr[i] < arr[l]:\n            largest = l\n        if r < n and arr[largest] < arr[r]:\n            largest = r\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n    ```\n\n    ### Explanation:\n    The heap_sort function first builds a max heap from the given list. Then, it repeatedly swaps the root element with the last element, reduces the size of the heap by one, and calls heapify on the reduced heap. This process sorts the list in ascending order.\n\n    The heapify function takes an array, the size of the heap, and the index of the root element. It compares the root element with its left and right child, and swaps it with the largest element if necessary. This process ensures that the subtree rooted at the given index satisfies the max heap property.\n\n    The heap_sort function repeatedly calls heapify on the array to build a max heap, and then swaps the root element with the last element, reducing the size of the heap by one, and calls heapify on the reduced heap. This process sorts the list in ascending order."}
{"task_id": "Mbpp/637", "completion": "def noprofit_noloss(buy_price, sell_price):\n    if buy_price == sell_price:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/638", "completion": "\n    def wind_chill(wind_velocity, temperature):\n        wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * (wind_velocity ** 0.16) + 0.3965 * temperature * (wind_velocity ** 0.16)\n        return round(wind_chill_index)\n    ```"}
{"task_id": "Mbpp/639", "completion": "def sample_nam(names):\n    return sum(len(name) for name in names if name[0].isupper())"}
{"task_id": "Mbpp/640", "completion": "def remove_parenthesis(string):\n    return string.replace(\"(\", \"\").replace(\")\", \"\")"}
{"task_id": "Mbpp/641", "completion": "\n    def is_nonagonal(n):\n        return n * (3 * n - 2)\n    ```"}
{"task_id": "Mbpp/75", "completion": "\n    def find_tuples(tuples, k):\n        result = []\n        for t in tuples:\n            if all(x % k == 0 for x in t):\n                result.append(t)\n        return result\n    ```\n\n    The `find_tuples` function takes a list of tuples and an integer `k` as input. It iterates through each tuple in the list, and if all elements of the tuple are divisible by `k`, it adds the tuple to the `result` list. Finally, it returns the `result` list."}
{"task_id": "Mbpp/643", "completion": "def text_match_wordz_middle(text):\n    import re\n    pattern = r'^[^z]*z[^z]*$'\n    return bool(re.match(pattern, text))"}
{"task_id": "Mbpp/644", "completion": "\n    def reverse_Array_Upto_K(arr, k):\n        return arr[:k][::-1] + arr[k:]\n    ```\n\n    The `reverse_Array_Upto_K` function takes an array `arr` and an integer `k` as input. It returns a new array that is the original array with the first `k` elements reversed. The `[::-1]` syntax is used to reverse the first `k` elements of the array. The `+` operator is used to concatenate the reversed part with the remaining part of the array."}
{"task_id": "Mbpp/720", "completion": "\n    def add_dict_to_tuple(tuple, dict):\n        return tuple + (dict,)\n    ```\n\n    ### Test:\n    \n    assert add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} ) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    ```"}
{"task_id": "Mbpp/721", "completion": "\n    def maxAverageOfPath(matrix):\n        n = len(matrix)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = matrix[0][0]\n        for i in range(1, n):\n            dp[0][i] = dp[0][i-1] + matrix[0][i]\n            dp[i][0] = dp[i-1][0] + matrix[i][0]\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        return dp[n-1][n-1] / (n*n)\n\n    print(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]))\n"}
{"task_id": "Mbpp/722", "completion": "def filter_data(students, min_height, min_weight):\n    filtered_students = {name: (height, weight) for name, (height, weight) in students.items() if height >= min_height and weight >= min_weight}\n    return filtered_students\n\n# Test the function\nstudents = {'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}\nmin_height = 6.0\nmin_weight = 70\nprint(filter_data(students, min_height, min_weight))"}
{"task_id": "Mbpp/723", "completion": "\n    def count_same_pair(list1, list2):\n        count = 0\n        for i in range(len(list1)):\n            if list1[i] == list2[i]:\n                count += 1\n        return count\n    ```\n    The `count_same_pair` function takes two lists as input and returns the number of indices where the lists have the same values. It iterates through the lists and compares the values at each index, incrementing the count if they are equal. Finally, it returns the count of indices where the lists have the same values."}
{"task_id": "Mbpp/724", "completion": "def power_base_sum(base, power):\n    return sum(int(digit) for digit in str(base ** power))"}
{"task_id": "Mbpp/725", "completion": "\n    def extract_quotation(string):\n        quotations = []\n        start_index = string.find('\"')\n        while start_index != -1:\n            end_index = string.find('\"', start_index + 1)\n            if end_index != -1:\n                quotations.append(string[start_index + 1:end_index])\n                start_index = string.find('\"', end_index + 1)\n            else:\n                break\n        return quotations\n    ```\n    The `extract_quotation` function uses the `find` method to locate the first occurrence of a quotation mark and then searches for the next quotation mark to extract the value between them. It appends the extracted value to the `quotations` list and continues the search for the next quotation mark. The function returns the list of extracted values."}
{"task_id": "Mbpp/726", "completion": "def multiply_elements(t):\n    return tuple(t[i] * t[i+1] for i in range(len(t)-1))"}
{"task_id": "Mbpp/728", "completion": "def sum_list(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/77", "completion": "\n    def is_Diff(num):\n        if num % 11 == 0:\n            return True\n        else:\n            return False\n    ```\n\n    ### Test:\n    \n    assert is_Diff(12345) == False\n    ```\n\n    ### Output:\n    ```\n    AssertionError\n    ```\n\n    ### Explanation:\n    The function `is_Diff` returns `True` when the input number is divisible by 11, but the assertion checks for `False`. Therefore, the function does not satisfy the assertion."}
{"task_id": "Mbpp/730", "completion": "def consecutive_duplicates(lst):\n    new_lst = []\n    for i in range(len(lst)):\n        if i == 0 or lst[i] != lst[i-1]:\n            new_lst.append(lst[i])\n    return new_lst"}
{"task_id": "Mbpp/731", "completion": "def lateralsurface_cone(r, h):\n    import math\n    return math.pi * r * (r + math.sqrt(r**2 + h**2))"}
{"task_id": "Mbpp/732", "completion": "def replace_specialchar(string):\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')\n\nassert replace_specialchar('Python language, Programming language.')==('Python:language::Programming:language:')"}
{"task_id": "Mbpp/733", "completion": "\n    def find_first_occurrence(arr, target):\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target and (mid == 0 or arr[mid - 1] < target):\n                return mid\n            elif arr[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n    ```\n\n    The `find_first_occurrence` function uses binary search to find the index of the first occurrence of a given number in a sorted array. It initializes two pointers, `left` and `right`, to the start and end of the array, respectively. It then enters a loop that continues until the pointers cross. In each iteration, it calculates the middle index and checks if the element at that index is equal to the target. If it is, it checks if it is the first occurrence by checking if the element at the previous index is less than the target. If so, it returns the index. If not, it updates the pointers based on the value at the middle index. If the target is not found, it returns -1."}
{"task_id": "Mbpp/734", "completion": "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    sum = 0\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            sum += prod\n    return sum\n\nassert sum_Of_Subarray_Prod([1,2,3]) == 20"}
{"task_id": "Mbpp/735", "completion": "\n    def toggle_middle_bits(num):\n        # Find the position of the most significant bit\n        msb = 0\n        while num >> (msb + 1) > 0:\n            msb += 1\n\n        # Toggle bits from 1 to msb-1\n        mask = (1 << (msb - 1)) - 1\n        return num ^ mask\n    ```\n\n    This function first finds the position of the most significant bit of the input number using a loop. Then, it creates a bit mask with all bits set except the first and the last bit, and uses bitwise XOR to toggle the middle bits. The function returns the modified number."}
{"task_id": "Mbpp/736", "completion": "def left_insertion(arr, x):\n    for i in range(len(arr)):\n        if arr[i] >= x:\n            return i\n    return len(arr)"}
{"task_id": "Mbpp/737", "completion": "import re\n\ndef check_str(string):\n    return bool(re.match(r'^[aeiou]', string, re.IGNORECASE))"}
{"task_id": "Mbpp/739", "completion": "\n    def find_Index(n):\n        # Initialize the index\n        index = 1\n        # Initialize the triangular number\n        triangular_number = 1\n        # Initialize the number of digits\n        digits = 1\n        # Loop until the number of digits is equal to n\n        while digits < n:\n            # Increment the index\n            index += 1\n            # Update the triangular number\n            triangular_number += index\n            # Update the number of digits\n            digits = len(str(triangular_number))\n        # Return the index\n        return index\n    ```\n    The `find_Index` function takes an integer `n` as input and returns the index of the smallest triangular number with `n` digits. It uses a while loop to increment the index and update the triangular number until the number of digits is equal to `n`."}
{"task_id": "Mbpp/740", "completion": "\n    def tuple_to_dict(tup):\n        return dict(zip(tup[::2], tup[1::2]))\n    ```\n\n    ### Explanation:\n    The `tuple_to_dict` function takes a tuple `tup` as input and uses the `zip` function to pair adjacent elements of the tuple into a dictionary. The `zip` function takes two iterables (in this case, the even-indexed elements of `tup` and the odd-indexed elements of `tup`) and returns an iterator of tuples, where each tuple contains the corresponding elements from the input iterables. The `dict` function then converts this iterator of tuples into a dictionary.\n\n    The assertion checks that the `tuple_to_dict` function correctly converts the given tuple to a key-value dictionary using adjacent elements."}
{"task_id": "Mbpp/79", "completion": "def word_len(word):\n    return len(word) % 2 != 0"}
{"task_id": "Mbpp/741", "completion": "def all_Characters_Same(string):\n    return len(set(string)) == 1"}
{"task_id": "Mbpp/742", "completion": "def area_tetrahedron(a):\n    return (a**2)*sqrt(3)"}
{"task_id": "Mbpp/743", "completion": "\n    def rotate_right(lst, n):\n        return lst[-n:] + lst[:-n]\n    ```\n\n    ### Test:\n    \n    assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3)==[8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    ```"}
{"task_id": "Mbpp/744", "completion": "\n    def check_none(tuple):\n        return None in tuple\n    ```\n\n    The `check_none` function takes a tuple as input and returns `True` if the tuple contains any `None` value, and `False` otherwise. This function can be used to check if a tuple contains any `None` value."}
{"task_id": "Mbpp/745", "completion": "def divisible_by_digits(startnum, endnum):\n    return [x for x in range(startnum, endnum + 1) if all(x % int(i) == 0 for i in str(x))]\n\nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"}
{"task_id": "Mbpp/746", "completion": "\n    import math\n\n    def sector_area(radius, angle):\n        if angle > 360:\n            return None\n        else:\n            return (angle / 360) * math.pi * radius ** 2\n    ```\n\n    ### Test:\n    \n    assert sector_area(4,45)==6.283185307179586\n    ```"}
{"task_id": "Mbpp/748", "completion": "def capital_words_spaces(string):\n    return ' '.join(word for word in string.split() if word[0].isupper())"}
{"task_id": "Mbpp/749", "completion": "def sort_numeric_strings(lst):\n    # Convert the list of strings to a list of integers\n    lst = [int(x) for x in lst]\n    # Sort the list of integers\n    lst.sort()\n    return lst"}
{"task_id": "Mbpp/750", "completion": "\n    def add_tuple(lst, tpl):\n        return lst + list(tpl)\n    ```\n\n    ### Explanation:\n    The `add_tuple` function takes a list `lst` and a tuple `tpl` as input. It returns the concatenation of `lst` and the list representation of `tpl`. This concatenation satisfies the assertion."}
{"task_id": "Mbpp/751", "completion": "\n    def check_min_heap(arr):\n        n = len(arr)\n        for i in range(n):\n            left_child = 2 * i + 1\n            right_child = 2 * i + 2\n            if left_child < n and arr[i] > arr[left_child]:\n                return False\n            if right_child < n and arr[i] > arr[right_child]:\n                return False\n        return True\n    ```\n    This function iterates through the array and checks if each element is smaller than its left and right children. If any of these conditions are not met, it returns False. If all conditions are met, it returns True."}
{"task_id": "Mbpp/80", "completion": "\n    def tetrahedral_number(n):\n        return n * (n + 1) * (n + 2) // 6\n    ```"}
{"task_id": "Mbpp/752", "completion": "\n    def jacobsthal_num(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return 2 * jacobsthal_num(n-1) + 3 * jacobsthal_num(n-2)\n    ```\n    The function `jacobsthal_num` takes an integer `n` as input and returns the nth Jacobsthal number. It uses a recursive approach to calculate the Jacobsthal numbers. The base cases are when `n` is 0 or 1, and the recursive step is to calculate the next Jacobsthal number using the formula `2 * jacobsthal_num(n-1) + 3 * jacobsthal_num(n-2)`."}
{"task_id": "Mbpp/753", "completion": "def min_k(tuples, k):\n    # Sort the tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list\n    return sorted_tuples[:k]"}
{"task_id": "Mbpp/754", "completion": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"}
{"task_id": "Mbpp/755", "completion": "def second_smallest(lst):\n    lst.sort()\n    return lst[1]"}
{"task_id": "Mbpp/757", "completion": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count\n\nassert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])== 2"}
{"task_id": "Mbpp/758", "completion": "def unique_sublists(lst):\n    unique_sublists = {}\n    for sublist in lst:\n        if tuple(sublist) in unique_sublists:\n            unique_sublists[tuple(sublist)] += 1\n        else:\n            unique_sublists[tuple(sublist)] = 1\n    return unique_sublists"}
{"task_id": "Mbpp/759", "completion": "def is_decimal(string):\n    try:\n        float(string)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/760", "completion": "def unique_Element(lst):\n    return len(set(lst)) == 1"}
{"task_id": "Mbpp/762", "completion": "def check_monthnumber_number(month_number):\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    elif month_number in [4, 6, 9, 11]:\n        return False\n    else:\n        return \"Invalid month number\"\n\nassert check_monthnumber_number(6)==True"}
{"task_id": "Mbpp/763", "completion": "def find_min_diff(arr, n):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n-1):\n        diff = arr[i+1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\nassert find_min_diff((1,5,3,19,18,25),6) == 1"}
{"task_id": "Mbpp/82", "completion": "import math\n\ndef volume_sphere(radius):\n    return (4/3) * math.pi * radius**3"}
{"task_id": "Mbpp/764", "completion": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count"}
{"task_id": "Mbpp/765", "completion": "def is_polite(n):\n    polite_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    for i in range(11, n+1):\n        polite_numbers.append(i)\n        for j in range(1, i):\n            if i % j == 0:\n                polite_numbers.remove(j)\n    return polite_numbers[n-1]"}
{"task_id": "Mbpp/766", "completion": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]"}
{"task_id": "Mbpp/767", "completion": "def get_pairs_count(nums, sum):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == sum:\n                count += 1\n    return count"}
{"task_id": "Mbpp/769", "completion": "def Diff(li1, li2):\n    return (list(set(li1) - set(li2)))"}
{"task_id": "Mbpp/770", "completion": "def odd_num_sum(n):\n    sum = 0\n    for i in range(1, n*2, 2):\n        sum += i**4\n    return sum"}
{"task_id": "Mbpp/771", "completion": "\n    def check_expression(expression):\n        stack = []\n        for char in expression:\n            if char in [\"(\", \"{\", \"[\"]:\n                stack.append(char)\n            else:\n                if not stack:\n                    return False\n                if char == \")\" and stack[-1] != \"(\":\n                    return False\n                if char == \"}\" and stack[-1] != \"{\":\n                    return False\n                if char == \"]\" and stack[-1] != \"[\":\n                    return False\n                stack.pop()\n        return not stack\n    ```\n    The `check_expression` function uses a stack to keep track of the opening brackets. It iterates through the expression, pushing opening brackets onto the stack and popping them off when it encounters a closing bracket. If the stack is empty at the end, the expression is balanced, and the function returns `True`. If the stack is not empty at the end, the expression is not balanced, and the function returns `False`."}
{"task_id": "Mbpp/772", "completion": "\n    def remove_length(string, k):\n        words = string.split()\n        filtered_words = [word for word in words if len(word) != k]\n        return ' '.join(filtered_words)\n    ```\n\n    The `remove_length` function takes a string and an integer `k` as input. It splits the string into words, then filters out words with length `k` using a list comprehension. Finally, it joins the filtered words back into a string and returns the result."}
{"task_id": "Mbpp/773", "completion": "def occurance_substring(string, substring):\n    if substring in string:\n        return substring, string.find(substring), string.rfind(substring)\n    else:\n        return None"}
{"task_id": "Mbpp/775", "completion": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/83", "completion": "def get_Char(string):\n    char_sum = 0\n    for char in string:\n        char_sum += ord(char)\n    return chr(char_sum % 26 + ord('a'))"}
{"task_id": "Mbpp/777", "completion": "\n    def find_sum(lst):\n        unique_elements = set()\n        sum_of_unique = 0\n        for num in lst:\n            if num not in unique_elements:\n                unique_elements.add(num)\n                sum_of_unique += num\n        return sum_of_unique\n    ```\n    The `find_sum` function takes a list of numbers as input and returns the sum of all unique elements in the list. It uses a set to keep track of unique elements and a variable to store the sum. The function iterates through the list, adding each unique element to the set and updating the sum. Finally, it returns the sum of unique elements."}
{"task_id": "Mbpp/778", "completion": "def pack_consecutive_duplicates(lst):\n    result = []\n    current_sublist = []\n    for i in range(len(lst)):\n        if i == 0 or lst[i] != lst[i-1]:\n            if current_sublist:\n                result.append(current_sublist)\n            current_sublist = [lst[i]]\n        else:\n            current_sublist.append(lst[i])\n    if current_sublist:\n        result.append(current_sublist)\n    return result"}
{"task_id": "Mbpp/780", "completion": "\n    def find_combinations(tuples):\n        combinations = []\n        for i in range(len(tuples)):\n            for j in range(i+1, len(tuples)):\n                combinations.append((tuples[i][0] + tuples[j][0], tuples[i][1] + tuples[j][1]))\n        return combinations\n    ```\n\n    The `find_combinations` function takes a list of tuples as input and returns a list of tuples representing the combinations of sums with tuples in the given tuple list. It iterates through the list of tuples and for each pair of tuples, it adds the sum of their elements to the combinations list. Finally, it returns the list of combinations."}
{"task_id": "Mbpp/781", "completion": "\n    def count_divisors(n):\n        count = 0\n        for i in range(1, n+1):\n            if n % i == 0:\n                count += 1\n        return count % 2 == 0\n    ```\n\n    The `count_divisors` function takes an integer `n` as input and returns `True` if the count of divisors of `n` is even, and `False` otherwise. It iterates through all numbers from 1 to `n` and checks if each number is a divisor of `n`. If it is, the count is incremented. Finally, it returns `True` if the count is even and `False` otherwise."}
{"task_id": "Mbpp/782", "completion": "def odd_length_sum(arr):\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                result += sum(arr[i:j+1])\n    return result"}
{"task_id": "Mbpp/783", "completion": "\n    def rgb_to_hsv(r, g, b):\n        r, g, b = r / 255.0, g / 255.0, b / 255.0\n        cmax = max(r, g, b)\n        cmin = min(r, g, b)\n        delta = cmax - cmin\n        if cmax == cmin:\n            h = 0\n        elif cmax == r:\n            h = (60 * ((g - b) / delta) + 360) % 360\n        elif cmax == g:\n            h = (60 * ((b - r) / delta) + 120) % 360\n        elif cmax == b:\n            h = (60 * ((r - g) / delta) + 240) % 360\n        if cmax == 0:\n            s = 0\n        else:\n            s = (delta / cmax) * 100\n        v = cmax * 100\n        return h, s, v\n    ```\n    This function takes in RGB values (r, g, b) and returns the corresponding HSV values (h, s, v). It first normalizes the RGB values to be between 0 and 1, then calculates the HSV values based on the formula provided in the link. The function returns the HSV values as a tuple."}
{"task_id": "Mbpp/784", "completion": "def mul_even_odd(lst):\n    even = []\n    odd = []\n    for i in lst:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return even[0] * odd[0]"}
{"task_id": "Mbpp/785", "completion": "\n    def tuple_str_int(tuple_str):\n        return tuple(map(int, tuple_str[1:-1].split(', ')))\n    ```"}
{"task_id": "Mbpp/786", "completion": "def right_insertion(lst, value):\n    for i in range(len(lst)):\n        if value <= lst[i]:\n            return i\n    return len(lst)"}
{"task_id": "Mbpp/787", "completion": "import re\ndef text_match_three(text):\n    pattern = r'ab{3}'\n    if re.search(pattern,  text):\n        return 'Found a match!'\n    else:\n        return('Not matched')\n\nprint(text_match_three(\"ac\"))\nprint(text_match_three(\"abc\"))\nprint(text_match_three(\"abbb\"))"}
{"task_id": "Mbpp/84", "completion": "def sequence(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return sequence(sequence(n-1) + sequence(n-sequence(n-1)))"}
{"task_id": "Mbpp/788", "completion": "def new_tuple(list, string):\n    return tuple(list + [string])"}
{"task_id": "Mbpp/790", "completion": "def even_position(lst):\n    return all(lst[i] % 2 == 0 for i in range(0, len(lst), 2))"}
{"task_id": "Mbpp/791", "completion": "\n    def remove_nested(t):\n        return tuple(x for x in t if not isinstance(x, tuple))\n    ```\n    The `remove_nested` function takes a tuple `t` as input and returns a new tuple `t2` without the nested tuples. It does this by using a generator expression to filter out the nested tuples and then converting the resulting iterator to a tuple."}
{"task_id": "Mbpp/792", "completion": "\n    def count_list(lst):\n        count = 0\n        for item in lst:\n            if isinstance(item, list):\n                count += 1\n        return count\n    ```\n\n    The `count_list` function takes a list as input and returns the number of lists in the input list. It iterates through the list and checks if each item is a list using the `isinstance` function. If an item is a list, it increments the count. Finally, it returns the count."}
{"task_id": "Mbpp/793", "completion": "def last(arr, x):\n    for i in range(len(arr)-1, -1, -1):\n        if arr[i] == x:\n            return i\n    return -1"}
{"task_id": "Mbpp/794", "completion": "def text_starta_endb(text):\n    return text.startswith(\"a\") and text.endswith(\"b\")"}
{"task_id": "Mbpp/796", "completion": "\n    def return_sum(dict):\n        return sum(dict.values())\n    ```"}
{"task_id": "Mbpp/797", "completion": "def sum_in_range(l, r):\n    sum = 0\n    for i in range(l, r+1):\n        if i % 2 != 0:\n            sum += i\n    return sum"}
{"task_id": "Mbpp/798", "completion": "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total"}
{"task_id": "Mbpp/799", "completion": "def left_rotate(num, d):\n    \"\"\"\n    Rotate the bits of a number to the left by d positions.\n\n    Args:\n    num (int): The number to rotate.\n    d (int): The number of positions to rotate.\n\n    Returns:\n    int: The rotated number.\n    \"\"\"\n    return ((num << d) | (num >> (32 - d))) & 0xFFFFFFFF"}
{"task_id": "Mbpp/85", "completion": "\n    import math\n\n    def surfacearea_sphere(radius):\n        return 4 * math.pi * radius ** 2\n\n    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)\n    ```\n\n    The `surfacearea_sphere` function takes a radius as input and returns the surface area of a sphere with that radius. The `assert` statement checks that the function returns the correct surface area for a sphere with radius 10."}
{"task_id": "Mbpp/800", "completion": "def remove_all_spaces(string):\n    return string.replace(' ', '')"}
{"task_id": "Mbpp/801", "completion": "def test_three_equal(a, b, c):\n    if a == b == c:\n        return 3\n    elif a == b or b == c or a == c:\n        return 2\n    else:\n        return 0"}
{"task_id": "Mbpp/803", "completion": "\n    def is_perfect_square(num):\n        if num < 0:\n            return False\n        if num == 0 or num == 1:\n            return True\n        start = 1\n        end = num\n        while start <= end:\n            mid = (start + end) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return False\n    ```\n\n    The `is_perfect_square` function takes a number `num` as input and returns `True` if the number is a perfect square, and `False` otherwise. It uses a binary search approach to find if the number is a perfect square. If the number is less than 0, it returns `False`. If the number is 0 or 1, it returns `True`. Otherwise, it initializes `start` to 1 and `end` to `num`. It then uses a binary search approach to find if the number is a perfect square. If the mid value squared is equal to the number, it returns `True`. If the mid value squared is less than the number, it updates `start` to `mid + 1`. Otherwise, it updates `end` to `mid - 1`. If the loop completes without finding a perfect square, it returns `False`."}
{"task_id": "Mbpp/804", "completion": "def is_product_even(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "completion": "def max_sum_list(lst):\n    max_sum = 0\n    max_list = []\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_list = sublist\n    return max_list"}
{"task_id": "Mbpp/806", "completion": "def max_run_uppercase(string):\n    max_run = 0\n    current_run = 0\n    for char in string:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    return max_run"}
{"task_id": "Mbpp/807", "completion": "def first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None"}
{"task_id": "Mbpp/808", "completion": "def check_K(tuple, k):\n    if k in tuple:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/809", "completion": "def check_smaller(tuple1, tuple2):\n    for i in range(len(tuple1)):\n        if tuple1[i] >= tuple2[i]:\n            return False\n    return True"}
{"task_id": "Mbpp/7", "completion": "\n    def find_char_long(string):\n        words = string.split()\n        char_long_words = [word for word in words if len(word) >= 4]\n        return char_long_words\n    ```\n\n    The `find_char_long` function takes a string as input and splits it into words. It then iterates through the words, checking if each word has at least 4 characters. If a word meets this criteria, it is added to a list of words that meet the condition. Finally, the function returns the list of words that meet the condition."}
{"task_id": "Mbpp/86", "completion": "\n    def centered_hexagonal_number(n):\n        return n * (2 * n - 1)\n    ```\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on.\n\n    The centered hexagonal number can be calculated using the formula:\n    n(2n-1)\n\n    Where n is the nth centered hexagonal number.\n\n    The centered hexagonal number is a sequence of numbers that are the sum of the hexagonal number and the previous hexagonal number. The first centered hexagonal number is 1, the second is 7, the third is 19, and so on."}
{"task_id": "Mbpp/87", "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    for d in (dict1, dict2, dict3):\n        merged_dict.update(d)\n    return merged_dict"}
{"task_id": "Mbpp/88", "completion": "\n    def freq_count(lst):\n        freq = {}\n        for item in lst:\n            if item in freq:\n                freq[item] += 1\n            else:\n                freq[item] = 1\n        return freq\n    ```\n\n    The `freq_count` function takes a list `lst` as input and returns a dictionary `freq` that contains the frequency of each element in the list. It iterates through the list, and for each element, it checks if it is already in the dictionary. If it is, it increments the count by 1. If it is not, it adds the element to the dictionary with a count of 1. Finally, it returns the dictionary `freq`."}
{"task_id": "Mbpp/89", "completion": "def closest_num(n):\n    \"\"\"\n    Find the closest smaller number than n.\n    \"\"\"\n    return n - 1"}
{"task_id": "Mbpp/90", "completion": "def len_log(words):\n    longest_word = \"\"\n    for word in words:\n        if len(word) > len(longest_word):\n            longest_word = word\n    return len(longest_word)\n\nassert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7"}
{"task_id": "Mbpp/91", "completion": "def find_substring(lst, substring):\n    for string in lst:\n        if substring in string:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "completion": "\n    def is_undulating(num):\n        num_str = str(num)\n        for i in range(1, len(num_str)):\n            if num_str[i] == num_str[i-1]:\n                return False\n        return True\n    ```\n\n    The `is_undulating` function takes a number as input and converts it to a string. It then iterates through the digits of the number and checks if any two consecutive digits are the same. If so, it returns False; otherwise, it returns True."}
{"task_id": "Mbpp/93", "completion": "def power(a, b):\n    return a ** b"}
{"task_id": "Mbpp/94", "completion": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]"}
{"task_id": "Mbpp/95", "completion": "def Find_Min_Length(list_of_lists):\n    min_length = len(list_of_lists[0])\n    for l in list_of_lists:\n        if len(l) < min_length:\n            min_length = len(l)\n    return min_length"}
{"task_id": "Mbpp/8", "completion": "\n    def square_nums(nums):\n        return [num ** 2 for num in nums]\n    ```\n\n    ### Test:\n    \n    assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    ```"}
{"task_id": "Mbpp/96", "completion": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/97", "completion": "def frequency_lists(lists):\n    flattened_list = [item for sublist in lists for item in sublist]\n    frequency_dict = {}\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict"}
{"task_id": "Mbpp/98", "completion": "\n    import math\n\n    def multiply_num(numbers):\n        product = 1\n        for num in numbers:\n            product *= num\n        return product / len(numbers)\n\n    assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)\n    ```\n\n    The `multiply_num` function takes a list of numbers as input and returns the product of all the numbers divided by the length of the list. The assertion checks if the result of the `multiply_num` function is close to -67.2 within a relative tolerance of 0.001."}
{"task_id": "Mbpp/99", "completion": "def decimal_to_binary(decimal):\n    binary = \"\"\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"}
{"task_id": "Mbpp/100", "completion": "def next_smallest_palindrome(n):\n    n = n + 1\n    while not is_palindrome(n):\n        n = n + 1\n    return n\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]"}
{"task_id": "Mbpp/101", "completion": "\n    def kth_element(arr, k):\n        arr.sort()\n        return arr[k-1]\n    ```\n    The `kth_element` function takes an array `arr` and an integer `k` as input. It sorts the array in ascending order and then returns the element at index `k-1`, which is the kth smallest element in the array."}
{"task_id": "Mbpp/102", "completion": "def snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return components[0] + ''.join(x.title() for x in components[1:])"}
{"task_id": "Mbpp/103", "completion": "\n    def eulerian_num(n, m):\n        if n == 0:\n            return 1\n        elif m == 0:\n            return 0\n        else:\n            return (n - m) * eulerian_num(n - 1, m) + eulerian_num(n, m - 1)\n    ```\n    The function `eulerian_num` takes two arguments `n` and `m` and returns the Eulerian number `a(n, m)`. If `n` is 0, the function returns 1. If `m` is 0, the function returns 0. Otherwise, the function recursively calculates the Eulerian number using the formula `a(n, m) = (n - m) * a(n - 1, m) + a(n, m - 1)`."}
{"task_id": "Mbpp/104", "completion": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/105", "completion": "def count(lst):\n    return lst.count(True)"}
{"task_id": "Mbpp/9", "completion": "\n    def find_Rotations(s):\n        # Find the minimum number of rotations required to get the same string\n        n = len(s)\n        for i in range(1, n):\n            if s[i:] + s[:i] == s:\n                return i\n        return 0\n    ```\n\n    The `find_Rotations` function takes a string `s` as input and returns the minimum number of rotations required to get the same string. It iterates through the string and checks if the substring starting from the current index is the same as the original string. If it is, the function returns the index of the rotation. If no rotation is found, the function returns 0."}
{"task_id": "Mbpp/106", "completion": "def add_lists(lst, tup):\n    return tup + tuple(lst)"}
{"task_id": "Mbpp/108", "completion": "\n    def merge_sorted_list(list1, list2, list3):\n        merged_list = list1 + list2 + list3\n        merged_list.sort()\n        return merged_list\n    ```\n\n    ### Test:\n    \n    assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    ```"}
{"task_id": "Mbpp/109", "completion": "def odd_Equivalent(binary_string, rotations):\n    binary_string = binary_string * rotations\n    odd_count = 0\n    for i in range(len(binary_string)):\n        if int(binary_string[i]) % 2 == 1:\n            odd_count += 1\n    return odd_count"}
{"task_id": "Mbpp/111", "completion": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for i in range(1, len(nested_lists)):\n        common_elements = common_elements.intersection(set(nested_lists[i]))\n    return list(common_elements)"}
{"task_id": "Mbpp/113", "completion": "def check_integer(string):\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/115", "completion": "def empty_dit(lst):\n    return all(not d for d in lst)"}
{"task_id": "Mbpp/116", "completion": "def tuple_to_int(t):\n    return int(''.join(map(str, t)))"}
{"task_id": "Mbpp/117", "completion": "def list_to_float(lst):\n    return [tuple(map(float, x)) for x in lst]"}
{"task_id": "Mbpp/118", "completion": "def string_to_list(string):\n    return string.split()"}
{"task_id": "Mbpp/119", "completion": "def search(arr):\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] == arr[mid - 1]:\n            if mid % 2 == 0:\n                right = mid - 2\n            else:\n                left = mid + 1\n        elif arr[mid] == arr[mid + 1]:\n            if mid % 2 == 0:\n                left = mid + 2\n            else:\n                right = mid - 1\n        else:\n            return arr[mid]\n    return arr[left]"}
{"task_id": "Mbpp/11", "completion": "\n    def remove_Occ(string, char):\n        if char in string:\n            string = string.replace(char, '', 1)\n            string = string.replace(char, '', 1)\n        return string\n    ```\n\n    ### Test:\n    \n    assert remove_Occ(\"hello\",\"l\") == \"heo\"\n    ```\n\n    ### Output:\n    ```\n    AssertionError\n    ```\n\n    ### Explanation:\n    The function `remove_Occ` is not working as expected. It is removing only the first occurrence of the given character, but not the last occurrence. The assertion is failing because the function is returning \"heo\" instead of \"he\"."}
{"task_id": "Mbpp/120", "completion": "def max_product_tuple(list_of_tuples):\n    max_product = 0\n    for i in range(len(list_of_tuples)):\n        for j in range(i+1, len(list_of_tuples)):\n            product = abs(list_of_tuples[i][0] * list_of_tuples[j][0]) * abs(list_of_tuples[i][1] * list_of_tuples[j][1])\n            if product > max_product:\n                max_product = product\n    return max_product\n\nassert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36"}
{"task_id": "Mbpp/123", "completion": "def amicable_numbers_sum(n):\n    sum_amicable = 0\n    for i in range(1, n+1):\n        sum_divisors_i = sum_divisors(i)\n        sum_divisors_sum_divisors_i = sum_divisors(sum_divisors_i)\n        if i == sum_divisors_sum_divisors_i and i != sum_divisors_i:\n            sum_amicable += i\n    return sum_amicable\n\ndef sum_divisors(n):\n    sum_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors\n\nassert amicable_numbers_sum(999)==504"}
{"task_id": "Mbpp/124", "completion": "\n    import math\n\n    def angle_complex(z):\n        return math.atan2(z.imag, z.real)\n    ```"}
{"task_id": "Mbpp/125", "completion": "def find_length(binary_string):\n    max_length = 0\n    count_0 = 0\n    count_1 = 0\n    for char in binary_string:\n        if char == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        if count_0 == count_1:\n            max_length = max(max_length, count_0 + count_1)\n        elif count_0 > count_1:\n            count_0 = 0\n            count_1 = 0\n    return max_length"}
{"task_id": "Mbpp/126", "completion": "def sum_common_divisors(num1, num2):\n    common_divisors = []\n    for i in range(1, min(num1, num2) + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            common_divisors.append(i)\n    return sum(common_divisors)\n\nassert sum_common_divisors(10, 15) == 6"}
{"task_id": "Mbpp/127", "completion": "def multiply_int(a, b):\n    return a * b"}
{"task_id": "Mbpp/128", "completion": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]"}
{"task_id": "Mbpp/129", "completion": "\n    def magic_square_test(matrix):\n        # Check if the matrix is a square matrix\n        if len(matrix) != len(matrix[0]):\n            return False\n\n        # Calculate the sum of the first row\n        row_sum = sum(matrix[0])\n\n        # Check if the sum of each row is equal to the row_sum\n        for row in matrix:\n            if sum(row) != row_sum:\n                return False\n\n        # Check if the sum of each column is equal to the row_sum\n        for i in range(len(matrix)):\n            col_sum = 0\n            for j in range(len(matrix)):\n                col_sum += matrix[j][i]\n            if col_sum != row_sum:\n                return False\n\n        # Check if the sum of the diagonals is equal to the row_sum\n        diag_sum1 = 0\n        diag_sum2 = 0\n        for i in range(len(matrix)):\n            diag_sum1 += matrix[i][i]\n            diag_sum2 += matrix[i][len(matrix)-1-i]\n        if diag_sum1 != row_sum or diag_sum2 != row_sum:\n            return False\n\n        return True\n    ```\n\n    This function first checks if the matrix is a square matrix. Then, it calculates the sum of the first row and checks if the sum of each row, column, and diagonal is equal to the row_sum. If all the conditions are met, the function returns True, indicating that the matrix is a magic square. Otherwise, it returns False."}
{"task_id": "Mbpp/130", "completion": "\n    def max_occurrences(lst):\n        # Create a dictionary to store the frequency of each item\n        freq_dict = {}\n        for item in lst:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    \n        # Find the item with maximum frequency\n        max_freq = max(freq_dict.values())\n        max_items = [item for item, freq in freq_dict.items() if freq == max_freq]\n    \n        # Return the item with maximum frequency\n        return max_items[0]\n    \n    # Test the function\n    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2\n    ```\n\n    This function first creates a dictionary to store the frequency of each item in the input list. It then finds the item with maximum frequency and returns it. The assert statement at the end of the code tests the function with the given example."}
{"task_id": "Mbpp/131", "completion": "\n    def reverse_vowels(s):\n        vowels = \"aeiouAEIOU\"\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return ''.join(s)\n    ```\n\n    This function uses two pointers, `i` and `j`, to iterate through the string `s` from both ends. It swaps the vowels found at `i` and `j`, and moves the pointers towards the center. The function returns the reversed string."}
{"task_id": "Mbpp/12", "completion": "def sort_matrix(matrix):\n    # Calculate the sum of each row in the matrix\n    row_sums = [sum(row) for row in matrix]\n    \n    # Sort the matrix based on the row sums\n    sorted_matrix = [x for _, x in sorted(zip(row_sums, matrix))]\n    \n    return sorted_matrix"}
{"task_id": "Mbpp/132", "completion": "def tup_string(tup):\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "completion": "def sum_negativenum(numbers):\n    sum_neg = 0\n    for num in numbers:\n        if num < 0:\n            sum_neg += num\n    return sum_neg\n\nassert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32"}
{"task_id": "Mbpp/135", "completion": "def hexagonal_num(n):\n    return n*(2*n-1)"}
{"task_id": "Mbpp/137", "completion": "import math\n\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    return zero_count / non_zero_count"}
{"task_id": "Mbpp/138", "completion": "def is_Sum_Of_Powers_Of_Two(num):\n    if num == 0:\n        return True\n    elif num < 0:\n        return False\n    else:\n        while num > 0:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                return False\n        return True"}
{"task_id": "Mbpp/139", "completion": "\n    import math\n\n    def circle_circumference(radius):\n        return 2 * math.pi * radius\n    ```\n\n    The `circle_circumference` function takes the radius of a circle as input and returns its circumference. It uses the `math.pi` constant from the `math` module to calculate the circumference. The `math.isclose` function is used to compare the calculated circumference with the expected value, with a relative tolerance of 0.001."}
{"task_id": "Mbpp/140", "completion": "\n    def extract_singly(list_of_lists):\n        return [item for sublist in list_of_lists for item in sublist]\n    ```\n    The `extract_singly` function takes a list of lists as input and uses a list comprehension to flatten the list of lists into a single list of numbers. It then converts the flattened list into a set to remove duplicates and return the set of numbers."}
{"task_id": "Mbpp/141", "completion": "def pancake_sort(lst):\n    for i in range(len(lst), 1, -1):\n        max_index = lst.index(max(lst[:i]))\n        if max_index != i - 1:\n            lst = lst[:max_index+1][::-1] + lst[max_index+1:]\n            lst = lst[:i][::-1] + lst[i:]\n    return lst"}
{"task_id": "Mbpp/142", "completion": "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/143", "completion": "\n    def find_lists(tuple_of_lists):\n        count = 0\n        for item in tuple_of_lists:\n            if isinstance(item, list):\n                count += 1\n        return count\n    ```\n\n    The `find_lists` function takes a tuple of lists as input and returns the number of lists present in the tuple. It iterates through the elements of the tuple and checks if each element is a list using the `isinstance` function. If an element is a list, it increments the count. Finally, it returns the count of lists in the tuple."}
{"task_id": "Mbpp/14", "completion": "\n    def find_Volume(base, height, length):\n        return (base * height * length) / 2\n    ```"}
{"task_id": "Mbpp/145", "completion": "def max_Abs_Diff(arr):\n    max_diff = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff"}
{"task_id": "Mbpp/160", "completion": "\n    def find_solution(a, b, n):\n        for x in range(n + 1):\n            for y in range(n + 1):\n                if a * x + b * y == n:\n                    return x, y\n        return None\n    ```\n    This function iterates through all possible values of x and y and checks if the equation ax + by = n holds for any pair of integers. If it does, it returns the pair as a tuple. If no solution is found, it returns None."}
{"task_id": "Mbpp/161", "completion": "\n    def remove_elements(lst1, lst2):\n        return [x for x in lst1 if x not in lst2]\n    ```\n\n    The `remove_elements` function takes two lists as input and returns a new list containing all elements from the first list that are not present in the second list. The function uses a list comprehension to filter out the elements from the first list that are not in the second list."}
{"task_id": "Mbpp/162", "completion": "def sum_series(n):\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return n + sum_series(n-2)"}
{"task_id": "Mbpp/164", "completion": "def are_equivalent(a, b):\n    def sum_divisors(n):\n        divisors = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisors.append(i)\n        return sum(divisors)\n\n    return sum_divisors(a) == sum_divisors(b)\n\nassert are_equivalent(36, 57) == False"}
{"task_id": "Mbpp/165", "completion": "\n    def count_char_position(string):\n        count = 0\n        for i in range(len(string)):\n            if string[i].lower() == chr(97 + i):\n                count += 1\n        return count\n    ```\n\n    The `count_char_position` function takes a string as input and iterates through each character, checking if it is the same as the character at the same position in the English alphabet (case insensitive). If it is, the count is incremented. Finally, the function returns the total count of characters that satisfy the condition."}
{"task_id": "Mbpp/166", "completion": "\n    def find_even_pair(numbers):\n        even_pairs = 0\n        for i in range(len(numbers)):\n            for j in range(i+1, len(numbers)):\n                if (numbers[i] ^ numbers[j]) % 2 == 0:\n                    even_pairs += 1\n        return even_pairs\n    ```\n    The function iterates through the list of numbers and for each pair of numbers, it checks if their bitwise XOR is even. If it is, the function increments the count of even pairs. Finally, the function returns the count of even pairs."}
{"task_id": "Mbpp/167", "completion": "\n    def next_power_of_2(n):\n        if n == 0:\n            return 1\n        else:\n            return 2 ** (n - 1).bit_length()\n    ```\n    The `bit_length` method returns the number of bits required to represent the number in binary. By subtracting 1 from this value and taking the bitwise AND with the original number, we can find the smallest power of 2 greater than or equal to n."}
{"task_id": "Mbpp/168", "completion": "def frequency(lst, num):\n    return lst.count(num)"}
{"task_id": "Mbpp/170", "completion": "\n    def sum_range_list(lst, start, end):\n        return sum(lst[start:end+1])\n    ```\n\n    The `sum_range_list` function takes a list `lst`, an integer `start`, and an integer `end` as input. It then returns the sum of all elements in the list within the range specified by `start` and `end`. The `sum` function is used to calculate the sum of the elements in the specified range."}
